[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MMON-GCM",
    "section": "",
    "text": "This code does not work with python 3.10 because of a dependency issue with Escher: https://github.com/zakandrewking/escher/issues/377 . So make sure you install the package in a venv with e.g. python 3.9.\n\nClone the repo from GitHub.\nMake a venv with e.g. conda: conda create --name mmon-gcm python=3.9\nInstall the package and dependencies in that virtualenv by running pip install -e . in the root of the repo\nRun the notebook scripts in the order that they are numbered.\n\nThe project uses nbdev2 to autocreate packages and documentation from jupyter notebooks."
  },
  {
    "objectID": "1.2_defining_parameters.html",
    "href": "1.2_defining_parameters.html",
    "title": "Finding parameters",
    "section": "",
    "text": "In order to constrain the model using photons, osmolarity, and co2 intake, it is necessary to have the required parameters"
  },
  {
    "objectID": "1.2_defining_parameters.html#photons",
    "href": "1.2_defining_parameters.html#photons",
    "title": "Finding parameters",
    "section": "Photons",
    "text": "Photons\nThe value for photon reflectance and transmission from Zhu et al (2010)\n\n# proportion of photons absorbed by the leaf\nmodelparameters[\"P_abs\"] = [0.9, r\"Dimensionless\", \"Zhu, Long, and Ort (2010)\"]\n\nThe value for the thickness of an Arabidopsis leaf from Wuyts et al (2021)\n\nmodelparameters[\"T_l\"] = [0.017 * 10 ** -2, r\"m\", \"Wuyts et al. (2010)\"]\n\nThe are of the leaf being simulated was fixed at 1m\\(^2\\)\n\nmodelparameters[\"A_l\"] = [1, r\"m$^2$\", \"Fixed\"]\n\nThe average volume of an Arabidopsis guard cell as the midpoint of the values given in table 1 of Jezek and Blatt (2017)\n\nj_b_upper = 0.65\nj_b_lower = 0.3\nV_gc_ind = (j_b_lower+j_b_upper)/2  # pL\nV_gc_ind = V_gc_ind * 10**-12  # dm3\nmodelparameters[\"V_gc_ind\"] = [V_gc_ind, r\"dm$^3$\", \"Jezek and Blatt (2017)\"]\n\nThe photosynthetic efficient of guard cells compared to the mesophyll was taken from Lawson (2003).\n\nIn leaves of all species the values of photosynthetic efficiency for guard cells were either indistinguishable from or only slightly lower (minimum of 79%) than those of the underlying, spongy mesophyll cells.\n\nI therefore took the average of 100% and 79%, 90%.\n\nmodelparameters[\"FqFm\"] = [0.9, r\"Dimensionless\", \"Lawson (2003)\"]\n\nThe proportion of the number of chloroplasts in guard cells compared to mesophyll cells is taken as the ratio of the midpoint of values for each cell type in Fujiwara et al (2019)\n\nupper_gc = 5.5\nlower_gc = 3.5\nmidpoint_gc = (lower_gc+upper_gc)/2\n\nupper_me = 100\nlower_me = 30\nmidpoint_me = (upper_me+lower_me)/2\n\nR_ch = midpoint_gc/midpoint_me\n\nmodelparameters[\"R_ch\"] = [R_ch, r\"Dimensionless\", \"Fujiwara, Sanjaya, and Itoh (2019)\"]\n\nThe proportion of the leaf that is air from Earles et al (2018) for Guzmania zahnii from Table 2.\n\nmodelparameters[\"L_air\"] = [0.37, r\"Dimensionless\", \"Earles et al. (2018)\"]\n\nThe proportion of the leaf that is epidermis from Wuyts et al 2010\n\nmodelparameters[\"L_epidermis\"] = [0.15, r\"Dimensionless\", \"Wuyts et al. (2010)\"]"
  },
  {
    "objectID": "1.2_defining_parameters.html#osmolarity",
    "href": "1.2_defining_parameters.html#osmolarity",
    "title": "Finding parameters",
    "section": "Osmolarity",
    "text": "Osmolarity\nWang 2017 use a value of 0.751 to be the propotion of the Guard Cell that is vacuole\n\nmodelparameters[\"Vac_frac\"] = [0.751, r\"Dimensionless\",\n                               \"Wang et al. (2017)\"]  # proportion of guard cell that is vacuole\n\nThe temperature in the model is taken to be 23C used by Horrer et al 2016.\n\nmodelparameters[\"T\"] = [273.15+23, \"K\", \"Horrer et al. (2016)\"]\n\nIdeal gas constant, from NIST, (reference Tiesinga2019)\n\nR = 8.205*10**(-5)  # m3atmK-1mol-1\nR = R*10**3  # dm3atmK-1mol-1\nmodelparameters[\"R\"] = [R, r\"dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\", \"Tiesinga et al. (2019)\"]\n\nThe density of guard cells per m\\(^2\\) of leaf was taken by multiplying the density of stomata from Papanatsiou et al 2016 by two. This only takes into accound the abaxial surface of the leaf. Strangely, Flutsch et al (2020) had 98 mm\\(^2\\), which is significantly less.\n\nmodelparameters[\"N_gcs\"] = [290 * 10 ** 6 * 2.0, r\"GCs$\\cdot$m$^{-2}$\", \"Papanatsiou, Amtmann, and Blatt (2016)\"]\n\nThe following parameters required for osmolarity are based on the updated OnGuard model (Wang et al 2017).\n\nmodelparameters[\"n\"] = [2.5, \"atm\", \"Wang et al. (2017)\"]\nmodelparameters[\"m\"] = [0.8, r\"atm$\\cdot$µm$^{-1}$\", \"Wang et al. (2017)\"]\nmodelparameters[\"r\"] = [0.05 * 10 ** (-12), r\"dm$^3$ µm$^{-1}$\", \"Wang et al. (2017)\"]\nmodelparameters[\"s\"] = [0.3 * 10 ** (-12), r\"dm$^3$\", \"Wang et al. (2017)\"]\n\n\napoplastic_concs_wang_2017 = {\n    \"K\": 10,\n    \"Ca\": 1,\n    \"Cl\": 12,\n    \"Suc\": 0.01,\n    \"MH2\": 3.2*10**(-6),\n    \"MH\": 7.9*10**(-5),\n    \"M\": 0.00999,\n}\napoplastic_conc_wang_2017 = sum(apoplastic_concs_wang_2017.values())\n\n\nmodelparameters[\"C_apo\"] = [apoplastic_conc_wang_2017*10 **\n                            (-3), r\"mol$\\cdot$dm$^{-3}$\", \"Wang et al. (2017)\"]  # concentration of osmolytes in the apoplast"
  },
  {
    "objectID": "1.2_defining_parameters.html#apertures",
    "href": "1.2_defining_parameters.html#apertures",
    "title": "Finding parameters",
    "section": "Apertures",
    "text": "Apertures\nWe use as a source of apertures those from Horrer et al (2016). The list is apertures for the four phases of the model.\n\nmodelparameters[\"A_closed\"] = [1.6, r\"µm\", \"Horrer et al. (2016)\"]\nmodelparameters[\"A_open\"] = [2.75, r\"µm\", \"Horrer et al. (2016)\"]\n\n\nmodelparameters_df = pd.DataFrame.from_dict(modelparameters, orient=\"index\", columns=[\"Value\", \"Units\", \"Source\"])\n\n\nmodelparameters_df\n\n\n\n\n\n  \n    \n      \n      Value\n      Units\n      Source\n    \n  \n  \n    \n      P_abs\n      9.000000e-01\n      Dimensionless\n      Zhu, Long, and Ort (2010)\n    \n    \n      T_l\n      1.700000e-04\n      m\n      Wuyts et al. (2010)\n    \n    \n      A_l\n      1.000000e+00\n      m$^2$\n      Fixed\n    \n    \n      V_gc_ind\n      4.750000e-13\n      dm$^3$\n      Jezek and Blatt (2017)\n    \n    \n      FqFm\n      9.000000e-01\n      Dimensionless\n      Lawson (2003)\n    \n    \n      R_ch\n      6.923077e-02\n      Dimensionless\n      Fujiwara, Sanjaya, and Itoh (2019)\n    \n    \n      L_air\n      3.700000e-01\n      Dimensionless\n      Earles et al. (2018)\n    \n    \n      L_epidermis\n      1.500000e-01\n      Dimensionless\n      Wuyts et al. (2010)\n    \n    \n      Vac_frac\n      7.510000e-01\n      Dimensionless\n      Wang et al. (2017)\n    \n    \n      T\n      2.961500e+02\n      K\n      Horrer et al. (2016)\n    \n    \n      R\n      8.205000e-02\n      dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\n      Tiesinga et al. (2019)\n    \n    \n      N_gcs\n      5.800000e+08\n      GCs$\\cdot$m$^{-2}$\n      Papanatsiou, Amtmann, and Blatt (2016)\n    \n    \n      n\n      2.500000e+00\n      atm\n      Wang et al. (2017)\n    \n    \n      m\n      8.000000e-01\n      atm$\\cdot$µm$^{-1}$\n      Wang et al. (2017)\n    \n    \n      r\n      5.000000e-14\n      dm$^3$ µm$^{-1}$\n      Wang et al. (2017)\n    \n    \n      s\n      3.000000e-13\n      dm$^3$\n      Wang et al. (2017)\n    \n    \n      C_apo\n      2.302007e-02\n      mol$\\cdot$dm$^{-3}$\n      Wang et al. (2017)\n    \n    \n      A_closed\n      1.600000e+00\n      µm\n      Horrer et al. (2016)\n    \n    \n      A_open\n      2.750000e+00\n      µm\n      Horrer et al. (2016)\n    \n  \n\n\n\n\n\nmodelparameters_df.to_csv(\"../inputs/arabidopsis_parameters.csv\")"
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html",
    "href": "4.3_analyse_alternative_flux_modes.html",
    "title": "Analysing alternative flux modes",
    "section": "",
    "text": "def visualise_graph(graph):\n\n    cyto = CytoscapeWidget()\n    cyto.graph.add_graph_from_networkx(subgraph)\n\n    cyto.set_style(\n        [\n            {\n                \"selector\": \"node\",\n                \"style\": {\n                    \"font-family\": \"helvetica\",\n                    \"font-size\": \"5px\",\n                    \"label\": \"data(id)\",\n                },\n            },\n            {\n                \"selector\": \"edge\",\n                \"style\": {\n                    \"font-family\": \"helvetica\",\n                    \"font-size\": \"5px\",\n                    \"label\": \"data(weight)\",\n                },\n            },\n        ]\n    )\n\n    # cyto.set_layout(name='circle')\n    cyto.set_layout(name=\"cose\")\n\n    return cyto\nAs we observed variability in the flux solutions (see solution files, we wanted to see how much our conclusions rely on the assumption that the optimal solution minimises enzyme fluxes. We want to know: - Is the variability significant? How much deviation is there? - How typical is our pFBA solution, are our conclusions reasonable? - What are the alternative flux modes when there is variation? Are they actually different pathways? Do they imply a different biological story?\nSee Notebook 5.1 for the theory behind the generation of the data analysed in this notebook, based on the method for accounting for enzyme costs outlined in Cheung et al. (2015). For each scenario in the paper the model was solved for 1000 random weights, using the script in Notebook 5.2. This notebook analyses these solutions in two ways: 1. Looking at the pearson correlation coefficients: > “The flux distributions predicted by cost-weighted FBA can be used to identify reactions that operate together or in parallel by calculating the Pearson correlation coefficient (r) for the set of reaction fluxes. This approach is similar to the concepts of reaction correlation coefficient (Poolman et al., 2007) and flux correlation (Poolman et al., 2009) used in conventional FBA, and it leads to a set of r values for the small metabolic network (Table II). Reactions that operate together have a positive r (e.g. between R5 and R6); reactions that work against each other (e.g. in parallel pathways) have a negative r (e.g. between R1, R2, and R3); and reactions that support fluxes with no necessary correlation have r close to 0 (e.g. between R1 and R4). These reaction correlation coefficients complement the flux range information from FVA by characterizing sets of reactions that operate together or in parallel. While alternative metabolic routes can be easily identified by inspection in a small metabolic network (Fig. 1), this is seldom possible in large-scale models with hundreds or even thousands of reactions.” (Cheung et al., 2015, p. 2) 2. Looking at the fluxes when the solutions are averaged: > “However, by varying the weightings and generating an averaged solution, it is made clear that there are multiple ways in which the network might function. The averaged solution is not an optimal solution for the conventional FBA problem of flux minimization with uniform weighting (Table I shows that the sum of fluxes for a model with equal weightings is 2 units, whereas the averaged solution gives 2.161 units), but it does emphasize the potential contribution of alternative pathways. These may or may not operate simultaneously, but without further biochemical knowledge, it is not possible to rule out the possibility that all the pathways in the averaged solution contribute to the flux distribution.” (Cheung et al., 2015, p. 2)\nNaN is observed for correlation where there is no standard deviation in one column."
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#how-different-is-the-average-solution-different-from-the-pfba-solution",
    "href": "4.3_analyse_alternative_flux_modes.html#how-different-is-the-average-solution-different-from-the-pfba-solution",
    "title": "Analysing alternative flux modes",
    "section": "How different is the average solution different from the pFBA solution?",
    "text": "How different is the average solution different from the pFBA solution?\n\nThis will tell us whether our use of pFBA, and the way the solver picks equivalent reactions, has biased the reactions that show flux in the solutions we present\nAs the method is designed to add variability, comparing with the average is better than comparing with the maximal/minimal solutions, because the further from the mean the more biologically-unrealistic the solution becomes. This is the range that FVA gives.\nWe use percentage difference rather than absolute to see differences that would meaningfully affect our conclusions. If there are absolute values that are important then they will still show up because they will make up a big proportion of the reaction that they are important to, even if it’s small for other reactions."
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#do-the-fluxes-that-decrease-in-absolute-terms-from-pfba-to-the-average-flux-solution-correlate-with-one-another",
    "href": "4.3_analyse_alternative_flux_modes.html#do-the-fluxes-that-decrease-in-absolute-terms-from-pfba-to-the-average-flux-solution-correlate-with-one-another",
    "title": "Analysing alternative flux modes",
    "section": "Do the fluxes that decrease (in absolute terms) from pFBA to the average flux solution, correlate with one another?",
    "text": "Do the fluxes that decrease (in absolute terms) from pFBA to the average flux solution, correlate with one another?\nBasically what we’re looking at here is how many different “pFBA pathways” potentially have alternatives. Is it all one pathway or different ones?\nHere we only calculate the pearson for the reactions that are different, to speed things up:\nThis doesn’t currently work because of this bug: https://github.com/zakandrewking/escher/issues/377 pfba_variable_pathways.style.apply( lambda x: [ “background: red” if abs(x[v]) > significance_threshold and v != x.name else “” for v in x.index ], axis=1, )\n\nsubgraph = G\n\ncyto = CytoscapeWidget()\ncyto.graph.add_graph_from_networkx(subgraph)\n\ncyto.set_style(\n    [\n        {\n            \"selector\": \"node\",\n            \"style\": {\n                \"font-family\": \"helvetica\",\n                \"font-size\": \"5px\",\n                \"label\": \"data(id)\",\n            },\n        },\n        {\n            \"selector\": \"edge\",\n            \"style\": {\n                \"font-family\": \"helvetica\",\n                \"font-size\": \"5px\",\n                \"label\": \"data(weight)\",\n            },\n        },\n    ]\n)\n\n# cyto.set_layout(name='circle')\ncyto.set_layout(name=\"cose\")\n\ncyto\n\n\n\n\n\nimport os\n\nimport pandas as pd\n\n\ncsv_path = input_dir + \\\n    f'/alternative_weights_reactions/{light}_{atpase_dict[atpase_constrained]}_{starch_dict[starch_knockout]}.csv'\nreactions_threshold_df = get_reactions_to_investigate(csv_path)\n\n\nfor row in reactions_threshold_df.iterrows():\n    reaction_to_investigate = row[0]\n    threshold = row[1][0]\n\n    correlation_df = get_reactions_correlated_to_named(reaction_to_investigate, pearson_df, threshold)\n\n    subgraphs_list = get_list_of_subgraphs_from_correlation_df(correlation_df, threshold)\n\n    alternatives_map = mmon_gcm.analysing.get_pfba_pathways_map(subgraphs_list, map_path, json_model)\n\n    alternatives_map.save_html(\n        output_dir + f'/alternative_weighting/analysis/{light}_{atpase_dict[atpase_constrained]}_{starch_dict[starch_knockout]}_{reaction_to_investigate}.html')\n\n\nvisualise_graph(subgraphs_list)"
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#notes-on-alternative-pathways",
    "href": "4.3_analyse_alternative_flux_modes.html#notes-on-alternative-pathways",
    "title": "Analysing alternative flux modes",
    "section": "Notes on alternative pathways:",
    "text": "Notes on alternative pathways:\n\nblue_unconstrained_wt\n\nMALIC_NAD_RXN_m_gc_2: Needed to use threshold of 0.4 to separate pathways, but can see that it’s PEP carboxykinase + PEP dephosphorylase vs MALIC NAD. Although the conversion of MAL->OX in the mitochondria pops up for only the PEP carboxykinase route, this must also be used for MALIC.\nACONITATEDEHYDR_RXN_m_gc_2: At 0.1 threshold there’s a lot of mess but drop it down to 0.4 and it’s just whether or not this reaction happens in the mitochondrion or cytoplasm\nSUCCCOASYN_RXN_m_gc_2: At 0.1 this includes some other reactions, but at 0.2 with pFBA this stage of the TCA cycle produces ATP which is then converted to GTP. The alternative is the direct production of GTP. Presumably this offers some sum-of-fluxes benefit because it doesn’t require dealing with GTP.\nPHOSGLYPHOS_RXN_c_gc_2: Used 0.25, and looks like this is just a question of whether ATP is produced in the plastid or in the cytoplasm, and shuffling it around.\n3PGAREARR_RXN_c_gc_2: Looks like the same as above\n\n\n\nblue_unconstrained_ko\nThis looks the same as blue_unconstrained_wt. As the solutions were the same that makes sense.\n\n\nblue_constrained_wt\n\nMALIC_NAD_RXN_m_gc_2: Needed to use threshold of 0.4 to separate pathways, but can see that it’s PEP carboxykinase + PEP dephosphorylase vs MALIC NAD. Although the conversion of MAL->OX in the mitochondria pops up for only the PEP carboxykinase route, this must also be used for MALIC.\nACONITATEDEHYDR_RXN_m_gc_2: At 0.1 threshold there’s a lot of mess but drop it down to 0.4 and it’s just whether or not this reaction happens in the mitochondrion or cytoplasm\nSUCCCOASYN_RXN_m_gc_2: At 0.1 this includes some other reactions, but at 0.2 with pFBA this stage of the TCA cycle produces ATP which is then converted to GTP. The alternative is the direct production of GTP. Presumably this offers some sum-of-fluxes benefit because it doesn’t require dealing with GTP.\n\n\n\nblue_constrained_ko\n\nRXN_1461_v_gc_2 (Sucrose breakdown in vacuole): Alternative is an equiavlent pathway via fructan that has a higher sum-of-fluxes.\nK_c_gc_Linker_2: This is to do with basal osmolarity. K+ is correlated with all of the charged osmolytes in the cytoplasm, then alternatives are the others that can accumulate in the cytoplasm.\nPEPDEPHOS_RXN_c_gc_2: Needed to use threshold of 0.4 to separate pathways, but can see that it’s PEP carboxykinase + PEP dephosphorylase vs MALIC NAD. Although the conversion of MAL->OX in the mitochondria pops up for only the PEP carboxykinase route, this must also be used for MALIC.\nACONITATEDEHYDR_RXN_m_gc_2: This is just whether the reaction happens in the mitochondria or whether everything is shuttled to the cytoplasm to do it and then shuttled back again\nSUCCCOASYN_RXN_m_gc_2: With pFBA this stage of the TCA cycle produces ATP which is then converted to GTP. The alternative is the direct production of GTP. Presumably this offers some sum-of-fluxes benefit because it doesn’t require dealing with GTP.\n\n\n\nwhite_constrained_wt\n\nPHOSGLYPHOS_RXN_c_gc_2: This is just whether it happens in the plastid or the cytosol\nTRIOSEPISOMERIZATION_RXN_p_gc_2: Again, just whether it happens in the plastid or the cytosol"
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#white_constrained_ko",
    "href": "4.3_analyse_alternative_flux_modes.html#white_constrained_ko",
    "title": "Analysing alternative flux modes",
    "section": "white_constrained_ko",
    "text": "white_constrained_ko\n\nPHOSGLYPHOS_RXN_c_gc_2: This is just whether it happens in the plastid or the cytosol\nTRIOSEPISOMERIZATION_RXN_p_gc_2: Whether it happens in the plastid or the cytosol\nGLUC1PURIDYLTRANS_RXN_c_gc_2: Needs to be 0.52 to separate into two subgraphs. Basically two ways of getting between GLC and GLC_1_P. One via UDP and one via GDP glucose.\nK_c_gc_Linker_2:This is to do with basal osmolarity. K+ is correlated with all of the charged osmolytes in the cytoplasm, then alternatives are the others that can accumulate in the cytoplasm.\nSER_pc_gc_2: Whether SER is used or is converted to GLY and used.\nRXN_1461_v_gc_2: Whether to use an equivalent reaction via FRUCTAN."
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#nops_constrained_wt",
    "href": "4.3_analyse_alternative_flux_modes.html#nops_constrained_wt",
    "title": "Analysing alternative flux modes",
    "section": "nops_constrained_wt",
    "text": "nops_constrained_wt\n\nPHOSGLYPHOS_RXN_c_gc_2: Used 0.32, whether it’s in the plastid or cytosol.\nTRIOSEPISOMERIZATION_RXN_p_gc_2: Same as above, including 0.32. Just whether it’s in plastid or cytosol.\nK_v_gc_Linker_2: Used 0.11. This is just shuffling things between c and v.\nSUCCCOASYN_RXN_m_gc_2: With pFBA this stage of the TCA cycle produces ATP which is then converted to GTP. The alternative is the direct production of GTP. Presumably this offers some sum-of-fluxes benefit because it doesn’t require dealing with GTP."
  },
  {
    "objectID": "4.3_analyse_alternative_flux_modes.html#nops_constrained_ko",
    "href": "4.3_analyse_alternative_flux_modes.html#nops_constrained_ko",
    "title": "Analysing alternative flux modes",
    "section": "nops_constrained_ko",
    "text": "nops_constrained_ko\n\nK_v_gc_Linker_2: Used 0.11. This is just shuffling things between c and v.\nSUCCCOASYN_RXN_m_gc_2: With pFBA this stage of the TCA cycle produces ATP which is then converted to GTP. The alternative is the direct production of GTP. Presumably this offers some sum-of-fluxes benefit because it doesn’t require dealing with GTP."
  },
  {
    "objectID": "1.1_buildingmodel.html",
    "href": "1.1_buildingmodel.html",
    "title": "Building model",
    "section": "",
    "text": "import cobra\nimport pandas as pd\nfrom mmon_gcm.buildingediting import (\n    add_linkers,\n    add_metabolite,\n    add_metabolites_to_reaction_multi,\n    add_reaction,\n    check_number_of_models,\n    set_bounds_multi,\n    split_model,\n)\n\n\nmodel = cobra.io.read_sbml_model(\"../models/PlantCoreMetabolism_v1_2_2_3fbc.xml\")\n\nNo objective coefficients in model. Unclear what should be optimized"
  },
  {
    "objectID": "1.1_buildingmodel.html#add-charge-to-model",
    "href": "1.1_buildingmodel.html#add-charge-to-model",
    "title": "Building model",
    "section": "Add charge to model",
    "text": "Add charge to model\n\ncharges = pd.read_csv(\"../inputs/charges.csv\")\ncharges.set_index(\"Metabolite\")\nfor index, row in charges.iterrows():\n    model.metabolites.get_by_id(row[1]).charge = row[0]"
  },
  {
    "objectID": "1.1_buildingmodel.html#changes-to-both-cells",
    "href": "1.1_buildingmodel.html#changes-to-both-cells",
    "title": "Building model",
    "section": "Changes to Both Cells",
    "text": "Changes to Both Cells\n\nK+\n\nfor metabolite in model.metabolites:\n    if \"KI_\" in metabolite.id:\n        metabolite.id = metabolite.id[:1] + metabolite.id[-2:]\n        metabolite.name = metabolite.id\nmodel.reactions.K_rev_vc.name = \"K_cv\"\nmodel.reactions.K_rev_vc.id = \"K_cv\"\nmodel.metabolites.K_e.charge = 1\n\n\n\nCl-\n\nadd_metabolite(model, \"Cl_e\", \"e\", multi=False)\nadd_metabolite(model, \"Cl_c\", \"c\", multi=False)\nadd_metabolite(model, \"Cl_v\", \"v\", multi=False)\nmodel.metabolites.Cl_e.notes = {\"INCHI\": [\"InChI=1S/ClH/h1H/p-1\"], \"SMILES\": [\"Cl-\"]}\nmodel.metabolites.Cl_e.charge = -1\nmodel.metabolites.Cl_c.notes = model.metabolites.Cl_e.notes.copy()\nmodel.metabolites.Cl_c.charge = -1\nmodel.metabolites.Cl_v.notes = model.metabolites.Cl_e.notes.copy()\nmodel.metabolites.Cl_v.charge = -1\n\nadd_reaction(model, \"Cl_tx\", multi=False)\nmodel.reactions.Cl_tx.add_metabolites({\"Cl_e\": 1})\nmodel.reactions.Cl_tx.lower_bound = -1000\n\n\n\nCIT\n\nfor metabolite in model.metabolites:\n    if \"CIT_\" in metabolite.id and \"aCIT\" not in metabolite.id:\n        metabolite.charge = -3\n\n\nmodel.metabolites.aCIT_v.charge = -2\n\n\n\nMAL\n\nfor metabolite in model.metabolites:\n    if \"MAL_\" in metabolite.id and \"aMAL\" not in metabolite.id:\n        metabolite.charge = -2\n\n\nmodel.metabolites.aMAL_v.charge = -1\n\n\nadd_metabolite(model, \"MAL_e\", \"e\", multi=False)\nadd_metabolite(model, \"aMAL_e\", \"e\", multi=False)\n\n\n\n        \n            \n                Metabolite identifieraMAL_e\n            \n                NameaMAL_e\n            \n                Memory address\n                0x7f99c96efee0\n            \n                FormulaNone\n            \n                Compartmente\n            \n                In 0 reaction(s)\n                    \n                    \n            \n        \n\n\n\nmodel.metabolites.MAL_e.notes = model.metabolites.MAL_v.notes.copy()\nmodel.metabolites.aMAL_e.notes = model.metabolites.aMAL_v.notes.copy()\nmodel.metabolites.MAL_e.charge = model.metabolites.MAL_v.charge\nmodel.metabolites.aMAL_e.charge = model.metabolites.aMAL_v.charge\n\n\nadd_reaction(model, \"MAL_tx\", multi=False)\nmodel.reactions.MAL_tx.add_metabolites(\n    {\n        \"MAL_e\": 0.7,\n        \"aMAL_e\": 0.3,\n    }\n)\nmodel.reactions.MAL_tx.lower_bound = -1000\n\n\n\nMAL Anion Export Channel (Cl/Mal)\n\nadd_reaction(model, \"MAL_ce\", multi=False)\nmodel.reactions.MAL_ce.name = \"MAL R/S-Type Anion Channel\"\nmodel.reactions.MAL_ce.add_metabolites(\n    {\"MAL_c\": -1, \"MAL_e\": 0.7, \"aMAL_e\": 0.3, \"PROTON_e\": -0.3}\n)\n\n\n\nNADPHox\n\n# change names to make consistent with the rest of the model\nfor reaction in model.reactions:\n    if \"NADPHox\" in reaction.id:\n        reaction.name = reaction.id[:7] + \"_\" + reaction.id[7:]\n        reaction.id = reaction.id[:7] + \"_\" + reaction.id[7:]\n\n\n\nRemove reactions only active in germinating seeds\nArabidopsis Peroxisomal Citrate Synthase Is Required for Fatty Acid Respiration and Seed Germination Itsara Pracharoenwattana, Johanna E. Cornah, Steven M. Smith The Plant Cell Jul 2005, 17 (7) 2037-2048; DOI: 10.1105/tpc.105.031856\nCoordinate expression of transcriptionally regulated isocitrate lyase and malate synthase genes in Brassica napus L. L Comai, R A Dietrich, D J Maslyar, C S Baden, J J Harada The Plant Cell Mar 1989, 1 (3) 293-300; DOI: 10.1105/tpc.1.3.293\n\nmodel.reactions.MALSYN_RXN_x.bounds = 0, 0\nmodel.reactions.CITSYN_RXN_x.bounds = 0, 0"
  },
  {
    "objectID": "1.1_buildingmodel.html#split-model-into-mesophyll-me-and-guard-cell-gc",
    "href": "1.1_buildingmodel.html#split-model-into-mesophyll-me-and-guard-cell-gc",
    "title": "Building model",
    "section": "Split Model into Mesophyll (me) and Guard Cell (gc)",
    "text": "Split Model into Mesophyll (me) and Guard Cell (gc)\nUsesplit_model to duplicate the model and add the tags “me” and “gc” to each one\n\nsplit_model(model, [\"me\", \"gc\"])\n\n/home/nls119/lib/miniconda3/envs/mmon-gcm/lib/python3.10/site-packages/cobra/core/group.py:147: UserWarning: need to pass in a list\n  warn(\"need to pass in a list\")"
  },
  {
    "objectID": "1.1_buildingmodel.html#adding-gc-specific-transporters",
    "href": "1.1_buildingmodel.html#adding-gc-specific-transporters",
    "title": "Building model",
    "section": "Adding GC-specific transporters",
    "text": "Adding GC-specific transporters\n\nmodel.reactions.PROTON_ATPase_c_gc\n\n\n\n        \n            \n                Reaction identifierPROTON_ATPase_c_gc\n            \n                NamePROTON_ATPase_c_gc\n            \n                Memory address\n                0x7f99c8752ad0\n            \n                Stoichiometry\n                \n                    0.65 ATP_c_gc + 0.45 PROTON_c_gc + WATER_c_gc + 0.35 aATP_c_gc --> 0.5 ADP_c_gc + PROTON_e_gc + 0.7 Pi_c_gc + 0.5 aADP_c_gc + 0.3 aPi_c_gc\n                    0.65 ATP_gc + 0.45 PROTON_gc + WATER_gc + 0.35 aATP[c]_gc --> 0.5 ADP_gc + PROTON_gc + 0.7 Pi[c]_gc + 0.5 aADP[c]_gc + 0.3 aPi[c]_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\nInward-rectifying K+ Channel\n\nRemove dependence for protons\n\nmodel.reactions.K_ec_gc.name = \"Apoplastic Inward-Rectifying K+ Channel\"\nmodel.reactions.K_ec_gc.add_metabolites({\"PROTON_e_gc\": 1, \"PROTON_c_gc\": -1})\n\n\nmodel.reactions.K_ec_gc\n\n\n\n        \n            \n                Reaction identifierK_ec_gc\n            \n                NameApoplastic Inward-Rectifying K+ Channel\n            \n                Memory address\n                0x7f99c890ff70\n            \n                Stoichiometry\n                \n                    K_e_gc --> K_c_gc\n                    K_e_gc --> K_c_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\n\nOutward-rectifying K+ Channel\n\nadd_reaction(model, \"K_ce_gc\", multi=False)\nmodel.reactions.K_ce_gc.name = \"Apoplastic Outward-Rectifying K+ Channel\"\nmodel.reactions.K_ce_gc.add_metabolites({\"K_c_gc\": -1, \"K_e_gc\": 1})\n\n\n\nH+-coupled K+ Symport\n\nadd_reaction(model, \"K_PROTON_ec_gc\", multi=False)\nmodel.reactions.K_PROTON_ec_gc.name = \"H+-Coupled K+ Symport\"\nmodel.reactions.K_PROTON_ec_gc.add_metabolites(\n    {\"K_e_gc\": -1, \"K_c_gc\": 1, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\nmodel.reactions.K_PROTON_ec_gc\n\n\n\n        \n            \n                Reaction identifierK_PROTON_ec_gc\n            \n                NameH+-Coupled K+ Symport\n            \n                Memory address\n                0x7f99c9c798a0\n            \n                Stoichiometry\n                \n                    K_e_gc + PROTON_e_gc --> K_c_gc + PROTON_c_gc\n                    K_e_gc + PROTON_gc --> K_c_gc + PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nCl- Import Channel\n\nadd_reaction(model, \"Cl_ec_gc\", multi=False)\nmodel.reactions.Cl_ec_gc.name = \"Cl Apoplastic Import Channel\"\nmodel.reactions.Cl_ec_gc.add_metabolites({\"Cl_e_gc\": -1, \"Cl_c_gc\": 1})\n\n\n\nH+-Coupled Cl- Symport\n\nadd_reaction(model, \"Cl_PROTON_ec_gc\", multi=False)\nmodel.reactions.Cl_PROTON_ec_gc.name = \"H+-Coupled Cl- Symport\"\nmodel.reactions.Cl_PROTON_ec_gc.add_metabolites(\n    {\"Cl_e_gc\": -2, \"Cl_c_gc\": 2, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nCl- Anion Export Channel (Cl/Mal)\n\nadd_reaction(model, \"Cl_ce_gc\", multi=False)\nmodel.reactions.Cl_ce_gc.name = \"Cl- R/S-Type Anion Channel\"\nmodel.reactions.Cl_ce_gc.add_metabolites({\"Cl_c_gc\": -1, \"Cl_e_gc\": 1})\n\n\n\nATPase Malate Importer\n\nadd_reaction(model, \"MAL_ATPASE_ec_gc\", multi=False)\nmodel.reactions.MAL_ATPASE_ec_gc.add_metabolites(\n    {\n        \"MAL_e_gc\": -0.7,\n        \"aMAL_e_gc\": -0.3,\n        \"MAL_c_gc\": 1,\n        \"ATP_c_gc\": -0.65,\n        \"aATP_c_gc\": -0.35,\n        \"WATER_c_gc\": -1,\n        \"ADP_c_gc\": 1,\n        \"Pi_c_gc\": 0.7,\n        \"aPi_c_gc\": 0.3,\n        \"PROTON_c_gc\": +0.85,\n    }\n)\n\n\n\nGlucose Apoplastic Symport Channel\n\nmodel.reactions.GLC_ec_gc.id = \"GLC_PROTON_ec_gc\"\nmodel.reactions.GLC_PROTON_ec_gc.name = \"H+-Coupled Glucose Symport\"\nmodel.reactions.GLC_PROTON_ec_gc\n\n\n\n        \n            \n                Reaction identifierGLC_PROTON_ec_gc\n            \n                NameH+-Coupled Glucose Symport\n            \n                Memory address\n                0x7f99c89ee290\n            \n                Stoichiometry\n                \n                    GLC_e_gc + PROTON_e_gc --> GLC_c_gc + PROTON_c_gc\n                    GLC_gc + PROTON_gc --> GLC_gc + PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nGlucose Exporter\n\nadd_reaction(model, \"GLC_ce_gc\", multi=False)\nmodel.reactions.GLC_ce_gc.name = \"Glucose Apoplastic Exporter\"\nmodel.reactions.GLC_ce_gc.add_metabolites({\"GLC_c_gc\": -1, \"GLC_e_gc\": 1})\n\n\n\nSucrose Apoplastic Symport Channel\n\n# Renaming Sucrose_tx\nmodel.reactions.Sucrose_tx_gc.id = \"SUCROSE_tx_gc\"\n\n\nmodel.reactions.Sucrose_ec_gc.id = \"SUCROSE_PROTON_ec_gc\"\nmodel.reactions.SUCROSE_PROTON_ec_gc.name = \"H+-Coupled Sucrose Symport\"\nmodel.reactions.SUCROSE_PROTON_ec_gc.upper_bound = 1000\nmodel.reactions.SUCROSE_PROTON_ec_gc\n\n\n\n        \n            \n                Reaction identifierSUCROSE_PROTON_ec_gc\n            \n                NameH+-Coupled Sucrose Symport\n            \n                Memory address\n                0x7f99c8673a90\n            \n                Stoichiometry\n                \n                    PROTON_e_gc + SUCROSE_e_gc --> PROTON_c_gc + SUCROSE_c_gc\n                    PROTON_gc + SUCROSE_gc --> PROTON_gc + SUCROSE_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000\n            \n        \n        \n\n\n\n\nSucrose Exporter\n\nadd_reaction(model, \"SUCROSE_ce_gc\", multi=False)\nmodel.reactions.SUCROSE_ce_gc.name = \"Sucrose Apoplastic Exporter\"\nmodel.reactions.SUCROSE_ce_gc.add_metabolites({\"SUCROSE_c_gc\": -1, \"SUCROSE_e_gc\": 1})\n\n\n\nFructose Apoplastic Symport Channel\n\nadd_metabolite(model, \"FRU_e_gc\", \"e\", multi=False)\nmodel.metabolites.FRU_e_gc.notes = model.metabolites.FRU_c_gc.notes.copy()\nmodel.metabolites.FRU_e_gc.charge = 0\n\n\nadd_reaction(model, \"FRU_PROTON_ec_gc\", multi=False)\nmodel.reactions.FRU_PROTON_ec_gc.name = \"H+-Coupled Fructose Symport\"\nmodel.reactions.FRU_PROTON_ec_gc.add_metabolites(\n    {\"FRU_e_gc\": -1, \"FRU_c_gc\": 1, \"PROTON_e_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nFructose Exporter\n\nadd_reaction(model, \"FRU_ce_gc\", multi=False)\nmodel.reactions.FRU_ce_gc.name = \"Fructose Apoplastic Exporter\"\nmodel.reactions.FRU_ce_gc.add_metabolites({\"FRU_c_gc\": -1, \"FRU_e_gc\": 1})\n\n\n\nCell-Wall Invertase\n\nadd_reaction(model, \"cwINV_gc\", multi=False)\n\n\n\n        \n            \n                Reaction identifiercwINV_gc\n            \n                NamecwINV_gc\n            \n                Memory address\n                0x7f99c9c79120\n            \n                Stoichiometry\n                \n                    -->\n                    -->\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\nmodel.reactions.cwINV_gc.add_metabolites(\n    {\"SUCROSE_e_gc\": -1, \"WATER_e_gc\": -1, \"FRU_e_gc\": 1, \"GLC_e_gc\": 1}\n)\n\n\n\nK+ Import Channel\n(TPK-Type and Fast-vacuolar)\n\nmodel.reactions.K_cv_gc.name = \"K+ Tonoplastic Import Channel\"\nmodel.reactions.K_cv_gc\n\n\n\n        \n            \n                Reaction identifierK_cv_gc\n            \n                NameK+ Tonoplastic Import Channel\n            \n                Memory address\n                0x7f99c878e8c0\n            \n                Stoichiometry\n                \n                    K_c_gc + PROTON_v_gc --> K_v_gc + PROTON_c_gc\n                    K_c_gc + PROTON_gc --> K_v_gc + PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nNHX-Type K+/H+ Antiport\n\nadd_reaction(model, \"K_PROTON_cv_gc\", multi=False)\nmodel.reactions.K_PROTON_cv_gc.name = \"NHX-Type K+/H+ Antiport\"\nmodel.reactions.K_PROTON_cv_gc.add_metabolites(\n    {\"K_c_gc\": -1, \"K_v_gc\": 1, \"PROTON_v_gc\": -1, \"PROTON_c_gc\": 1}\n)\n\n\n\nK+ Tonoplastic Export Channel\nSlow Vacuolar Channel\n\nadd_reaction(model, \"K_vc_gc\", multi=False)\nmodel.reactions.K_vc_gc.name = \"K+ Tonoplastic Export Slow Vacuolar Channel\"\nmodel.reactions.K_vc_gc.add_metabolites({\"K_v_gc\": -1, \"K_c_gc\": 1})\n\n\n\nCLC-Type Cl-/H+ Antiport Vacoular Import Channel\n\nadd_reaction(model, \"Cl_PROTON_cv_gc\", multi=False)\nmodel.reactions.Cl_PROTON_cv_gc.name = (\n    \"CLC-Type Cl-/H+ Antiport Vacoular Import Channel\"\n)\nmodel.reactions.Cl_PROTON_cv_gc.add_metabolites(\n    {\n        \"Cl_v_gc\": 1,\n        \"Cl_c_gc\": -1,\n        \"PROTON_c_gc\": 2,\n        \"PROTON_v_gc\": -2,\n    }\n)\n\n\n\nVCL Cl- Vacuolar Import Channel\n\nadd_reaction(model, \"Cl_cv_gc\", multi=False)\nmodel.reactions.Cl_cv_gc.name = \"VCL Cl- Vacuolar Import Channel\"\nmodel.reactions.Cl_cv_gc.add_metabolites({\"Cl_c_gc\": -1, \"Cl_v_gc\": 1})\n\n\n\nCl- Vacuolar Export Channel\n\nmodel.reactions.Cl_cv_gc.lower_bound = -1000\n\n\n\nMAL Import Channel (AMLT)\n\nmodel.reactions.MAL_PROTON_vc_gc.id = \"MAL_cv_gc\"\nmodel.reactions.MAL_cv_gc.name = \"VMAL-type MAL Channel (Import)\"\nmodel.reactions.MAL_cv_gc\n\n\n\n        \n            \n                Reaction identifierMAL_cv_gc\n            \n                NameVMAL-type MAL Channel (Import)\n            \n                Memory address\n                0x7f99c87ac100\n            \n                Stoichiometry\n                \n                    MAL_c_gc + 0.3 PROTON_v_gc --> 0.7 MAL_v_gc + 0.3 aMAL_v_gc\n                    MAL_gc + 0.3 PROTON_gc --> 0.7 MAL_gc + 0.3 aMAL[v]_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nMAL Export Channel (AMLT)\n\nadd_reaction(model, \"MAL_vc_gc\", multi=False)\nmodel.reactions.MAL_vc_gc.name = \"VMAL-type MAL Channel (Export)\"\nmodel.reactions.MAL_vc_gc.add_metabolites(\n    {\n        \"MAL_v_gc\": -0.7,\n        \"aMAL_v_gc\": -0.3,\n        \"MAL_c_gc\": 1,\n        \"PROTON_c_gc\": 0.3,\n    }\n)\n\n\n\nMAL Export Symporter\nAlready in Model\n\nmodel.reactions.MAL_PROTON_rev_vc_gc.name = \"MAL Export Symporter\"\nmodel.reactions.MAL_PROTON_rev_vc_gc\n\n\n\n        \n            \n                Reaction identifierMAL_PROTON_rev_vc_gc\n            \n                NameMAL Export Symporter\n            \n                Memory address\n                0x7f99c869c700\n            \n                Stoichiometry\n                \n                    0.7 MAL_v_gc + 1.7 PROTON_v_gc + 0.3 aMAL_v_gc --> MAL_c_gc + 2.0 PROTON_c_gc\n                    0.7 MAL_gc + 1.7 PROTON_gc + 0.3 aMAL[v]_gc --> MAL_gc + 2.0 PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nFructose Import Antiporter\nPreviously in the model\n\nmodel.reactions.FRU_PROTON_rev_vc_gc.id = \"FRU_PROTON_rev_cv_gc\"\nmodel.reactions.FRU_PROTON_rev_cv_gc.name = \"Fructose Tonoplastic Import Antiporter\"\nmodel.reactions.FRU_PROTON_rev_cv_gc\n\n\n\n        \n            \n                Reaction identifierFRU_PROTON_rev_cv_gc\n            \n                NameFructose Tonoplastic Import Antiporter\n            \n                Memory address\n                0x7f99c8a83f70\n            \n                Stoichiometry\n                \n                    FRU_c_gc + PROTON_v_gc --> FRU_v_gc + PROTON_c_gc\n                    FRU[c]_gc + PROTON_gc --> FRU[v]_gc + PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nFructose Import Symporter\n\nadd_reaction(model, \"FRU_PROTON_cv_gc\", multi=False)\nmodel.reactions.FRU_PROTON_cv_gc.name = \"Fructose Tonoplastic Import Symporter\"\nmodel.reactions.FRU_PROTON_cv_gc.add_metabolites(\n    {\"PROTON_c_gc\": -1, \"PROTON_v_gc\": 1, \"FRU_c_gc\": -1, \"FRU_v_gc\": 1}\n)\n\n\n\nFructose Export\n\nmodel.reactions.FRU_vc_gc\n\n\n\n        \n            \n                Reaction identifierFRU_vc_gc\n            \n                NameFRU_vc_gc\n            \n                Memory address\n                0x7f99c8918bb0\n            \n                Stoichiometry\n                \n                    FRU_v_gc --> FRU_c_gc\n                    FRU[v]_gc --> FRU[c]_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nGlucose Tonoplastic Antiporter\n\nmodel.reactions.GLC_PROTON_rev_vc_gc.id = \"GLC_PROTON_rev_cv_gc\"\nmodel.reactions.GLC_PROTON_rev_cv_gc.name = \"Glucose Tonoplastic Import Antiporter\"\nmodel.reactions.GLC_PROTON_rev_cv_gc\n\n\n\n        \n            \n                Reaction identifierGLC_PROTON_rev_cv_gc\n            \n                NameGlucose Tonoplastic Import Antiporter\n            \n                Memory address\n                0x7f99c899d420\n            \n                Stoichiometry\n                \n                    GLC_c_gc + PROTON_v_gc --> GLC_v_gc + PROTON_c_gc\n                    GLC_gc + PROTON_gc --> GLC_gc + PROTON_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nGlucose Tonoplastic Symporter\n\nadd_reaction(model, \"GLC_PROTON_cv_gc\", multi=False)\nmodel.reactions.GLC_PROTON_cv_gc.name = \"Glucose Tonoplastic Import Symporter\"\nmodel.reactions.GLC_PROTON_cv_gc.add_metabolites(\n    {\"PROTON_c_gc\": -1, \"PROTON_v_gc\": 1, \"GLC_c_gc\": -1, \"GLC_v_gc\": 1}\n)\n\n\n\nGlucose Export Channel\n\nmodel.reactions.GLC_vc_gc\n\n\n\n        \n            \n                Reaction identifierGLC_vc_gc\n            \n                NameGLC_vc_gc\n            \n                Memory address\n                0x7f99c878d8a0\n            \n                Stoichiometry\n                \n                    GLC_v_gc --> GLC_c_gc\n                    GLC_gc --> GLC_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nSucrose Tonoplastic Importer\n\nadd_reaction(model, \"SUCROSE_cv_gc\", multi=False)\nmodel.reactions.SUCROSE_cv_gc.name = \"Sucrose Free Tonoplastic Import\"\nmodel.reactions.SUCROSE_cv_gc.add_metabolites(\n    {\n        \"SUCROSE_c_gc\": -1,\n        \"SUCROSE_v_gc\": 1,\n    }\n)\n\n\n\nSucrose Tonoplastic Import Antiporter\nAlready in the model\n\nmodel.reactions.SUCROSE_PROTON_vc_gc.id = \"SUCROSE_PROTON_cv_gc\"\nmodel.reactions.SUCROSE_PROTON_cv_gc.name = \"Sucrose Tonoplastic Import Antiporter\"\nmodel.reactions.SUCROSE_PROTON_cv_gc\n\n\n\n        \n            \n                Reaction identifierSUCROSE_PROTON_cv_gc\n            \n                NameSucrose Tonoplastic Import Antiporter\n            \n                Memory address\n                0x7f99c8c279d0\n            \n                Stoichiometry\n                \n                    PROTON_v_gc + SUCROSE_c_gc --> PROTON_c_gc + SUCROSE_v_gc\n                    PROTON_gc + SUCROSE_gc --> PROTON_gc + SUCROSE_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nSucrose Tonoplastic Export Symporter\n\nmodel.reactions.SUCROSE_PROTON_rev_vc_gc.id = \"SUCROSE_PROTON_vc_gc\"\nmodel.reactions.SUCROSE_PROTON_vc_gc.name = \"Sucrose Tonoplastic Export Symporter\"\n\n\n\nTonoplastic PPase\n\nmodel.reactions.PROTON_PPi_rev_vc_gc\n\n\n\n        \n            \n                Reaction identifierPROTON_PPi_rev_vc_gc\n            \n                NamePROTON_PPi_rev_vc_gc\n            \n                Memory address\n                0x7f99c8631840\n            \n                Stoichiometry\n                \n                    0.65 PPI_c_gc + 0.25 PROTON_c_gc + WATER_c_gc + 0.35 aPPI_c_gc --> PROTON_v_gc + 1.4 Pi_c_gc + 0.6 aPi_c_gc\n                    0.65 PPI_gc + 0.25 PROTON_gc + WATER_gc + 0.35 aPPI[c]_gc --> PROTON_gc + 1.4 Pi[c]_gc + 0.6 aPi[c]_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\n\nTonoplastic H+ ATPase\n\nmodel.reactions.PROTONATP_rev_vc_gc\n\n\n\n        \n            \n                Reaction identifierPROTONATP_rev_vc_gc\n            \n                NamePROTONATP_rev_vc_gc\n            \n                Memory address\n                0x7f99c8ba7e50\n            \n                Stoichiometry\n                \n                    0.65 ATP_c_gc + 1.45 PROTON_c_gc + WATER_c_gc + 0.35 aATP_c_gc --> 0.5 ADP_c_gc + 2.0 PROTON_v_gc + 0.7 Pi_c_gc + 0.5 aADP_c_gc + 0.3 aPi_c_gc\n                    0.65 ATP_gc + 1.45 PROTON_gc + WATER_gc + 0.35 aATP[c]_gc --> 0.5 ADP_gc + 2.0 PROTON_gc + 0.7 Pi[c]_gc + 0.5 aADP[c]_gc + 0.3 aPi[c]_gc\n                \n            \n                GPR\n            \n                Lower bound0.0\n            \n                Upper bound1000.0\n            \n        \n        \n\n\n\nadd_reaction(model, \"PROTON_ec_gc\", multi=False)\nmodel.reactions.PROTON_ec_gc.name = \"Plasma membrane proton leakage\"\nmodel.reactions.PROTON_ec_gc.add_metabolites(\n    {\n        \"PROTON_e_gc\": -1,\n        \"PROTON_c_gc\": 1,\n    }\n)\n\n\nadd_reaction(model, \"PROTON_vc_gc\", multi=False)\nmodel.reactions.PROTON_vc_gc.name = \"Tonoplast membrane proton leakage\"\nmodel.reactions.PROTON_vc_gc.add_metabolites(\n    {\n        \"PROTON_v_gc\": -1,\n        \"PROTON_c_gc\": 1,\n    }\n)"
  },
  {
    "objectID": "1.1_buildingmodel.html#constrain-channels-in-guard-cell",
    "href": "1.1_buildingmodel.html#constrain-channels-in-guard-cell",
    "title": "Building model",
    "section": "Constrain Channels in Guard Cell",
    "text": "Constrain Channels in Guard Cell\n\nfor channel in [\"Cl_ec\", \"K_cv\", \"FRU_PROTON_cv\", \"GLC_PROTON_cv\", \"SUCROSE_cv\"]:\n    model.reactions.get_by_id(channel + \"_gc\").bounds = 0, 0"
  },
  {
    "objectID": "1.1_buildingmodel.html#adding-apoplast-and-exchanges",
    "href": "1.1_buildingmodel.html#adding-apoplast-and-exchanges",
    "title": "Building model",
    "section": "Adding apoplast and exchanges",
    "text": "Adding apoplast and exchanges\nIn this section we add an apoplastic compartment and set the influx of osmolites to be from this compartment rather than as boundary reactions.\n\nRemoving tx_me\nHere we remove all the boundary reactions from the mesophyll cell except for: - Maintenance reactions - Photon influx - Phloem output - Gas transfer (O2 and CO2)\n\ntx_me = []\nfor reaction in model.reactions:\n    if \"_tx_me\" in reaction.id:\n        tx_me.append(reaction)\nkeep = [\n    \"Photon_tx_me\",\n    \"Phloem_output_tx_me\",\n    \"NADPHox_c_tx_me\",\n    \"NADPHox_m_tx_me\",\n    \"NADPHox_p_tx_me\",\n    \"O2_tx_me\",\n    \"CO2_tx_me\",\n    \"ATPase_tx_me\",\n]\nfor reaction in keep:\n    tx_me.remove(model.reactions.get_by_id(reaction))\n\nmodel.remove_reactions(tx_me)\n\n\n\nRemoving tx_gc\nSee above for removing tx_me reactions, only difference is in this case we don’t have a phloem output reaction\n\ntx_gc = []\nfor reaction in model.reactions:\n    if \"_tx_gc\" in reaction.id:\n        tx_gc.append(reaction)\nkeep = [\n    \"Photon_tx_gc\",\n    \"NADPHox_c_tx_gc\",\n    \"NADPHox_m_tx_gc\",\n    \"NADPHox_p_tx_gc\",\n    \"O2_tx_gc\",\n    \"CO2_tx_gc\",\n    \"ATPase_tx_gc\",\n]\nfor reaction in keep:\n    tx_gc.remove(model.reactions.get_by_id(reaction))\n\nmodel.remove_reactions(tx_gc)\n\n\n\nAdding tx to apo and adding exchanges\nNow for the species that are present in the extracellular compartment of the guard cell we: - Add the species to the apoplastic compartment with the tag “a” - Add a boundary reaction into this compartment for the species - Add a transfer reaction to allow them to be transferred between the guard cell extracellular compartment and the apoplast - Add a transfer reaction to allow them to be transferred between the mesophyll cell extracellular compartment and the apoplast\nAll these actions are free and reversible, as we are assuming that really the extracellular space and the apoplast are all the same. The apoplastic compartment just gives us an easy way to track influx/efflux of metabolites as well as osmolite levels in that compartment.\n\n# fructose wasn't in the extracellular compartment of mesophyll before\nadd_metabolite(model, \"FRU_e_me\", \"e\", multi=False)\n\n\n\n        \n            \n                Metabolite identifierFRU_e_me\n            \n                NameFRU_e_me\n            \n                Memory address\n                0x7f99c9905120\n            \n                FormulaNone\n            \n                Compartmente\n            \n                In 0 reaction(s)\n                    \n                    \n            \n        \n\n\n\nadd_reaction(model, \"Sucrose_ce_me\", multi=False)  # sucrose transport out of the mesophyll cell wasn't allowed before\nmodel.reactions.Sucrose_ce_me.add_metabolites({\"SUCROSE_c_me\": -1, \"SUCROSE_e_me\": 1})\n\n\nea_reactions = []\nfor metabolite in model.metabolites:\n    if \"_e_gc\" in metabolite.id:\n        ea_reactions.append(metabolite)\n\nprint(ea_reactions)\n\n# don't want these to be transferred in the apoplast, they already have individual boundary reactions in each cell type\nremove = [\"Photon\", \"OXYGEN_MOLECULE\", \"CARBON_DIOXIDE\", \"PROTON\"]\nfor name in remove:\n    ea_reactions.remove(model.metabolites.get_by_id(name + \"_e_gc\"))\n\nfor metabolite in ea_reactions:\n\n    add_metabolite(model, metabolite.id[:-4] + \"a\", \"a\", multi=False)\n    model.metabolites.get_by_id(metabolite.id[:-4] + \"a\").charge = metabolite.charge\n    model.metabolites.get_by_id(metabolite.id[:-4] + \"a\").notes = metabolite.notes\n\n    add_reaction(model, metabolite.id[:-4] + \"a_tx\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"a_tx\").add_metabolites(\n        {metabolite.id[:-4] + \"a\": 1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"a_tx\").lower_bound = -1000\n\n    add_reaction(model, metabolite.id[:-4] + \"ae_gc\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_gc\").add_metabolites(\n        {metabolite: 1, metabolite.id[:-4] + \"a\": -1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_gc\").lower_bound = -1000\n\n    add_reaction(model, metabolite.id[:-4] + \"ae_me\", multi=False)\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_me\").add_metabolites(\n        {metabolite.id[:-4] + \"e_me\": 1, metabolite.id[:-4] + \"a\": -1}\n    )\n    model.reactions.get_by_id(metabolite.id[:-4] + \"ae_me\").lower_bound = -1000\n\n[<Metabolite NITRATE_e_gc>, <Metabolite SUCROSE_e_gc>, <Metabolite WATER_e_gc>, <Metabolite MGII_e_gc>, <Metabolite GLC_e_gc>, <Metabolite PROTON_e_gc>, <Metabolite CARBON_DIOXIDE_e_gc>, <Metabolite CAII_e_gc>, <Metabolite Pi_e_gc>, <Metabolite SULFATE_e_gc>, <Metabolite OXYGEN_MOLECULE_e_gc>, <Metabolite Photon_e_gc>, <Metabolite K_e_gc>, <Metabolite AMMONIUM_e_gc>, <Metabolite Cl_e_gc>, <Metabolite MAL_e_gc>, <Metabolite aMAL_e_gc>, <Metabolite FRU_e_gc>]\n\n\n\n\nList of all boundary reactions:\n\nfor reaction in model.reactions:\n    if \"_tx\" in reaction.id:\n        print(reaction.id)\n\nPhoton_tx_me\nPhoton_tx_gc\nNADPHox_m_tx_me\nNADPHox_m_tx_gc\nCO2_tx_me\nCO2_tx_gc\nO2_tx_me\nO2_tx_gc\nPhloem_output_tx_me\nNADPHox_c_tx_me\nNADPHox_c_tx_gc\nATPase_tx_me\nATPase_tx_gc\nNADPHox_p_tx_me\nNADPHox_p_tx_gc\nNITRATE_a_tx\nSUCROSE_a_tx\nWATER_a_tx\nMGII_a_tx\nGLC_a_tx\nCAII_a_tx\nPi_a_tx\nSULFATE_a_tx\nK_a_tx\nAMMONIUM_a_tx\nCl_a_tx\nMAL_a_tx\naMAL_a_tx\nFRU_a_tx"
  },
  {
    "objectID": "1.1_buildingmodel.html#constrain-free-exchange-and-starch-breakdown",
    "href": "1.1_buildingmodel.html#constrain-free-exchange-and-starch-breakdown",
    "title": "Building model",
    "section": "Constrain free exchange and starch breakdown",
    "text": "Constrain free exchange and starch breakdown\nPrevent: - Free import into the apoplast of energy-carrying metabolites like Glucose, malate, sucrose, fructose. - Free exchange of protons. - Alpha-glucosidase starch degradation pathway as it isn’t used\n\nfor reaction in [\n    \"GLC_a_tx\",\n    \"MAL_a_tx\",\n    \"SUCROSE_a_tx\",\n    \"FRU_a_tx\",\n    \"RXN_1826_p_me\",\n    \"RXN_1826_p_gc\",\n    \"MALTODEXGLUCOSID_RXN_p_me\",\n    \"MALTODEXGLUCOSID_RXN_p_gc\",\n]:\n    model.reactions.get_by_id(reaction).bounds = (0, 0)"
  },
  {
    "objectID": "1.1_buildingmodel.html#quadruple-model-into-4-phases",
    "href": "1.1_buildingmodel.html#quadruple-model-into-4-phases",
    "title": "Building model",
    "section": "Quadruple model into 4 phases",
    "text": "Quadruple model into 4 phases\n\nsplit_model(model, range(1, 5))"
  },
  {
    "objectID": "1.1_buildingmodel.html#add-linker-reactions-with-pseudometabolites-osmolarity-and-charge",
    "href": "1.1_buildingmodel.html#add-linker-reactions-with-pseudometabolites-osmolarity-and-charge",
    "title": "Building model",
    "section": "Add Linker Reactions With Pseudometabolites (Osmolarity and Charge)",
    "text": "Add Linker Reactions With Pseudometabolites (Osmolarity and Charge)\nSet phase times here\n\ncompartments = [\"c\", \"v\", \"p\", \"a\"]\n\ncells = [\n    \"gc\",\n    \"me\",\n]\nphase_times = [6.0, 0.5, 11.5, 6.0]\n\n\nadd_linkers(model, \"../inputs/osmolytes.csv\", compartments, cells, phase_times)\n\n\nprefix_metabolites = {\n    \"a\": {\n        \"v_gc\": {\n            \"MAL\": 0.7,\n            \"CIT\": 0.5,\n        },\n        \"a\": {\n            \"MAL\": 0.7,\n        },\n        \"v_me\": {\n            \"MAL\": 0.7,\n            \"CIT\": 0.5,\n        },\n    },\n    \"b\": {\"v_me\": {\"HIS\": 0}, \"v_gc\": {\"HIS\": 0}},\n}\n\n\nfor prefix, compartments in prefix_metabolites.items():\n    for compartment, metabolites in compartments.items():\n        for metabolite, ratio in metabolites.items():\n            if ratio == 0:\n                set_bounds_multi(\n                    model, metabolite + \"_\" + compartment + \"_Linker\", 0, 0\n                )\n            elif ratio == 1:\n                set_bounds_multi(\n                    prefix + model, metabolite + \"_\" + compartment + \"_Linker\", 0, 0\n                )\n            else:\n                add_metabolite(\n                    model, metabolite + \"_\" + compartment + \"_prefixpseudometabolite\"\n                )\n                for phase in range(check_number_of_models(model)):\n                    model.reactions.get_by_id(\n                        f\"{metabolite}_{compartment}_Linker_\" + str(phase + 1)\n                    ).add_metabolites(\n                        {\n                            model.metabolites.get_by_id(\n                                f\"{metabolite}_{compartment}_prefixpseudometabolite_\" +\n                                str(phase + 1)\n                            ): 1 -\n                            ratio\n                        }\n                    )\n                    model.reactions.get_by_id(\n                        f\"{prefix}{metabolite}_{compartment}_Linker_\" + str(phase + 1)\n                    ).add_metabolites(\n                        {\n                            model.metabolites.get_by_id(\n                                f\"{metabolite}_{compartment}_prefixpseudometabolite_\"\n                                + str(phase + 1)\n                            ): -ratio\n                        }\n                    )"
  },
  {
    "objectID": "1.1_buildingmodel.html#add-maintenance-reactions",
    "href": "1.1_buildingmodel.html#add-maintenance-reactions",
    "title": "Building model",
    "section": "Add Maintenance Reactions",
    "text": "Add Maintenance Reactions\n\nnumber_of_models = check_number_of_models(model)\nfor cell in [\"gc\", \"me\"]:\n    add_metabolite(model, \"maintenance_ratio_constraint_\" + cell, \"pseudo\")\n    add_metabolite(model, \"maintenance_phase_constraint_\" + cell, \"pseudo\")\n    add_reaction(model, \"maintenance_phase_overall_\" + cell, multi=\"\")\n    for i in range(1, number_of_models + 1):\n        for x in [\"c\", \"m\", \"p\"]:\n            reaction = model.reactions.get_by_id(f\"NADPHox_{x}_tx_{cell}_\" + str(i))\n            reaction.add_metabolites(\n                {f\"maintenance_ratio_constraint_{cell}_\" + str(i): -3}\n            )\n        reaction = model.reactions.get_by_id(f\"ATPase_tx_{cell}_\" + str(i))\n        reaction.add_metabolites(\n            {\n                f\"maintenance_ratio_constraint_{cell}_\" + str(i): 1,\n                f\"maintenance_phase_constraint_{cell}_\" + str(i): 1,\n            }\n        )\n        model.reactions.get_by_id(f\"maintenance_phase_overall_{cell}\").add_metabolites(\n            {f\"maintenance_phase_constraint_{cell}_\" + str(i): -1}\n        )"
  },
  {
    "objectID": "1.1_buildingmodel.html#add-phloem_tx-overall",
    "href": "1.1_buildingmodel.html#add-phloem_tx-overall",
    "title": "Building model",
    "section": "Add Phloem_tx Overall",
    "text": "Add Phloem_tx Overall\n\nnumber_of_models = check_number_of_models(model)\nday = [2, 3]\nnight = [1, 4]\nadd_metabolite(model, \"pseudoPhloem_me\", \"pseudo\")\nadd_metabolite(model, \"pseudoPhloem_day_me\", \"pseudo\", multi=\"\")\nadd_metabolite(model, \"pseudoPhloem_night_me\", \"pseudo\", multi=\"\")\nadd_reaction(model, \"Phloem_constraint_day\", multi=\"\")\nadd_reaction(model, \"Phloem_constraint_night\", multi=\"\")\nadd_reaction(model, \"Phloem_tx_overall\", multi=\"\")\nfor i in range(1, number_of_models + 1):\n    length_of_phase = 1 / (\n        -model.reactions.get_by_id(f\"SUCROSE_v_gc_Linker_{i}\").get_coefficient(\n            f\"SUCROSE_v_gc_{i}\"\n        )\n    )\n    model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n        {f\"pseudoPhloem_me_{i}\": 1}\n    )\n    if i in day:\n        model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n            {\"pseudoPhloem_day_me\": 1 * length_of_phase}\n        )\n        model.reactions.Phloem_constraint_day.add_metabolites(\n            {f\"pseudoPhloem_me_{i}\": -1}\n        )\n    elif i in night:\n        model.reactions.get_by_id(f\"Phloem_output_tx_me_{i}\").add_metabolites(\n            {\"pseudoPhloem_night_me\": 1 * length_of_phase}\n        )\n        model.reactions.Phloem_constraint_night.add_metabolites(\n            {f\"pseudoPhloem_me_{i}\": -1}\n        )\n    else:\n        raise ValueError(\"Make sure all phases are either assigned to day or night\")\nmodel.reactions.Phloem_constraint_day.add_metabolites({})\nmodel.reactions.Phloem_tx_overall.add_metabolites(\n    {\n        \"pseudoPhloem_day_me\": -3,\n        \"pseudoPhloem_night_me\": -1,\n    }\n)"
  },
  {
    "objectID": "1.1_buildingmodel.html#add-pseudoreactions-for-total-metabolite-counting-and-fva",
    "href": "1.1_buildingmodel.html#add-pseudoreactions-for-total-metabolite-counting-and-fva",
    "title": "Building model",
    "section": "Add pseudoreactions for total metabolite counting and FVA",
    "text": "Add pseudoreactions for total metabolite counting and FVA\nEssentially, here we add a ‘total’ pseudometabolite in the guard cel for each of a list of metabolites. We can use this metabolite to see the sum of the linker reactions for the vacuole and cytoplasm, but most importantly we can perform FVA on this reaction to see if the total transfer of a metabolite matters. Otherwise, we end up in a situation where we can do FVA on the cytoplasmic and vacuolar reactions separately but it could be the case that when cytoplasm goes down the vacuole compensates etc.\n\"total\" added as keyword to getweightings in order to prevent these reactions from contributing to sum of fluxes constraint\n\nhelp(add_metabolites_to_reaction_multi)\n\nHelp on function add_metabolites_to_reaction_multi in module mmon_gcm.buildingediting:\n\nadd_metabolites_to_reaction_multi(model, reaction, metabolites_dict)\n    This function adds a dictionary of metabolites to a reaction in every phase of the model\n\n\n\n\nmetabolites = [\"SUCROSE\", \"GLC\", \"MAL\", \"FRU\", \"K\", \"Cl\", \"CIT\"]  # \"NITRATE\", \"CIT\"]\n\n\nfor metabolite in metabolites:\n    if metabolite == \"MAL\" or metabolite == \"CIT\":\n        add_reaction(model, f\"{metabolite}_total_pseudolinker\")\n        add_metabolite(model, f\"{metabolite}_total_pseudometabolite\")\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_total_pseudolinker\",\n            {f\"{metabolite}_total_pseudometabolite\": -1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_c_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"a{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n    else:\n        add_reaction(model, f\"{metabolite}_total_pseudolinker\")\n        add_metabolite(model, f\"{metabolite}_total_pseudometabolite\")\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_total_pseudolinker\",\n            {f\"{metabolite}_total_pseudometabolite\": -1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_c_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )\n        add_metabolites_to_reaction_multi(\n            model,\n            f\"{metabolite}_v_gc_Linker\",\n            {f\"{metabolite}_total_pseudometabolite\": 1},\n        )"
  },
  {
    "objectID": "1.1_buildingmodel.html#export-model",
    "href": "1.1_buildingmodel.html#export-model",
    "title": "Building model",
    "section": "Export Model",
    "text": "Export Model\n\ncobra.io.write_sbml_model(model, \"../models/4_stage_GC.xml\")\ncobra.io.save_json_model(model, \"../models/4_stage_GC.json\")"
  },
  {
    "objectID": "1.3_atpase_constraint.html",
    "href": "1.3_atpase_constraint.html",
    "title": "Is H+ATPase limiting?",
    "section": "",
    "text": "Jezek et al. (2019) wrote a follow-up OnGuard paper, where they added a constraint-relaxation-recovery mechanism into the model. The justification for this was:\nThey therefore added a the CRR mechanism into the model which was able to reconcile the kinetics of stomatal conductance experimentally and in the model.\nDespite this, they also say in the discussion:\nFlutsch et al (2020) investigated the kinetics of stomatal opening in amy3bam1 and aha1 knockouts. The amy3bam1 mutant cannot degrade starch and the aha1 mutant can’t pump protons out of the guard cell, which drives K+/Mal/Cl uptake into the guard cell. It also is part of the starch signaling pathway. They found that there was no impact on the H+-ATPase or kinetics of K+/Cl- uptake in the amy3bam1 knockout, suggesting that starch is not degraded to power the H+-ATPase pump, but rather it is a source of osmoticum in the form of glucose. However, the amy3bam1 mutants had slower opening kinetics.\nThis would be consistent with a H+-ATPase that is not able to provide osmoticum at a sufficient rate for opening. It is saturated regardless of whether or not starch is available. As our model does not degrade starch, instead meeting all the osmotic requirements of opening using K+/Cl- uptake, we wanted to see what would happen if we added a constraint on the rate of the H+-ATPase. This notebook explores the experimental rate of the H+-ATPase that Flutsch et al (2020) estimated and compares it to the rate in the model that is required for the Guard Cell to open, in order to see whether adding a constraint would affect the model."
  },
  {
    "objectID": "1.3_atpase_constraint.html#setup",
    "href": "1.3_atpase_constraint.html#setup",
    "title": "Is H+ATPase limiting?",
    "section": "Setup",
    "text": "Setup\n\nimport cobra\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfrom mmon_gcm.supermodel import SuperModel\n\n\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\nsolution = pd.read_csv(\"../outputs/model_solutions/blue_unconstrained_starchko.csv\", index_col=0)\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)"
  },
  {
    "objectID": "1.3_atpase_constraint.html#calculating-h-atpase-flux-in-the-model-in-fmolesgch-1",
    "href": "1.3_atpase_constraint.html#calculating-h-atpase-flux-in-the-model-in-fmolesgch-1",
    "title": "Is H+ATPase limiting?",
    "section": "Calculating H+-ATPase flux in the model in fmoles/gc/h-1",
    "text": "Calculating H+-ATPase flux in the model in fmoles/gc/h-1\n\natpase_flux = solution.loc[\"PROTON_ATPase_c_gc_2\", \"fluxes\"]\nprint(f\"ATPase flux is {atpase_flux} mmoles m-2 leaf h-1\")\n\nATPase flux is 0.00812887978917 mmoles m-2 leaf h-1\n\n\n\nn_gcs = parameters_df.loc[\"N_gcs\", \"Value\"]\n\n\nflux_per_gc_moles = atpase_flux / n_gcs * 10**-3\n\n\nflux_per_gc_fmoles = flux_per_gc_moles * 10**15\nflux_per_gc_fmoles_rounded = flux_per_gc_fmoles.round(1)\nprint(f\"Rate of H+-ATPase is {flux_per_gc_fmoles_rounded} fmoles gc-1 h-1\")\n\nRate of H+-ATPase is 14.0 fmoles gc-1 h-1"
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-flutsch",
    "href": "1.3_atpase_constraint.html#comparing-with-flutsch",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with Flutsch",
    "text": "Comparing with Flutsch\nAccording to their Supplemental file 1, Flutsch et al say that guard cells can provide 17 fmoles H+ h-1 (0.017 pmoles)."
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-papanatsiou-et-al-2019",
    "href": "1.3_atpase_constraint.html#comparing-with-papanatsiou-et-al-2019",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with Papanatsiou et al 2019",
    "text": "Comparing with Papanatsiou et al 2019\n(From supplementary methods of Papanatsiou et al., 2019:) >“Between the fully closed and fully open state of the stoma, the osmotic content of an Arabidopsis guard cell rises by approximately 200 to 300 mM on a cell volume basis (5). Roughly half of this osmotic content is made up of K+ transported across the plasma membrane and translates to approximately 70 fmol of K+ per guard cell.”\n5 - Engineer, C. B. et al. (2016) ‘CO2 Sensing and CO2 Regulation of Stomatal Conductance: Advances and Open Questions’, Trends in Plant Science. Elsevier Ltd, 21(1), pp. 16–30. doi: 10.1016/j.tplants.2015.08.014.\nBut there is nothing in the Engineer paper that references this…"
  },
  {
    "objectID": "1.3_atpase_constraint.html#comparing-with-onguard",
    "href": "1.3_atpase_constraint.html#comparing-with-onguard",
    "title": "Is H+ATPase limiting?",
    "section": "Comparing with OnGuard",
    "text": "Comparing with OnGuard\nI ran the default model that comes with OnGuard version 3 ‘RCA5-wt-191120-wt’ using the Summer 2022 release of OnGuard. Modifying it by unticking the ‘CRR’ box. I ran it for 24 hours and exported the results as a csv:\n\n# import csv and tidy up\nonguard_df = pd.read_csv(\"../inputs/RCA5-wt-191120-wt-001.csv\")\nonguard_df = onguard_df.set_index(\"Time /hr\")\nonguard_df\n\n\n\n\n\n  \n    \n      \n      Time /s\n      Time /min\n      Time /d\n      Vpm /mV\n      Vtp /mV\n      VT /pL\n      Vac %-age\n      SA /um\n      TP /atm\n      Unnamed: 10\n      ...\n      VPD/KPa\n      Unnamed: 140\n      CRR Value\n      CRR Recovery\n      Unnamed: 143\n      Ciso(0) /mM\n      'Mott' (*1000)\n      Ciso' /mM\n      Osm[Cyt] /mM\n      Unnamed: 148\n    \n    \n      Time /hr\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0.00000\n      0.0\n      0.00000\n      0.00000\n      -62.1\n      -35.5\n      0.381\n      79.172\n      1.629\n      4.303\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1003\n      5.73262\n      28.8329\n      204.713\n      NaN\n    \n    \n      0.00639\n      23.0\n      0.38342\n      0.00027\n      -62.9\n      -35.5\n      0.381\n      79.162\n      1.629\n      4.303\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.0992\n      5.73783\n      28.8370\n      204.752\n      NaN\n    \n    \n      0.01306\n      47.0\n      0.78353\n      0.00054\n      -63.7\n      -35.4\n      0.381\n      79.161\n      1.629\n      4.303\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.0991\n      5.73811\n      28.8372\n      204.793\n      NaN\n    \n    \n      0.01881\n      67.7\n      1.12838\n      0.00078\n      -64.3\n      -35.4\n      0.381\n      79.164\n      1.629\n      4.303\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.0990\n      5.73851\n      28.8375\n      204.829\n      NaN\n    \n    \n      0.02486\n      89.5\n      1.49185\n      0.00104\n      -64.9\n      -35.4\n      0.381\n      79.168\n      1.629\n      4.303\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.0990\n      5.73911\n      28.8381\n      204.867\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      23.97191\n      86298.9\n      1438.31476\n      0.99883\n      -59.9\n      -36.4\n      0.380\n      79.641\n      1.609\n      4.287\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1004\n      5.66717\n      28.7675\n      204.079\n      NaN\n    \n    \n      23.97842\n      86322.3\n      1438.70519\n      0.99910\n      -59.9\n      -36.4\n      0.380\n      79.642\n      1.609\n      4.287\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1004\n      5.66763\n      28.7680\n      204.084\n      NaN\n    \n    \n      23.98431\n      86343.5\n      1439.05839\n      0.99935\n      -60.0\n      -36.4\n      0.380\n      79.642\n      1.609\n      4.287\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1004\n      5.66814\n      28.7685\n      204.089\n      NaN\n    \n    \n      23.99081\n      86366.9\n      1439.44890\n      0.99962\n      -59.9\n      -36.4\n      0.380\n      79.643\n      1.609\n      4.287\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1004\n      5.66859\n      28.7690\n      204.094\n      NaN\n    \n    \n      23.99670\n      86388.1\n      1439.80211\n      0.99986\n      -60.0\n      -36.4\n      0.380\n      79.643\n      1.609\n      4.287\n      NaN\n      ...\n      -0.943\n      NaN\n      1\n      2.630280e-25\n      NaN\n      23.1004\n      5.66910\n      28.7695\n      204.099\n      NaN\n    \n  \n\n3905 rows × 148 columns\n\n\n\nWhere did their original kinetics for the H+-ATPase come from?\nFrom Hills et al (2012):\n\nH+-ATPase: The parameters are fully constrained by experimental analysis of the Vicia guard cell H+-ATPase (Blatt 1987a; Blatt 1988a; Blatt and Clint 1989; Clint and Blatt 1989) and equivalent analysis of the Chara H+-ATPase (Blatt et al. 1990a), the latter providing expansion to a 4-state carrier cycle to describe its pH dependence explicitly. The model incorporates [Ca2+]i sensitivity as an inhibitory ligand (Ki, 400 nM and nh, 3 to give >90% inhibition at 1 μM [Ca2+]i; see Kinoshita, et al. (1995) and light as a stimulatory ligand [K1/2, 50 μmol m-2 s-1 and nh, 1, 20-fold enhancement over dark activity; see Goh, et al. (1995) and Kinoshita and Shimazaki (Kinoshita and Shimazaki 1999)].\n\n\n4-State H+-ATPase [3000000 units] (4-State ‘Slayman’ Pump) #‘H’ Stoichiometry = +1; binds at 4->1 (in) and 3->2 (ex); K12 = 2000, K23 = 50000, K34 = 500, K41 = 2e+09, K21 = 100, K32 = 1e+08, K43 = 10, K14 = 200; Light-Sensitive: Yes: L1⁄2 = 50 μEinsteins, Fmin = 5% Ligand-Gates: Ca-inhibited (cytosol): Kd= 2.5e-07, Hill= 3;"
  },
  {
    "objectID": "1.3_atpase_constraint.html#stomatal-aperture-sanity-check",
    "href": "1.3_atpase_constraint.html#stomatal-aperture-sanity-check",
    "title": "Is H+ATPase limiting?",
    "section": "Stomatal aperture sanity check",
    "text": "Stomatal aperture sanity check\nFirst, a sanity check on the stomatal aperture:\n\nonguard_df[\"SA /um\"].plot(ylabel=\"Aperture (µm)\")\n\n<Axes: xlabel='Time /hr', ylabel='Aperture (µm)'>\n\n\n\n\n\n\nonguard_df[onguard_df.index < 1][\"SA /um\"].plot(ylabel=\"Aperture (µm)\")\n\n<Axes: xlabel='Time /hr', ylabel='Aperture (µm)'>\n\n\n\n\n\nOur aperture is 1.6-2.75, so pretty similar over half an hour to what they are seeing over one hour\n\nOsmolarity sanity check\n\ncyt_df = onguard_df.filter(regex=\"mM\").filter(regex=\"Cyt\")\nvac_df = onguard_df.filter(regex=\"mM\").filter(regex=\"Vac\")\n\n\ndef just_inside_brackets(string_to_be_pruned):\n    return string_to_be_pruned.split(\"]\")[0][1:]\n\n\nvac_df.columns = [just_inside_brackets(col) + \" mM\" for col in vac_df.columns]\ncyt_df.columns = [just_inside_brackets(col) + \" mM\" for col in cyt_df.columns]\n\n\nvac_frac = 79.2589 / 100\n\n\ntotal_df = vac_df * vac_frac + cyt_df * (1 - vac_frac)\n\n\ntotal_df[onguard_df.index < 1].sum(axis=1).plot(ylabel=\"Total osmolytes\")\n\n<Axes: xlabel='Time /hr', ylabel='Total osmolytes'>\n\n\n\n\n\nOur osmolarities go from 178mM to 215mM for the same aperture range, so there’s something not quite right somewhere maybe…\n\n\nH\\(^+\\)-ATPase flux\nNow, let’s see what the H+-ATPase flux is doing:\n\n# get the flux of the H+-ATPase in units of fmoles/h\natpase_h = onguard_df[\"HATP[H]\"] * 3600\natpase_h.plot()\n\n<Axes: xlabel='Time /hr'>\n\n\n\n\n\nThe flux through the H+-ATPASe increases over the first hour or so, but we are only interested in the first half an hour ish:\n\nfrom scipy import stats\n\nlinreg = stats.linregress(x=onguard_df[onguard_df.index < 0.5].index, y=atpase_h[onguard_df.index < 0.5])\n\n\nplt.plot(onguard_df[onguard_df.index < 1].index, atpase_h[onguard_df.index < 1])\nplt.plot(onguard_df[onguard_df.index < 0.5].index,\n         (onguard_df[onguard_df.index < 0.5].index) * linreg.slope + linreg.intercept)\nplt.ylabel(\"H+-ATPase flux (fmol/h)\")\n\nText(0, 0.5, 'H+-ATPase flux (fmol/h)')\n\n\n\n\n\nAs the increase in flux through the H+-ATPase looks pretty linear from 0 to 0.5 hours, we can take the average over this time period and use it as our constraint\n\natpase_h[onguard_df.index < 0.5].mean()\n\n7.499933868292683"
  },
  {
    "objectID": "1.3_atpase_constraint.html#conclusions",
    "href": "1.3_atpase_constraint.html#conclusions",
    "title": "Is H+ATPase limiting?",
    "section": "Conclusions",
    "text": "Conclusions\nSo even though the Flutsch value is higher (17 fmoles/h), it looks like this value from the OnGuard model might be a good value to use as our constraint, as it will about half the H+-ATPase rate for us (7.5 fmoles/h vs 13.9 fmoles/h)."
  },
  {
    "objectID": "prep_plant_cell.html",
    "href": "prep_plant_cell.html",
    "title": "Preparing data for ‘The Plant Cell’ submission",
    "section": "",
    "text": "This is pretty slow as the files are large\n\nimport os\nimport cobra\n\nimport pandas as pd\n\n\ni = 1\n\n\nmodel = cobra.io.read_sbml_model(\"../models/4_stage_GC.xml\")\ncobra.io.write_sbml_model(model, f\"../plant_cell_paper/tpc00001-SupplementalDS{i}.xml\")\ni += 1\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\nmodel_solutions_legend = \"Apart from this one, each sheet contains the solution to the scenario given by the sheet name in the format [light_scenario]_[atpase constrained or unconstrained]_[starch is wt or ko]. Rows are reaction ids, fluxes column is the solution, and minimum and maximum give the flux bounds from FVA for the reactions which it was carried out on.\"\n\n\nwith pd.ExcelWriter(f\"../plant_cell_paper/tpc00001-SupplementalDS{i}.xlsx\") as writer:\n    legend_df = pd.DataFrame([model_solutions_legend])\n    legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n    for file in os.listdir(\"../outputs/model_solutions\"):\n        filename = os.fsdecode(file)\n        if filename.endswith(\".csv\"):\n            solution_df = pd.read_csv(\"../outputs/model_solutions/\" + file, index_col=0)\n            solution_df.to_excel(writer, sheet_name=filename[:-4])\ni += 1\n\n\nfile_list = [\"../outputs/constraint_scan/constraints_df.csv\", \"../outputs/constraint_scan/constraint_scan_results_blue.csv\",\n             \"../outputs/constraint_scan/constraint_scan_results_white.csv\", \"../outputs/alternative_weighting/alternative_weights.csv\"]\nconstraints_df_legend = \"The data sheet contains the list of constraints used to constrain the model in the constraint scan\"\nscan_results_blue_legend = \"The data sheet contains the flux results for each set of constraints in the constraint scan for the model solved under blue light. The rows correspond to the constraints list and the columns to reaction IDs.\"\nscan_results_white_legend = \"The data sheet contains the flux results for each set of constraints in the constraint scan for the model solved under white light. The rows correspond to the constraints list and the columns to reaction IDs.\"\nalternative_weights_legend = \"The data sheet contains the list of alternative weights used in the analysis, with the reaction IDs as columns and rows the different sets of weights\"\nlegend_list = [constraints_df_legend, scan_results_blue_legend, scan_results_white_legend, alternative_weights_legend]\n\n\nfor file, legend in zip(file_list, legend_list):\n    with pd.ExcelWriter(f\"../plant_cell_paper/tpc00001-SupplementalDS{i}.xlsx\") as writer:\n        legend_df = pd.DataFrame([legend])\n        legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n        file_df = pd.read_csv(file, index_col=0)\n        file_df.to_excel(writer, sheet_name=\"Data\")\n        i += 1\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        for starch in [\"wt\", \"ko\"]:\n            filename = f\"../outputs/alternative_weighting/solution_{light}_{atpase}_{starch}.csv\"\n            legend = f\"The data sheet contains the results for solving the alternative weightings for the scenario with {light} light, {atpase} ATPase, and {starch} starch. The columns are reaction IDs and the rows match the alternative weights given in Supplemental Data Set 6\"\n            try:\n                with pd.ExcelWriter(f\"../plant_cell_paper/tpc00001-SupplementalDS{i}.xlsx\") as writer:\n                    legend_df = pd.DataFrame([legend])\n                    legend_df.to_excel(writer, sheet_name=\"Legend\",index=False, header=False)\n                    solution_df = pd.read_csv(filename, index_col=0)\n                    solution_df.to_excel(writer, sheet_name=\"Data\")\n\n                i += 1\n\n            except:\n                print(f\"No solution for {light}, {atpase}, {starch}\")\n\nNo solution for white, unconstrained, wt\nNo solution for white, unconstrained, ko\nNo solution for nops, unconstrained, wt\nNo solution for nops, unconstrained, ko"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html",
    "href": "3.3_analyse_constraint_scan.html",
    "title": "Analysing the results of the constraint scan",
    "section": "",
    "text": "import cobra\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib.cm import ScalarMappable\nfrom matplotlib.colors import Normalize\nfrom matplotlib.ticker import AutoMinorLocator, MultipleLocator\nfrom mmon_gcm.analysing import get_phase_lengths\nfrom mmon_gcm.supermodel import SuperModel\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom sklearn.preprocessing import OneHotEncoder, StandardScaler"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#importing-results-and-constraints",
    "href": "3.3_analyse_constraint_scan.html#importing-results-and-constraints",
    "title": "Analysing the results of the constraint scan",
    "section": "Importing results and constraints",
    "text": "Importing results and constraints\n\n# import results files\nblue_results = pd.read_csv(\"../outputs/constraint_scan/constraint_scan_results_blue.csv\", index_col=0)\nwhite_results = pd.read_csv(\"../outputs/constraint_scan/constraint_scan_results_white.csv\", index_col=0)\nscan_results = pd.concat([white_results, blue_results])\nscan_results = scan_results.reset_index().drop(\"index\", axis=1)\n# remove solutions which were not feasible\ninfeasible_solutions = scan_results[scan_results.isna().any(axis=1)]\nfeasible_solutions = scan_results.dropna()\nscan_results = feasible_solutions\n\n\n# convert any fluxes that are below 10^-6 to 0\nscan_results = scan_results.mask(abs(scan_results) < 0.000001, other=0)\n\n\n# import constraints files\nwhite_constraints = pd.read_csv(\"../outputs/constraint_scan/constraints_df.csv\", index_col=0)\nwhite_constraints[\"light\"] = \"white\"\nblue_constraints = pd.read_csv(\"../outputs/constraint_scan/constraints_df.csv\", index_col=0)\nblue_constraints[\"light\"] = \"blue\"\nscan_constraints = pd.concat([white_constraints, blue_constraints])\nscan_constraints = scan_constraints.reset_index().drop(\"index\", axis=1)\n# remove infeasible constraints combinations\nfeasible_scan_constraints = scan_constraints.loc[feasible_solutions.index]\ninfeasible_scan_constraints = scan_constraints.loc[infeasible_solutions.index]\nscan_constraints = feasible_scan_constraints\n\n\n# import constraints that were used in previous paper solutions\ndefault_constraints = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)[\"Value\"]\n\npaper_constraints = []\nindex = []\nfor light in [\"white\", \"blue\", \"nops\"]:\n    for constraint in [\"unconstrained\", \"constrained\"]:\n        constraints = default_constraints.copy()\n        if constraint == \"unconstrained\":\n            constraints[\"ATPase\"] = 1000\n        elif constraint == \"constrained\":\n            constraints[\"ATPase\"] = 7.48\n        constraints[\"light\"] = light\n        index.append(f\"{light}_{constraint}_wt\")\n        paper_constraints.append(constraints)\npaper_constraints = pd.DataFrame(paper_constraints, index=index)\npaper_constraints = paper_constraints.iloc[1, :-1]\npaper_constraints\n\nP_abs                  0.9\nT_l                0.00017\nA_l                    1.0\nV_gc_ind               0.0\nFqFm                   0.9\nR_ch              0.069231\nL_air                 0.37\nL_epidermis           0.15\nVac_frac             0.751\nT                   296.15\nR                  0.08205\nN_gcs          580000000.0\nn                      2.5\nm                      0.8\nr                      0.0\ns                      0.0\nC_apo              0.02302\nA_closed               1.6\nA_open                2.75\nATPase                7.48\nName: white_constrained_wt, dtype: object\n\n\n\n# import results for previous simulations in paper\npaper_solution_files = []\n\nfor light in [\"white\", \"blue\", \"nops\"]:\n    for constraint in [\"unconstrained\", \"constrained\"]:\n        paper_solution_files.append(f\"{light}_{constraint}_wt.csv\")\nsolution_dfs = [pd.read_csv(f\"../outputs/model_solutions/{file_name}\",\n                            index_col=0)[\"fluxes\"] for file_name in paper_solution_files]\npaper_results = pd.concat(solution_dfs, axis=1).T\npaper_results.index = index\n\n\n# get a reduced get of constraints that are more specific to the guard cell\n\nscan_gc_constraints = pd.DataFrame.from_dict(list(scan_constraints.apply(get_bounds_in_model, axis=1)))\nscan_gc_constraints[\"Os_dif\"] = scan_gc_constraints[\"Os_open\"]-scan_gc_constraints[\"Os_closed\"]\nscan_gc_constraints.index = scan_constraints.index\nscan_gc_constraints.head()\n\n/home/nls119/src/mmon-gcm2/mmon_gcm/supermodel.py:23: UserWarning: No fba model added to the Supermodel, fine if that's what you want\n  warnings.warn(\"No fba model added to the Supermodel, fine if that's what you want\")\n\n\n\n\n\n\n  \n    \n      \n      V_closed\n      V_open\n      Os_closed\n      Os_open\n      Photons\n      ATPase\n      Os_dif\n    \n  \n  \n    \n      0\n      0.000223\n      0.000396\n      0.043690\n      0.146301\n      0.179889\n      0.000401\n      0.102611\n    \n    \n      1\n      0.000352\n      0.000513\n      0.089882\n      0.208754\n      0.472789\n      0.010845\n      0.118871\n    \n    \n      2\n      0.000441\n      0.000619\n      0.107437\n      0.225174\n      0.473290\n      0.001625\n      0.117737\n    \n    \n      3\n      0.000302\n      0.000630\n      0.064496\n      0.347008\n      0.509358\n      0.001168\n      0.282512\n    \n    \n      4\n      0.000096\n      0.000290\n      0.018519\n      0.149224\n      0.250117\n      0.000062\n      0.130705\n    \n  \n\n\n\n\n\npaper_gc_constraints = pd.Series(get_bounds_in_model(paper_constraints))\npaper_gc_constraints[\"Os_dif\"] = paper_gc_constraints[\"Os_open\"]-paper_gc_constraints[\"Os_closed\"]\npaper_gc_constraints\n\n/home/nls119/src/mmon-gcm2/mmon_gcm/supermodel.py:23: UserWarning: No fba model added to the Supermodel, fine if that's what you want\n  warnings.warn(\"No fba model added to the Supermodel, fine if that's what you want\")\n\n\nV_closed     0.000220\nV_open       0.000254\nOs_closed    0.039359\nOs_open      0.054922\nPhotons      0.091641\nATPase       0.004338\nOs_dif       0.015563\ndtype: float64"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#a---what-contributes-to-phloem-output",
    "href": "3.3_analyse_constraint_scan.html#a---what-contributes-to-phloem-output",
    "title": "Analysing the results of the constraint scan",
    "section": "7a - What contributes to phloem output?",
    "text": "7a - What contributes to phloem output?\n\nSet up features for linear regression by\n\nConvert light using onehotencoder\n\n# extract the subject column as a pandas DataFrame\nlight = scan_constraints[[\"light\"]]\n# setting sparse=False means that enc.transform() will return an array\nenc = OneHotEncoder(sparse_output=False)\n\n# fit the encoder to the data\nenc.fit(light)\n\n# encode the data\nlight_enc = enc.transform(light)\nlight_columns = pd.DataFrame(light_enc, columns=\"light_\" + enc.categories_[0])\nfull_features = scan_constraints.drop(\"light\", axis=1).join(light_columns)\ngc_features = scan_gc_constraints.join(light_columns)\n\n\n\nAlso create scaled versions of features\n\nscaler = StandardScaler()\n\nscaler.fit(full_features)\nfull_features_scaled = scaler.transform(full_features)\n\nscaler.fit(gc_features)\ngc_features_scaled = scaler.transform(gc_features)\n\n\n\n\nCompare full and gc features\n\nresponse = scan_results.Phloem_tx_overall\n\nlm_full = LinearRegression()\nlm_full.fit(full_features, response)\nfull_pred = lm_full.predict(full_features)\nprint(\"Mean squared error, MSE = %.5f\" % mean_squared_error(response, full_pred))\nprint(\"Coefficient of determination, r2 = %.5f\" % r2_score(response, full_pred))\n\nlm_gc = LinearRegression()\nlm_gc.fit(gc_features, response)\ngc_pred = lm_gc.predict(gc_features)\nprint(\"Mean squared error, MSE = %.5f\" % mean_squared_error(response, gc_pred))\nprint(\"Coefficient of determination, r2 = %.5f\" % r2_score(response, gc_pred))\n\nMean squared error, MSE = 0.00041\nCoefficient of determination, r2 = 0.99960\nMean squared error, MSE = 0.85966\nCoefficient of determination, r2 = 0.15120\n\n\nSo can’t predict phloem output using GC features, but can predict pretty well using the full set\n\nWhich features are most important?\n\npd.DataFrame(lm_full.coef_, index=full_features.columns).sort_values(by=0)\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      T_l\n      -7.716594e-01\n    \n    \n      light_blue\n      -3.504391e-01\n    \n    \n      m\n      -9.376244e-04\n    \n    \n      A_open\n      -1.647888e-04\n    \n    \n      Vac_frac\n      -1.228209e-04\n    \n    \n      n\n      -3.861555e-05\n    \n    \n      FqFm\n      -1.762768e-05\n    \n    \n      V_gc_ind\n      -9.025010e-10\n    \n    \n      s\n      -4.246077e-11\n    \n    \n      N_gcs\n      -1.013508e-12\n    \n    \n      R\n      -1.636531e-13\n    \n    \n      A_l\n      6.923333e-13\n    \n    \n      r\n      3.359222e-12\n    \n    \n      T\n      1.134554e-06\n    \n    \n      ATPase\n      6.590579e-06\n    \n    \n      L_air\n      1.577355e-05\n    \n    \n      A_closed\n      1.014129e-04\n    \n    \n      L_epidermis\n      1.088898e-04\n    \n    \n      R_ch\n      3.235657e-04\n    \n    \n      C_apo\n      1.648781e-03\n    \n    \n      light_white\n      3.504391e-01\n    \n    \n      P_abs\n      1.816986e+01\n    \n  \n\n\n\n\nLots of unimportant features so we can use lasso regression to see which ones we really need\n\n\nTry different alphas for lasso to see r2\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.01, 0.1, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features, response)\n    lasso_pred = lasso.predict(full_features)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.01    0.962348\n0.02    0.850602\n0.03    0.664360\n0.04    0.403621\n0.05    0.118469\n0.06    0.113857\n0.07    0.108407\n0.08    0.102119\n0.09    0.094992\n0.10    0.087026\ndtype: float64\n\n\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.001, 0.01, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features, response)\n    lasso_pred = lasso.predict(full_features)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.001    0.999224\n0.002    0.998106\n0.003    0.996244\n0.004    0.993637\n0.005    0.990284\n0.006    0.986187\n0.007    0.981345\n0.008    0.975757\n0.009    0.969425\n0.010    0.962348\ndtype: float64\n\n\nLets take 0.03 as it’s highest that rounds to 0.999\n\n\nLasso with alpha = 0.003\n\nlasso = Lasso(alpha=0.003)\nlasso.fit(full_features, response)\nlasso_pred = lasso.predict(full_features)\nlass_coefs = pd.DataFrame(lasso.coef_, index=full_features.columns).sort_values(by=0)\n# display coefficients that aren't 0\nlass_coefs[abs(lass_coefs.loc[:, 0]) > 0.00001]\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      light_blue\n      -0.688878\n    \n    \n      A_open\n      -0.001152\n    \n    \n      ATPase\n      -0.000150\n    \n    \n      T\n      0.000204\n    \n    \n      P_abs\n      17.048822\n    \n  \n\n\n\n\nP_abs and light are by far the largest coefficients\n\n\nTry scaled as well\n\nfrom sklearn.linear_model import Lasso\n\nalphas = np.linspace(0.01, 0.1, 10)\nr2s = []\n\nfor alpha in alphas:\n    lasso = Lasso(alpha=alpha)\n    lasso.fit(full_features_scaled, response)\n    lasso_pred = lasso.predict(full_features_scaled)\n    r2s.append(r2_score(response, lasso_pred))\n\npd.Series(r2s, index=alphas)\n\n0.01    0.999399\n0.02    0.998806\n0.03    0.997819\n0.04    0.996437\n0.05    0.994659\n0.06    0.992487\n0.07    0.989920\n0.08    0.986958\n0.09    0.983601\n0.10    0.979849\ndtype: float64\n\n\n\nlasso = Lasso(alpha=0.01)\nlasso.fit(full_features_scaled, response)\nlasso_pred = lasso.predict(full_features_scaled)\nlass_coefs = pd.DataFrame(lasso.coef_, index=full_features.columns).sort_values(by=0)\nprint(f\"r2 score: {r2_score(response, lasso_pred)}\")\n# display coefficients that aren't 0\nlass_coefs[abs(lass_coefs.loc[:, 0]) > 0.00001]\n\nr2 score: 0.9993985733606163\n\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      light_blue\n      -0.340439\n    \n    \n      P_abs\n      0.933180\n    \n  \n\n\n\n\nWhen scaled this is even clearer\n\ndef phloemoutput_subfig(ax):\n\n    for light, colour in zip([\"white\", \"blue\"], [sns.color_palette()[1], sns.color_palette()[0]]):\n\n        constraints_light_df = scan_constraints[scan_constraints.light == light]\n        results_light_df = scan_results[scan_constraints.light == light]\n\n        ax.scatter(constraints_light_df.P_abs, results_light_df.Phloem_tx_overall,\n                   label=light.capitalize(), color=colour)\n\n    ax.legend(title=\"Light during opening\")\n    ax.set_xlabel(\"$P_{abs}$\\n(Prop. photons absorbed by leaf)\", size=\"medium\")\n    ax.set_ylabel(\"Phloem output\\n(mmol$\\cdot$m$^{-2}$leaf$\\cdot$h$^{-1}$)\", size=\"medium\")\n\n    ax.set_ylim(13.9, 19)\n    ax.set_xlim(0.797, 1)\n    ax.spines['left'].set_bounds(14, 19)\n    ax.spines['bottom'].set_bounds(0.8, 1)\n    ax.xaxis.set_major_locator(MultipleLocator(0.1))\n    # ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(1))\n    # ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n\n    ax.set_aspect(abs(1-0.8)/abs(19-14))\n\n    return ax\n\n\nfig, ax = plt.subplots()\nphloemoutput_subfig(ax)\n\n<Axes: xlabel='$P_{abs}$\\n(Prop. photons absorbed by leaf)', ylabel='Phloem output\\n(mmol$\\\\cdot$m$^{-2}$leaf$\\\\cdot$h$^{-1}$)'>"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#b---what-affects-hexose-export-from-the-guard-cell",
    "href": "3.3_analyse_constraint_scan.html#b---what-affects-hexose-export-from-the-guard-cell",
    "title": "Analysing the results of the constraint scan",
    "section": "7b - What affects hexose export from the guard cell?",
    "text": "7b - What affects hexose export from the guard cell?\n\nGenerate hexose export df\n\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\n\n# get total flux across all phases\nnet_carbon_dict = {}\nfor metabolite in [\"GLC\", \"FRU\", \"SUCROSE\"]:\n    net_metabolite = 0\n    for i, phase_length in enumerate(get_phase_lengths(four_stage_GC_model)):\n        phase_number = i+1\n        net_metabolite = net_metabolite + \\\n            scan_results.loc[:, f\"{metabolite}_ae_gc_{phase_number}\"]*phase_length\n    net_carbon_dict[metabolite] = net_metabolite\nnet_carbon_df = pd.DataFrame.from_dict(net_carbon_dict)\n\n# correct for fact that sucrose is two hexoses\nnet_carbon = (net_carbon_df.GLC + net_carbon_df.FRU + net_carbon_df.SUCROSE*2) * -1  # mmol.m2-1\nnet_carbon = net_carbon * 10**-3  # moles.m2-1\ncarbon_per_gc = net_carbon / scan_constraints.N_gcs  # moles.gc-1\ncarbon_per_gc = carbon_per_gc * 10**15  # fmol.gc-1\n\nNo objective coefficients in model. Unclear what should be optimized\n\n\n\n\nFit model to hexose export\n\nresponse = carbon_per_gc\nfor features in [full_features, gc_features]:\n    lm_1 = LinearRegression()\n    lm_1.fit(features, response)\n    pred = lm_1.predict(features)\n    print(\"Mean squared error, MSE = %.2f\" % mean_squared_error(response, pred))\n    print(\"Coefficient of determination, r2 = %.2f\" % r2_score(response, pred))\n\nMean squared error, MSE = 9919.47\nCoefficient of determination, r2 = 0.41\nMean squared error, MSE = 3274.79\nCoefficient of determination, r2 = 0.80\n\n\nSo hexose export can be better predicted using the gc features compared to all the features. Is this because it’s hexose per gc?\n\nresponse = net_carbon\nfor features in [full_features, gc_features]:\n    lm_1 = LinearRegression()\n    lm_1.fit(features, response)\n    pred = lm_1.predict(features)\n    print(\"Mean squared error, MSE = %.2f\" % mean_squared_error(response, pred))\n    print(\"Coefficient of determination, r2 = %.2f\" % r2_score(response, pred))\n\nMean squared error, MSE = 0.00\nCoefficient of determination, r2 = 0.51\nMean squared error, MSE = 0.00\nCoefficient of determination, r2 = 1.00\n\n\nSeems so, as we’re confusing things by introducing the N_gcs division into the response\n\nresponse = net_carbon\nlm_1 = LinearRegression()\nlm_1.fit(gc_features, response)\npred = lm_1.predict(gc_features)\nlm_coefs = pd.DataFrame(lm_1.coef_, index=gc_features.columns).sort_values(by=0)\nlm_coefs[abs(lm_coefs.loc[:, 0]) > 0.00001]\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      V_closed\n      -0.009206\n    \n    \n      Os_dif\n      -0.000030\n    \n    \n      Os_closed\n      0.000025\n    \n    \n      ATPase\n      0.000059\n    \n    \n      Photons\n      0.000233\n    \n    \n      V_open\n      0.003493\n    \n  \n\n\n\n\nMainly different light colours as well as osmolarity. What if we correct for light colour?\n\n\nCreate a reponse for total photons into the GC, irrespective of blue or white light\n\nphoton_influx = scan_results.loc[:, \"Photon_tx_gc_3\"]\nphoton_hours = scan_constraints.loc[:, \"light\"].apply(lambda x: 12 if x == \"white\" else 11.5)\ntotal_photons_per_day = photon_influx * photon_hours\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.999035\n\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      Photons per day\n      0.00002\n    \n  \n\n\n\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day, gc_features.Os_dif]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\", \"Os dif\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.999911\n\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      Os dif\n      -0.00003\n    \n    \n      Photons per day\n      0.00002\n    \n  \n\n\n\n\nPretty good R2\n\nresponse = net_carbon\nfeatures = np.array(gc_features.ATPase).reshape(-1, 1)\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\npd.DataFrame(lm_1.coef_, index=[\"ATPase\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.075506\n\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      ATPase\n      0.00689\n    \n  \n\n\n\n\nATPase can’t really predict hexose export, at least not by itself\n\ndef photons_vs_carbon_export_subfig(ax):\n\n    max_os_dif = scan_gc_constraints.Os_dif.max().round(1)\n    norm = Normalize(vmin=0, vmax=max_os_dif)\n    mappable = ScalarMappable(norm=norm, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    net_carbon_mmol = net_carbon * 10 ** 3\n\n    ax.scatter(total_photons_per_day, net_carbon_mmol, c=scan_gc_constraints.Os_dif,\n               norm=norm, s=10, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    cbaxes = ax.inset_axes([0.1, 0.93, 0.40, 0.05])\n    cbar = plt.colorbar(mappable, cax=cbaxes, ticks=[0, max_os_dif], orientation='horizontal')\n    cbar.set_label(\"Osmolarity increase\\n(mmol$\\cdot$m$^{-2}\\cdot$d$^{-1}$)\", size=10)\n\n    inset_ax = ax.inset_axes([0.7, 0.15, 0.3, 0.3])\n    inset_ax.scatter(total_photons_per_day, net_carbon_mmol, c=scan_gc_constraints.Os_dif,\n                     s=1, cmap=sns.color_palette(\"crest\", as_cmap=True))\n    inset_ax.set_xlim([-0.3/10, 2])\n    inset_ax.set_ylim([-0.02/5, 0.04])\n    inset_ax.tick_params(labelsize=10)\n    inset_ax.spines['left'].set_bounds(0, 0.04)\n    inset_ax.spines['bottom'].set_bounds(0, 2)\n    inset_ax.yaxis.set_major_locator(MultipleLocator(0.04))\n    inset_ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    inset_ax.xaxis.set_major_locator(MultipleLocator(2))\n    inset_ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n\n    ax.set_xlim([-0.5, 40])\n    ax.set_ylim([-0.02, 0.75])\n    ax.spines['left'].set_bounds(0, 0.75)\n    ax.spines['bottom'].set_bounds(0, 40)\n    ax.xaxis.set_major_locator(MultipleLocator(20))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(0.25))\n    ax.set_aspect(abs(40-0)/abs(0.75-0))\n\n    ax.set_xlabel(\"Photons per day into GC\\n\" + r\"(mmol$\\cdot$m$^{-2}\\cdot$d$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(\"Net hexose export flux from GC\\n\" + r\"(mmol$\\cdot$m$^{-2}\\cdot$h$^{-1}$)\", size=\"medium\")\n\n    return ax\n\n\nfig, ax = plt.subplots()\nphotons_vs_carbon_export_subfig(ax)\n\n<Axes: xlabel='Photons per day into GC\\n(mmol$\\\\cdot$m$^{-2}\\\\cdot$d$^{-1}$)', ylabel='Net hexose export flux from GC\\n(mmol$\\\\cdot$m$^{-2}\\\\cdot$h$^{-1}$)'>\n\n\n\n\n\n\n\nAre there any solutions that are below 0?\n\n(net_carbon < 0).sum()\n\n2\n\n\nWhat’s interesting about them?\n\nscan_constraints.loc[net_carbon < 0]\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      ...\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n      light\n    \n  \n  \n    \n      180\n      0.905621\n      0.000238\n      1.0\n      5.504346e-13\n      0.851331\n      0.042463\n      0.229569\n      0.166053\n      0.804005\n      297.456238\n      ...\n      6.273035e+08\n      1.96254\n      0.80448\n      6.905245e-14\n      1.886476e-13\n      0.028729\n      1.953838\n      11.38203\n      8.971524\n      white\n    \n    \n      1152\n      0.905621\n      0.000238\n      1.0\n      5.504346e-13\n      0.851331\n      0.042463\n      0.229569\n      0.166053\n      0.804005\n      297.456238\n      ...\n      6.273035e+08\n      1.96254\n      0.80448\n      6.905245e-14\n      1.886476e-13\n      0.028729\n      1.953838\n      11.38203\n      8.971524\n      blue\n    \n  \n\n2 rows × 21 columns\n\n\n\n\nscan_gc_constraints.loc[net_carbon < 0]\n\n\n\n\n\n  \n    \n      \n      V_closed\n      V_open\n      Os_closed\n      Os_open\n      Photons\n      ATPase\n      Os_dif\n    \n  \n  \n    \n      180\n      0.000203\n      0.000611\n      0.035224\n      0.296097\n      0.039867\n      0.005628\n      0.260872\n    \n    \n      1152\n      0.000203\n      0.000611\n      0.035224\n      0.296097\n      0.039867\n      0.005628\n      0.260872\n    \n  \n\n\n\n\nOk they are the same just with different light colours. Is it the photon/od_dif ratio?\n\nscan_gc_constraints.loc[180, \"Photons\"] / scan_gc_constraints.loc[180, \"Os_dif\"]\n\n0.15282224853377138\n\n\n\n(scan_gc_constraints.loc[:, \"Photons\"]/scan_gc_constraints.loc[:, \"Os_dif\"]).min()\n\n0.15282224853377138\n\n\nYes, it has the lowest photon:od_diff ratio of any combination"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#at-our-predicted-level-of-osmolarity-and-other-guard-cell-parameters-what-would-fqfm.r_ch-need-to-be-for-guard-cell-to-act-as-a-sink",
    "href": "3.3_analyse_constraint_scan.html#at-our-predicted-level-of-osmolarity-and-other-guard-cell-parameters-what-would-fqfm.r_ch-need-to-be-for-guard-cell-to-act-as-a-sink",
    "title": "Analysing the results of the constraint scan",
    "section": "At our predicted level of osmolarity and other guard cell parameters, what would FqFm.R_ch need to be for guard cell to act as a sink?",
    "text": "At our predicted level of osmolarity and other guard cell parameters, what would FqFm.R_ch need to be for guard cell to act as a sink?\n\\(e = FqFm \\cdot R_{ch}\\) <- We want to know e, that is the capacity of guard cell vs mesophyll. Function of efficiency and number of chloroplasts\n\\(P_{gc} = e \\cdot v\\_prop_{gc} \\cdot P\\)\n\\(e = \\frac{P_{gc}}{v\\_prop_{gc} \\cdot P}\\)\n\nP = 150 * paper_constraints.P_abs\nP = P * 10 ** -3 * 60 * 60  # umolessec-1 -> mmolhr-1\n\n\nV_l = paper_constraints.T_l * paper_constraints.A_l  # volume of leaf is area x thickness\nV_l = V_l * 10 ** 3  # (Total leaf volume) m3 -> dm3 = 10**3\n\nV_gc = paper_constraints.V_gc_ind * paper_constraints.N_gcs  # total volume of gc in leaf\n\n# volume of meosphyll is leaf that isn't epidermis or air\nV_me = V_l * (1 - paper_constraints.L_epidermis) * (1 - paper_constraints.L_air)\n\nv_prop_gc = V_gc / V_me  # volume of gc is negligable\n\n\nresponse = net_carbon\nfeatures = np.array([total_photons_per_day, gc_features.Os_dif]).T\nlm_1 = LinearRegression()\nlm_1.fit(features, response)\npred = lm_1.predict(features)\nprint(\"Mean squared error, MSE = %.6f\" % mean_squared_error(response, pred))\nprint(\"Coefficient of determination, r2 = %.6f\" % r2_score(response, pred))\nprint(f\"Intercept: {lm_1.intercept_}\")\npd.DataFrame(lm_1.coef_, index=[\"Photons per day\", \"Os dif\"]).sort_values(by=0)\n\nMean squared error, MSE = 0.000000\nCoefficient of determination, r2 = 0.999911\nIntercept: -6.79617736739377e-08\n\n\n\n\n\n\n  \n    \n      \n      0\n    \n  \n  \n    \n      Os dif\n      -0.00003\n    \n    \n      Photons per day\n      0.00002\n    \n  \n\n\n\n\n$ C_{net} = -3^{-5}Os_{dif} + 2^{-5}P_{day} - 6.80 ^{-8}$\n$ 0 = -3^{-5} + 2^{-5}P_{day} - 6.80 ^{-8}$\n$ = P_{day}$\n\nos_dif_coef = lm_1.coef_[1]\nphotons_per_day_coef = lm_1.coef_[0]\nos_in_selected_scenarios = paper_gc_constraints.Os_dif\nintercept = lm_1.intercept_\n\n\nphotons_needed = (intercept - os_dif_coef*os_in_selected_scenarios)/photons_per_day_coef\nphotons_needed\n\n0.020218242888203602\n\n\n\ntotal_photons_per_day.min()/photons_needed\n\n14.958540346092619\n\n\nSo at that osmolarity for the guard cell to act as sink tissue the total level of photons coming in would have to be 15x lower than we see in any of our scenarios, which will be for blue light\n\nphoton_influx = photons_needed/11.5\n\n\\(e = \\frac{P_{gc}}{v\\_prop_{gc} \\cdot P}\\)\n\ne = photon_influx/(v_prop_gc*P)\ne*100\n\n0.11953527728193179\n\n\nSo the capacity for photosynthesis in the guard cell only needs to be 0.1% of that of the mesophyll to act as a source tissue\n\nWhat is the range of photosynthetic capacities that we use?\n\ncapacity_percentages = (scan_constraints.FqFm * scan_constraints.R_ch)*100\nprint(f\"High: {capacity_percentages.max()}\")\nprint(f\"Low: {capacity_percentages.min()}\")\n\nHigh: 16.398489377751467\nLow: 2.8086635016180743"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#c---so-does-the-atpase-have-an-effect-on-starch-if-not-on-hexose-export-very-much",
    "href": "3.3_analyse_constraint_scan.html#c---so-does-the-atpase-have-an-effect-on-starch-if-not-on-hexose-export-very-much",
    "title": "Analysing the results of the constraint scan",
    "section": "7c - So does the ATPase have an effect on starch if not on hexose export very much?",
    "text": "7c - So does the ATPase have an effect on starch if not on hexose export very much?\n\nHow many solutions utilise starch?\n\nstarch = scan_results.STARCH_p_gc_Linker_1 - scan_results.STARCH_p_gc_Linker_2\nprint(f\"{(starch > 0).sum()} or {(starch > 0).sum()/len(starch) * 100:.0f}%\")\n\n1891 or 97%"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#in-how-many-of-those-solutions-is-the-atpase-constrained",
    "href": "3.3_analyse_constraint_scan.html#in-how-many-of-those-solutions-is-the-atpase-constrained",
    "title": "Analysing the results of the constraint scan",
    "section": "In how many of those solutions is the ATPase constrained?",
    "text": "In how many of those solutions is the ATPase constrained?\n\natpase_constrained = (abs(scan_gc_constraints.ATPase-scan_results.PROTON_ATPase_c_gc_2) < 0.000001)\n(atpase_constrained & starch > 0).sum()\n\n1890\n\n\nSo there is one solution which doesn’t\n\nscan_gc_constraints[(~atpase_constrained & starch > 0)]\n\n\n\n\n\n  \n    \n      \n      V_closed\n      V_open\n      Os_closed\n      Os_open\n      Photons\n      ATPase\n      Os_dif\n    \n  \n  \n    \n      1685\n      0.000254\n      0.000316\n      0.050405\n      0.075048\n      1.393555\n      0.01318\n      0.024642\n    \n  \n\n\n\n\n\n(scan_gc_constraints.loc[1685] - scan_gc_constraints.mean())/scan_gc_constraints.std()\n\nV_closed     0.111731\nV_open      -0.602100\nOs_closed   -0.024406\nOs_open     -0.918384\nPhotons      1.760322\nATPase       1.728109\nOs_dif      -1.023596\ndtype: float64\n\n\nHigh photons, high ATPase, low osmolarity dif"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#how-many-constrained-solutions-dont-use-starch",
    "href": "3.3_analyse_constraint_scan.html#how-many-constrained-solutions-dont-use-starch",
    "title": "Analysing the results of the constraint scan",
    "section": "How many constrained solutions don’t use starch?",
    "text": "How many constrained solutions don’t use starch?\n\n(atpase_constrained & (starch == 0)).sum()\n\n1\n\n\n\nscan_gc_constraints[(atpase_constrained & (starch == 0))]\n\n\n\n\n\n  \n    \n      \n      V_closed\n      V_open\n      Os_closed\n      Os_open\n      Photons\n      ATPase\n      Os_dif\n    \n  \n  \n    \n      1315\n      0.000356\n      0.000376\n      0.073848\n      0.082492\n      0.806864\n      0.004604\n      0.008644\n    \n  \n\n\n\n\n\n(scan_gc_constraints.loc[1315] - scan_gc_constraints.mean())/scan_gc_constraints.std()\n\nV_closed     0.970232\nV_open      -0.337247\nOs_closed    0.787662\nOs_open     -0.858245\nPhotons      0.509296\nATPase      -0.255409\nOs_dif      -1.168544\ndtype: float64\n\n\nOsmolarity difference is low, photons are high, atpase is low. Closed osmolarity is high, forcing the use of something else?\nIncrease per GC allows comparison with literature values\n\nstarch_per_gc = starch * 10**-3 / scan_constraints.N_gcs * 10**15  # fmol.gc-1\n\n\nhorrer_starch_level = 184\n\n\nos_increase_per_gc = scan_gc_constraints.Os_dif * 10**-3 / scan_constraints.N_gcs * 10**15\nprotons_moved_per_gc = scan_results.PROTON_ATPase_c_gc_2 * 10**-3 / scan_constraints.N_gcs * 10**15\n\n\nprotons_moved_per_gc.max()\n\n16.995468262384303\n\n\n\ndef starch_vs_os_subfig(ax):\n    dot_size = 2\n\n    norm = Normalize(vmin=0, vmax=15)\n    mappable = ScalarMappable(norm=norm, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    ax.plot([0, 600], [0, 600], c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    sc = ax.scatter(os_increase_per_gc, starch_per_gc, s=dot_size, c=protons_moved_per_gc,\n                    norm=norm, cmap=sns.color_palette(\"crest\", as_cmap=True))\n\n    cbaxes = ax.inset_axes([0.15, 0.93, 0.40, 0.05])\n    cbar = plt.colorbar(mappable, cax=cbaxes, ticks=[0, 15], orientation='horizontal')\n    cbar.set_label(\"Total H$^+$ export\\n(fmol$\\cdot$GC$^{-1}$)\", size=10)\n\n    y_max = 600\n    y_min = -20\n    x_max = 600\n    x_min = -20\n    ax.set_ylim(y_min, y_max)\n    ax.set_xlim(x_min, x_max)\n    ax.spines['left'].set_bounds(0, y_max)\n    ax.spines['bottom'].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(200))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(200))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect(1)\n\n    ax.set_xlabel(\"Osmolarity increase (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(r\"Starch degradation (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    #ax.hlines(-155, xmin=0.15, xmax=0.99, clip_on=False, linewidth=1, color='.15')\n\n    ax.hlines(184, xmin=0, xmax=x_max, linewidth=1, linestyle=\"--\", color=sns.color_palette()[6])\n    ax.text(x_max, 175, \"Horrer et al. (2016)\", ha=\"right\", va=\"top\", size=\"x-small\", color=sns.color_palette()[6])\n\n    paper_scenarios_colour = sns.color_palette()[2]\n    ax.vlines(26.83, ymin=0, ymax=110, linewidth=1, linestyle=\"--\", color=paper_scenarios_colour)\n    ax.text(50, 120, \"Paper\\nscenarios\", ha=\"center\", va=\"bottom\", size=\"x-small\", color=paper_scenarios_colour)\n\n    return ax\n\n\nfig, ax = plt.subplots(figsize=(6, 4))\n\nstarch_vs_os_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/atpase_vs_starch.svg\")\nfig.savefig(\"../outputs/constraint_scan/atpase_vs_starch.png\")\n\n\n\n\n\nHow do starch levels vary with white/blue light?\n\nfig, ax = plt.subplots(figsize=(6, 4))\n\nblue_higher = 0\nwhite_higher = 0\nsame_starch = 0\n\nlen_light = int(len(scan_constraints)/2)\n\nfor i in range(len_light):\n    x = os_increase_per_gc[i]\n\n    y_white = starch_per_gc[i]\n    y_blue = starch_per_gc[i+len_light]\n\n    if y_blue > y_white:  # blue higher\n        colour = colours[0]\n        blue_higher += 1\n    elif y_blue < y_white:\n        colour = colours[1]\n        white_higher += 1\n    else:\n        same_starch += 1\n        colour = \"black\"\n\n    ax.arrow(x, y_white, 0, y_blue-y_white, color=colour, length_includes_head=True,\n             width=4, head_width=10, head_length=4, linewidth=0)\n\n\n\n\n\nprint(f\"Blue higher: {blue_higher}\")\nprint(f\"White higher: {white_higher}\")\nprint(f\"Same starch: {same_starch}\")\n\nBlue higher: 949\nWhite higher: 0\nSame starch: 23\n\n\n\nstarch_differences = ((scan_results[scan_constraints.light == \"blue\"].reset_index()) -\n                      (scan_results[scan_constraints.light == \"white\"].reset_index())).STARCH_p_gc_Linker_1\n\n\n(starch_differences > 0).sum()\n\n949\n\n\n\nscan_results[scan_constraints.light == \"blue\"].reset_index()[(starch_differences == 0)].STARCH_p_gc_Linker_1\n\n10     0.0\n38     0.0\n80     0.0\n104    0.0\n126    0.0\n128    0.0\n150    0.0\n231    0.0\n239    0.0\n280    0.0\n292    0.0\n313    0.0\n343    0.0\n374    0.0\n438    0.0\n453    0.0\n531    0.0\n612    0.0\n674    0.0\n853    0.0\n876    0.0\n905    0.0\n922    0.0\nName: STARCH_p_gc_Linker_1, dtype: float64\n\n\nStarch is only equal when it’s 0\n\nhigh_starch = scan_results[starch_per_gc > horrer_starch_level]\nprint(len(high_starch))\nprint(((scan_constraints.loc[high_starch.index, \"light\"]\n      == \"white\").sum()/(len(scan_results)/2)*100).round(0))\nprint(((scan_constraints.loc[high_starch.index, \"light\"]\n      == \"blue\").sum()/(len(scan_results)/2)*100).round(0))\n\n840\n43.0\n44.0\n\n\n\nselected_scenarios_max_starch = (\n    paper_results.loc[:, \"STARCH_p_gc_Linker_1\"]-paper_results.loc[:, \"STARCH_p_gc_Linker_2\"]).max()\nselected_scenarios_max_starch = selected_scenarios_max_starch * 10**-3 / paper_constraints.N_gcs * 10**15\n\n\nhigher_than_scenarios_starch = scan_results[starch_per_gc > selected_scenarios_max_starch]\nprint(len(higher_than_scenarios_starch))\nprint(((scan_constraints.loc[higher_than_scenarios_starch.index, \"light\"]\n      == \"white\").sum()/(len(scan_results)/2)*100).round(0))\nprint(((scan_constraints.loc[higher_than_scenarios_starch.index, \"light\"]\n      == \"blue\").sum()/(len(scan_results)/2)*100).round(0))\n\n1824\n93.0\n95.0"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#how-is-starch-used",
    "href": "3.3_analyse_constraint_scan.html#how-is-starch-used",
    "title": "Analysing the results of the constraint scan",
    "section": "How is starch used?",
    "text": "How is starch used?\nWhat proportion of white light solutions that degrade starch use it for osmoticum?\n\n(((scan_constraints[\"light\"] == \"white\") & (starch > 0) & (scan_results.RXN_2141_p_gc_2 > 0)).sum()) / \\\n    ((scan_constraints[\"light\"] == \"white\") & (starch > 0)).sum()*100\n\n100.0\n\n\nWhat proportion of white light solutions that degrade starch use it for energy?\n\n(((scan_constraints[\"light\"] == \"white\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0)\n  ).sum())/((scan_constraints[\"light\"] == \"white\") & (starch > 0)).sum()*100\n\n2.8662420382165608\n\n\nIn the solutions that use it for energy, what is the average % used for energy?\n\n(((scan_results[(((scan_constraints[\"light\"] == \"white\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0)))].MALTODEG_RXN_c_gc_2) /\n starch[((scan_constraints[\"light\"] == \"white\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0))]) * 100).mean()\n\n2.018286419537275\n\n\nWhat proportion of blue light solutions that degrade starch use it for osmoticum?\n\n(((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & (scan_results.RXN_2141_p_gc_2 > 0)).sum()) / \\\n    ((scan_constraints[\"light\"] == \"blue\") & (starch > 0)).sum()*100\n\n99.89462592202318\n\n\n\n((scan_constraints[\"light\"] == \"blue\") & (starch > 0)).sum() - \\\n    (((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & (scan_results.RXN_2141_p_gc_2 > 0)).sum())\n\n1\n\n\nOnly one solution doesn’t\n\nscan_constraints[((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & ~(scan_results.RXN_2141_p_gc_2 > 0))]\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      ...\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n      light\n    \n  \n  \n    \n      1685\n      0.821423\n      0.000237\n      1.0\n      3.854387e-12\n      0.790419\n      0.17526\n      0.229149\n      0.2216\n      0.899394\n      283.991986\n      ...\n      8.359438e+08\n      1.749547\n      0.84542\n      6.715197e-14\n      1.344834e-13\n      0.031261\n      2.529549\n      3.62111\n      15.767152\n      blue\n    \n  \n\n1 rows × 21 columns\n\n\n\n1685 is solution without constrained ATPase\nWhat proportion of blue light solutions that degrade starch use it for energy?\n\n(((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0)\n  ).sum())/((scan_constraints[\"light\"] == \"blue\") & (starch > 0)).sum()*100\n\n97.36564805057955\n\n\n\n((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & ~(scan_results.MALTODEG_RXN_c_gc_2 > 0)).sum()\n\n25\n\n\n25 solutions that use starch in blue light don’t use the energy pathway\n\n(((scan_results[((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0))].MALTODEG_RXN_c_gc_2) /\n starch[((scan_constraints[\"light\"] == \"blue\") & (starch > 0) & (scan_results.MALTODEG_RXN_c_gc_2 > 0))]) * 100).mean()\n\n4.619191722016749\n\n\nAverage of 5% of starch degraded was used for energy"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#d---how-does-glucose-increase-during-opening-vary-with-starch-and-why-isnt-it-totally-linear",
    "href": "3.3_analyse_constraint_scan.html#d---how-does-glucose-increase-during-opening-vary-with-starch-and-why-isnt-it-totally-linear",
    "title": "Analysing the results of the constraint scan",
    "section": "7d - How does glucose increase during opening vary with starch, and why isn’t it totally linear?",
    "text": "7d - How does glucose increase during opening vary with starch, and why isn’t it totally linear?\nIs sucrose degaded in the cytoplasm in any solutions?\n\n(scan_results[starch > 0][\"RXN_1461_c_gc_2\"] > 0).sum()\n\n0\n\n\nNo\n\nsucrose_degraded_v = scan_results[starch > 0][\"RXN_1461_v_gc_2\"] > 0.000001\nno_sucrose_degraded_v = scan_results[starch > 0][\"RXN_1461_v_gc_2\"] < 0.000001\nglucose_import_into_vacuole = scan_results[starch > 0][\"GLC_PROTON_rev_cv_gc_2\"] > 0.000001\nno_glucose_import_into_vacuole = scan_results[starch > 0][\"GLC_PROTON_rev_cv_gc_2\"] < 0.000001\n\n\nsucrose_deg_and_glc_import = (sucrose_degraded_v & glucose_import_into_vacuole)\nsucrose_deg_no_glc_import = (sucrose_degraded_v & no_glucose_import_into_vacuole)\nno_sucrose_deg_glc_import = (no_sucrose_degraded_v & glucose_import_into_vacuole)\nno_sucrose_deg_no_glc_import = (no_sucrose_degraded_v & no_glucose_import_into_vacuole)\n\n\nconditions = [sucrose_deg_and_glc_import, sucrose_deg_no_glc_import,\n              no_sucrose_deg_glc_import, no_sucrose_deg_no_glc_import]\nlabels = [\"+ S.d. + G.i.\", \"+ S.d - G.i.\", \"- S.d + G.i.\", \"- S.d - G.i.\"]\n\n\nfor condition, label in zip(conditions, labels):\n    print(f\"{label}:\")\n    print(f\"Length: {(condition).sum()} ({((condition).sum()/len(scan_constraints[starch > 0]) * 100).round(1)}%)\")\n    starch_proportion = ((scan_results[starch > 0][condition].STARCH_p_gc_Linker_1 /\n                         scan_gc_constraints.loc[starch > 0][condition].Os_dif)*100).median()\n    print(f\"Starch median % of osmolarity: {starch_proportion}\")\n    starch_proportion = ((scan_results[starch > 0][condition].STARCH_p_gc_Linker_1 /\n                         scan_gc_constraints.loc[starch > 0][condition].Os_dif)*100).mean()\n    print(f\"Starch mean % of osmolarity: {starch_proportion}\")\n    starch_proportion = ((scan_results[starch > 0][condition].STARCH_p_gc_Linker_1 /\n                         scan_gc_constraints.loc[starch > 0][condition].Os_dif)*100).max()\n    print(f\"Starch max % of osmolarity: {starch_proportion}\")\n    starch_proportion = ((scan_results[starch > 0][condition].STARCH_p_gc_Linker_1 /\n                         scan_gc_constraints.loc[starch > 0][condition].Os_dif)*100).min()\n    print(f\"Starch min % of osmolarity: {starch_proportion}\")\n\n+ S.d. + G.i.:\nLength: 962 (50.9%)\nStarch median % of osmolarity: 79.21003879220572\nStarch mean % of osmolarity: 78.82409377347064\nStarch max % of osmolarity: 100.92816549076942\nStarch min % of osmolarity: 43.44248513983288\n+ S.d - G.i.:\nLength: 3 (0.2%)\nStarch median % of osmolarity: 48.05105335942245\nStarch mean % of osmolarity: 49.40105341585774\nStarch max % of osmolarity: 52.31384439881553\nStarch min % of osmolarity: 47.838262489335236\n- S.d + G.i.:\nLength: 822 (43.5%)\nStarch median % of osmolarity: 85.04872218180918\nStarch mean % of osmolarity: 81.8724710052484\nStarch max % of osmolarity: 100.86764024051335\nStarch min % of osmolarity: 34.687666050849344\n- S.d - G.i.:\nLength: 104 (5.5%)\nStarch median % of osmolarity: 30.960905103662995\nStarch mean % of osmolarity: 31.84584462456143\nStarch max % of osmolarity: 84.97624241427523\nStarch min % of osmolarity: 0.3001445678386764\n\n\n\nglc_increase = (scan_results[starch > 0].GLC_total_pseudolinker_2 -\n                scan_results[starch > 0].GLC_total_pseudolinker_1)\nglc_increase_per_gc = glc_increase*10**-3/scan_constraints.N_gcs*10**15\n\n\ndef glucose_vs_starch_subfig(ax):\n\n    x = [0, 600]\n    y = [0, 600]\n\n    size = 10\n\n    ax.plot(x, y, c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    conditions = [sucrose_deg_and_glc_import, sucrose_deg_no_glc_import,\n                  no_sucrose_deg_glc_import, no_sucrose_deg_no_glc_import]\n    colours = [sns.color_palette()[2], sns.color_palette()[3], sns.color_palette()[4], sns.color_palette()[8]]\n    labels = [\"+ S.d. + G.i.\", \"+ S.d - G.i.\", \"- S.d + G.i.\", \"- S.d - G.i.\"]\n\n    glucose_increase_max = glc_increase_per_gc.max()\n\n    for condition, colour, label in zip(conditions, colours, labels):\n        ax.scatter(starch_per_gc[starch > 0][condition], glc_increase_per_gc[starch > 0][condition],\n                   color=colour, s=size, label=label, linewidths=0, clip_on=False)\n\n    ax.set_xlabel(\"Starch degradation\\n\" r\"(fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(\"Increase in glucose (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n\n    y_max = glucose_increase_max\n    x_max = 600\n    major_increment = 200\n    ax.set_ylim(None, y_max)\n    ax.set_xlim(None, x_max)\n    ax.spines['left'].set_bounds(0, y_max)\n    ax.spines['bottom'].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect('equal')\n\n    ax.vlines(184, ymin=0, ymax=570, linewidth=1, linestyle=\"--\", color=sns.color_palette()[6])\n    ax.text(184, 570, \"Horrer et al. (2016)\", ha=\"center\", va=\"bottom\", size=\"x-small\", color=sns.color_palette()[6])\n\n    ax.legend(loc=\"lower right\", bbox_to_anchor=(1, 0), handletextpad=0, fontsize=\"x-small\")\n\n    return ax\n\n\nfig, ax = plt.subplots()\n\nglucose_vs_starch_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.svg\")\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.png\", dpi=300)\n\n\n\n\n\ndef glucose_vs_starch_subfig(ax):\n\n    x = [0, 600]\n    y = [0, 600]\n\n    size = 10\n\n    ax.plot(x, y, c=\"grey\", alpha=0.5, clip_on=False, linewidth=1)\n\n    conditions = [sucrose_deg_and_glc_import,\n                  no_sucrose_deg_glc_import, no_sucrose_deg_no_glc_import, sucrose_deg_no_glc_import]\n    colours = [sns.color_palette()[2], sns.color_palette()[3], sns.color_palette()[4], sns.color_palette()[8]]\n    labels = [\"+ S.d. + G.i.\", \"- S.d + G.i.\", \"- S.d - G.i.\", \"+ S.d - G.i.\"]\n\n    glucose_increase_max = glc_increase_per_gc.max()\n\n    for condition, colour, label in zip(conditions, colours, labels):\n        ax.scatter(starch_per_gc[starch > 0][condition], glc_increase_per_gc[starch > 0][condition],\n                   color=colour, s=size, label=label, linewidths=0, clip_on=False)\n\n    ax.set_xlabel(\"Starch degradation\\n\" r\"(fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n    ax.set_ylabel(\"Increase in glucose (fmol$\\cdot$GC$^{-1}$)\", size=\"medium\")\n\n    y_max = glucose_increase_max\n    x_max = 600\n    major_increment = 200\n    ax.set_ylim(None, y_max)\n    ax.set_xlim(None, x_max)\n    ax.spines['left'].set_bounds(0, y_max)\n    ax.spines['bottom'].set_bounds(0, x_max)\n    ax.xaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.xaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.yaxis.set_major_locator(MultipleLocator(major_increment))\n    ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n    ax.set_aspect('equal')\n\n    ax.vlines(184, ymin=0, ymax=570, linewidth=1, linestyle=\"--\", color=sns.color_palette()[6])\n    ax.text(184, 570, \"Horrer et al. (2016)\", ha=\"center\", va=\"bottom\", size=\"x-small\", color=sns.color_palette()[6])\n\n    ax.legend(loc=\"lower right\", bbox_to_anchor=(1, 0), handletextpad=0, fontsize=\"x-small\")\n\n    return ax\n\n\nfig, ax = plt.subplots()\n\nglucose_vs_starch_subfig(ax)\n\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.svg\")\nfig.savefig(\"../outputs/constraint_scan/starch_vs_glucose.png\", dpi=300)"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#combine-subfigures",
    "href": "3.3_analyse_constraint_scan.html#combine-subfigures",
    "title": "Analysing the results of the constraint scan",
    "section": "Combine subfigures",
    "text": "Combine subfigures\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\nplt.subplots_adjust(hspace=0.5, wspace=0.35)\n\nphloemoutput_subfig(axs[0][0])\n\nphotons_vs_carbon_export_subfig(axs[0][1])\n\nstarch_vs_os_subfig(axs[1][0])\n\nglucose_vs_starch_subfig(axs[1][1])\naxs[1][1].get_legend().remove()\n\nfor ax, letter in zip([axs[0][0], axs[0][1], axs[1][0], axs[1][1]], [\"a\", \"b\", \"c\", \"d\"]):\n    ax.text(-0.1, 1.06, letter, transform=ax.transAxes,\n            size=20, weight='bold')\n\nfig.savefig(\"../outputs/constraint_scan/constraint_scan_analysis_plot.svg\", transparent=True)\nfig.savefig(\"../outputs/constraint_scan/constraint_scan_analysis_plot.png\", transparent=True)"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#extra-analyses-not-included",
    "href": "3.3_analyse_constraint_scan.html#extra-analyses-not-included",
    "title": "Analysing the results of the constraint scan",
    "section": "Extra analyses not included",
    "text": "Extra analyses not included\n\nWhat is the ratio of mitochondrial to plastidic ATP synthase?\n\nfig, axs = plt.subplots(1, 2, figsize=(10, 4))\n\naxs[0].hist(scan_results.Plastidial_ATP_Synthase_p_gc_2[scan_constraints.light == \"white\"] /\n            scan_results.Mitochondrial_ATP_Synthase_m_gc_2[scan_constraints.light == \"white\"], bins=100)\naxs[0].set_title(\"Opening in white light\")\naxs[0].set_xlabel(\"Plastidial ATP Synthase\\nMitochondrial ATP Synthase\")\naxs[1].hist(scan_results.Plastidial_ATP_Synthase_p_gc_3/scan_results.Mitochondrial_ATP_Synthase_m_gc_3, bins=100)\naxs[1].set_title(\"Day in both light types\")\naxs[1].set_xlabel(\"Plastidial ATP Synthase\\nMitochondrial ATP Synthase\")\n\nText(0.5, 0, 'Plastidial ATP Synthase\\nMitochondrial ATP Synthase')\n\n\n\n\n\n\nfig, ax = plt.subplots(1, figsize=(5, 4))\n\nplastidial_atp_max = scan_results.loc[:, [\n    \"Plastidial_ATP_Synthase_p_gc_3\", \"Plastidial_ATP_Synthase_p_gc_2\"]].max(axis=1)\nmitochondial_atp_max = scan_results.loc[:, [\n    \"Mitochondrial_ATP_Synthase_m_gc_3\", \"Mitochondrial_ATP_Synthase_m_gc_2\"]].max(axis=1)\n\nfor light in [\"blue\", \"white\"]:\n    ax.hist(plastidial_atp_max[scan_constraints.light == light] /\n            mitochondial_atp_max[scan_constraints.light == light], histtype=\"step\", label=light)\n\nax.set_xlabel(\"Max plastidial ATP Synthase\\nMax mitochondrial ATP Synthase\")\n\nax.legend()\n\n<matplotlib.legend.Legend>\n\n\n\n\n\n\nfig, ax = plt.subplots()\n\nax.plot([0, 0.3], [0, 0.3], c=\"grey\", zorder=0)\nax.scatter(plastidial_atp_max, mitochondial_atp_max, s=1)\n\n<matplotlib.collections.PathCollection>\n\n\n\n\n\n\n(plastidial_atp_max/mitochondial_atp_max).min()\n\n0.08544687640486812"
  },
  {
    "objectID": "3.3_analyse_constraint_scan.html#almost-all-starch-is-used-for-glucose-and-pep-carboxykinase-reaction-never-runs",
    "href": "3.3_analyse_constraint_scan.html#almost-all-starch-is-used-for-glucose-and-pep-carboxykinase-reaction-never-runs",
    "title": "Analysing the results of the constraint scan",
    "section": "Almost all starch is used for glucose, and PEP carboxykinase reaction never runs",
    "text": "Almost all starch is used for glucose, and PEP carboxykinase reaction never runs\n\n(scan_results.PEPCARBOX_RXN_c_gc_2 > 0).sum()\n\n0\n\n\n\n(scan_results.PEPDEPHOS_RXN_c_gc_2 > 0).sum()\n\n984\n\n\n\n((scan_results.MALTODEG_RXN_c_gc_2 > 0) & (scan_results.PEPDEPHOS_RXN_c_gc_2 > 0)).sum()\n\n951\n\n\n\n((scan_results.MALTODEG_RXN_c_gc_2 > 0) & (scan_results.PYRUVDEH_RXN_m_gc_2 > 0)).sum()\n\n951\n\n\n\n((scan_results.MALTODEG_RXN_c_gc_2 > 0) & (scan_results.ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2 > 0)).sum()\n\n951\n\n\n\n(scan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].MALTODEG_RXN_c_gc_2/2 -\n scan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].PEPDEPHOS_RXN_c_gc_2).hist(bins=100)\n\n<Axes: >\n\n\n\n\n\n\n(scan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].MALTODEG_RXN_c_gc_2/2 -\n scan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].PYRUVDEH_RXN_m_gc_2).hist(bins=100)\n\n<Axes: >\n\n\n\n\n\n\nscan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].MALTODEG_RXN_c_gc_2 - \\\n    scan_results[(scan_results.MALTODEG_RXN_c_gc_2 > 0)].ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2\n\n25      0.000994\n32      0.000602\n58      0.000030\n140     0.002853\n148     0.002621\n          ...   \n1939   -0.003483\n1940    0.003833\n1941   -0.001579\n1942   -0.000820\n1943   -0.003544\nLength: 951, dtype: float64\n\n\n\n(scan_results.MAL_total_pseudolinker_2 > 0).sum()\n\n78\n\n\n\nscan_constraints[((scan_results.MAL_total_pseudolinker_2 - scan_results.MAL_total_pseudolinker_1) > 0)]\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      ...\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n      light\n    \n  \n  \n    \n      1384\n      0.856283\n      0.000233\n      1.0\n      3.557774e-12\n      0.829166\n      0.09021\n      0.325547\n      0.178134\n      0.821274\n      290.830057\n      ...\n      2.209913e+08\n      2.157369\n      0.845391\n      7.202105e-14\n      1.351502e-13\n      0.031031\n      3.986023\n      10.771568\n      0.018741\n      blue\n    \n  \n\n1 rows × 21 columns\n\n\n\n\nstarch[1384]\n\n0.0774719542034296\n\n\n\n(scan_constraints.loc[1384]-scan_constraints.mean())/scan_constraints.std()\n\n/tmp/ipykernel_1954444/1907229730.py:1: FutureWarning: The default value of numeric_only in DataFrame.mean is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n  (scan_constraints.loc[1384]-scan_constraints.mean())/scan_constraints.std()\n/tmp/ipykernel_1954444/1907229730.py:1: FutureWarning: The default value of numeric_only in DataFrame.std is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n  (scan_constraints.loc[1384]-scan_constraints.mean())/scan_constraints.std()\n\n\nATPase        -1.727007\nA_closed       1.766129\nA_l                 NaN\nA_open         1.255356\nC_apo          0.225023\nFqFm          -0.498871\nL_air          0.896352\nL_epidermis    0.197816\nN_gcs         -1.572157\nP_abs         -0.835521\nR              0.999743\nR_ch          -0.440596\nT              0.043976\nT_l            1.367673\nV_gc_ind       1.214546\nVac_frac      -0.104569\nlight               NaN\nm             -0.946882\nn              0.543079\nr              0.814312\ns             -1.123443\ndtype: object\n\n\n\nscan_constraints.loc[1384].ATPase\n\n0.0187406648439282\n\n\n\nscan_constraints.mean().ATPase\n\n/tmp/ipykernel_1954444/856568451.py:1: FutureWarning: The default value of numeric_only in DataFrame.mean is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n  scan_constraints.mean().ATPase\n\n\n8.503141757759833\n\n\n\natpase_constrained[1384]\n\nTrue\n\n\n\nscan_results.loc[1384].MALTODEG_RXN_c_gc_2 / starch[1384] * 100\n\n6.022598590391629\n\n\n\nscan_results.loc[1384].RXN_2141_p_gc_2\n\n0.072806129381625\n\n\n\nscan_results.loc[1384].MALATE_DEH_RXN_m_gc_2\n\n0.0062190610980747\n\n\n\nscan_results.loc[1384].ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc_2\n\n0.0031105060888218\n\n\n\n(scan_gc_constraints.loc[1384]-scan_gc_constraints.mean())/scan_gc_constraints.std()\n\nV_closed    -1.252034\nV_open      -1.102307\nOs_closed   -0.921524\nOs_open     -0.706567\nPhotons     -0.761435\nATPase      -1.319215\nOs_dif      -0.551403\ndtype: float64"
  },
  {
    "objectID": "1.5_convert_horrer_starch_level.html",
    "href": "1.5_convert_horrer_starch_level.html",
    "title": "Starch amount estimation",
    "section": "",
    "text": "Here we use the values determined in Horrer et al. (2016) in order to determine an experimental value for the level of starch degradation we should expect to see in our model.\n\nimport pandas as pd\n\n\nstarchdf = pd.DataFrame([[\"End of night\", 41.92813034], [\"1h Light\", 12.10368844]],\n                        columns=[\"Time of day\", \"Starch content per guard cell (pg)\"])\nstarchdf = starchdf.set_index(\"Time of day\")\nstarchdf\n\n\n\n\n\n  \n    \n      \n      Starch content per guard cell (pg)\n    \n    \n      Time of day\n      \n    \n  \n  \n    \n      End of night\n      41.928130\n    \n    \n      1h Light\n      12.103688\n    \n  \n\n\n\n\nThis table is found in the supplementary files of Horrer (2016). We can calculate glucose equivalents from starch by dividing by 162 g/mol, as Horrer et al did:\n\nstarchdf[\"Glucose equivalents (pmol)\"] = starchdf[\"Starch content per guard cell (pg)\"]/162\nstarchdf\n\n\n\n\n\n  \n    \n      \n      Starch content per guard cell (pg)\n      Glucose equivalents (pmol)\n    \n    \n      Time of day\n      \n      \n    \n  \n  \n    \n      End of night\n      41.928130\n      0.258816\n    \n    \n      1h Light\n      12.103688\n      0.074714\n    \n  \n\n\n\n\nIn our model we use the glucose equivalents as a measure of starch.\nWe use a value of \\(580 \\times 10^6\\) for the number of guard cells in our model, and therefore we can calculate the expected amount of starch in the model at the two times, and the expected amount of degradation.\n\nN_gc = 290 * 10 ** 6 * 2  # number of stomata/m^2 *2 gives number of guard cells\nstarchdf[\"Starch amount (mmole/m2)\"] = starchdf[\"Glucose equivalents (pmol)\"]*N_gc*10**-9  # 10**-9 to convert to mmol\nstarchdf\n\n\n\n\n\n  \n    \n      \n      Starch content per guard cell (pg)\n      Glucose equivalents (pmol)\n      Starch amount (mmole/m2)\n    \n    \n      Time of day\n      \n      \n      \n    \n  \n  \n    \n      End of night\n      41.928130\n      0.258816\n      0.150113\n    \n    \n      1h Light\n      12.103688\n      0.074714\n      0.043334\n    \n  \n\n\n\n\n\nprint(\"Expected starch degradation amount is therefore %s fmoles/GC\" %\n      round((starchdf.at[\"End of night\", \"Glucose equivalents (pmol)\"]-starchdf.at[\"1h Light\", \"Glucose equivalents (pmol)\"])*1000, 3))\n\nExpected starch degradation amount is therefore 184.101 fmoles/GC\n\n\n\nprint(\"Expected starch degradation amount is therefore %s mmoles/m2\" %\n      round((starchdf.at[\"End of night\", \"Starch amount (mmole/m2)\"]-starchdf.at[\"1h Light\", \"Starch amount (mmole/m2)\"]), 3))\n\nExpected starch degradation amount is therefore 0.107 mmoles/m2"
  },
  {
    "objectID": "2.3_flux_map_values.html",
    "href": "2.3_flux_map_values.html",
    "title": "Calculating line widths for flux maps",
    "section": "",
    "text": "For this, rather than taking values from solutions the values are inputted manually from the escher maps. It would be better from the solution dfs but I don’t fancy coding this at the moment…\nSo we have a 50-fold difference between the smallest and largest flux. 5mm in the inkscape figures that I’ve created is probably the max I can do, so 0.1 is the minimum.\nInkscape will only do widths to nearest 0.01mm I think, but allows you to input 3 numbers after the dp."
  },
  {
    "objectID": "2.3_flux_map_values.html#for-the-key",
    "href": "2.3_flux_map_values.html#for-the-key",
    "title": "Calculating line widths for flux maps",
    "section": "For the key:",
    "text": "For the key:\n\nimport cobra\nimport pandas as pd\nfrom mmon_gcm.supermodel import SuperModel\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\"../models/4_stage_GC.xml\")  # read model\narabidopsis_supermodel = SuperModel(parameters_df.loc[:, \"Value\"], fba_model=four_stage_GC_model);\n\nNo objective coefficients in model. Unclear what should be optimized\n/home/nls119/src/mmon-gcm2/mmon_gcm/supermodel.py:25: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for parameter, value in parameters.iteritems():\n\n\n\narabidopsis_supermodel.N_gcs\n\n580000000.0\n\n\n\n0.01/arabidopsis_supermodel.N_gcs\n\n1.724137931034483e-11\n\n\n\nmoles_gc_h = 10 * 10 ** -15  # fmolesgc-1h-1\n\n\nmoles_m2_h = moles_gc_h*arabidopsis_supermodel.N_gcs  # molesh-1\n\n\nmmoles_m2_h = moles_m2_h * 10 ** 3\nmmoles_m2_h\n\n0.005800000000000001\n\n\n\nf\"{convert_fluxes_to_widths_linear(mmoles_m2_h)}mm for a flux of 10 fmoles gc-1 h-1\"\n\n'2.05mm for a flux of 10 fmoles gc-1 h-1'"
  },
  {
    "objectID": "4.2_run_alternative_flux_modes.html",
    "href": "4.2_run_alternative_flux_modes.html",
    "title": "Run alternative flux modes simulations",
    "section": "",
    "text": "As with runconstraintscan.py, this notebook can either be run as a notebook, or using nbdev a python script is produced that can be run in the command line for easier running on e.g. a cluster. It is a notebook in the nbs directory that is symlinked in the nbs/functions directory in order to be exported as a .py file in the mmon-gcm library.\nNOTE: I have had issues where for an unknown reason the code hangs while solving. In this case I can check the temporary files to see which solutions are missing and run it again to just get those. For the paper, the blue light, unconstrained, KO solution number 348 hangs with a tolerance of 1e-8 and says infeasible for a tolerance of 1e-7. So the solution list is constructed from combining the remaining temporary files rather than all in one go."
  },
  {
    "objectID": "4.2_run_alternative_flux_modes.html#constrain-light-atpase-starch",
    "href": "4.2_run_alternative_flux_modes.html#constrain-light-atpase-starch",
    "title": "Run alternative flux modes simulations",
    "section": "Constrain light, ATPase, starch",
    "text": "Constrain light, ATPase, starch\nIf you are running from notebook you’ll want to comment out the next cell! It’s here so that running nbdev tests doesn’t take too long, as they test running the entire notebook. It won’t be exported so running as a script will be fine\n\nweightings = weightings.iloc[0:4]  # so tests don't take too long\nweightings.head()\n\n\n\n\n\n  \n    \n      \n      10_FORMYL_THF_pc_gc_1\n      10_FORMYL_THF_pc_gc_2\n      10_FORMYL_THF_pc_gc_3\n      10_FORMYL_THF_pc_gc_4\n      10_FORMYL_THF_pc_me_1\n      10_FORMYL_THF_pc_me_2\n      10_FORMYL_THF_pc_me_3\n      10_FORMYL_THF_pc_me_4\n      1TRANSKETO_RXN_p_gc_1\n      1TRANSKETO_RXN_p_gc_2\n      ...\n      sSUC_biomass_me_3\n      sSUC_biomass_me_4\n      unlProtHYPO_c_gc_1\n      unlProtHYPO_c_gc_2\n      unlProtHYPO_c_gc_3\n      unlProtHYPO_c_gc_4\n      unlProtHYPO_c_me_1\n      unlProtHYPO_c_me_2\n      unlProtHYPO_c_me_3\n      unlProtHYPO_c_me_4\n    \n  \n  \n    \n      0\n      3.196322\n      0.266360\n      6.126284\n      3.196322\n      2.003810\n      0.166984\n      3.840636\n      2.003810\n      4.628290\n      0.385691\n      ...\n      3.685919\n      1.923088\n      3.013075\n      0.251090\n      5.775060\n      3.013075\n      4.919640\n      0.409970\n      9.429310\n      4.919640\n    \n    \n      1\n      2.976393\n      0.248033\n      5.704753\n      2.976393\n      0.059372\n      0.004948\n      0.113797\n      0.059372\n      3.306903\n      0.275575\n      ...\n      11.088275\n      5.785187\n      4.092069\n      0.341006\n      7.843133\n      4.092069\n      0.268098\n      0.022342\n      0.513855\n      0.268098\n    \n    \n      2\n      3.812475\n      0.317706\n      7.307244\n      3.812475\n      3.160252\n      0.263354\n      6.057151\n      3.160252\n      1.036738\n      0.086395\n      ...\n      5.557520\n      2.899576\n      3.424889\n      0.285407\n      6.564371\n      3.424889\n      1.629429\n      0.135786\n      3.123073\n      1.629429\n    \n    \n      3\n      0.186226\n      0.015519\n      0.356934\n      0.186226\n      1.913905\n      0.159492\n      3.668317\n      1.913905\n      4.470282\n      0.372524\n      ...\n      2.648911\n      1.382040\n      4.475259\n      0.372938\n      8.577580\n      4.475259\n      0.418057\n      0.034838\n      0.801276\n      0.418057\n    \n  \n\n4 rows × 7093 columns"
  },
  {
    "objectID": "1.0_generating_linkers.html",
    "href": "1.0_generating_linkers.html",
    "title": "Generating table for linkers/osmolytes",
    "section": "",
    "text": "This notebook describes the steps to generate the"
  },
  {
    "objectID": "1.0_generating_linkers.html#add-the-amino-acids-as-linker-reactions-in-the-vacuole-of-both-the-guard-cell-and-mesophyll-cell.-they-have-an-osmotic-effect-in-the-guard-cell-but-not-the-mesophyll",
    "href": "1.0_generating_linkers.html#add-the-amino-acids-as-linker-reactions-in-the-vacuole-of-both-the-guard-cell-and-mesophyll-cell.-they-have-an-osmotic-effect-in-the-guard-cell-but-not-the-mesophyll",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add the amino acids as linker reactions in the vacuole of both the guard cell and mesophyll cell. They have an osmotic effect in the guard cell but not the mesophyll",
    "text": "Add the amino acids as linker reactions in the vacuole of both the guard cell and mesophyll cell. They have an osmotic effect in the guard cell but not the mesophyll\n\namino_acid_list = [\n    '4_AMINO_BUTYRATE',\n    'LEU',\n    'GLY',\n    'VAL',\n    'L_ALPHA_ALANINE',\n    'ASN',\n    'MET',\n    'LYS',\n    'THR',\n    'ILE',\n    'SER',\n    'GLT',\n    'TRP',\n    'GLN',\n    'TYR',\n    'L_ASPARTATE',\n    'PRO',\n    'PHE',\n    'HIS',\n    'bHIS',\n    'CYS',\n    'ARG',\n]\n\nfor cell, osmolarity in zip([\"me\", \"gc\"], [0, 1]):\n    for amino_acid in amino_acid_list:\n        linkers_dict[f\"{amino_acid}_v_{cell}\"] = osmolarity"
  },
  {
    "objectID": "1.0_generating_linkers.html#use-vacuolar-linkers-from-previous-diel-paper-for-mesophyll-non-osmotic-linkers",
    "href": "1.0_generating_linkers.html#use-vacuolar-linkers-from-previous-diel-paper-for-mesophyll-non-osmotic-linkers",
    "title": "Generating table for linkers/osmolytes",
    "section": "Use vacuolar linkers from previous diel paper for mesophyll non-osmotic linkers",
    "text": "Use vacuolar linkers from previous diel paper for mesophyll non-osmotic linkers\n\nme_linkers = [\n    \"MAL\",\n    \"aMAL\",\n    \"SUCROSE\",\n    \"CIT\",\n    \"aCIT\",\n]\n\nfor me_linker in me_linkers:\n    linkers_dict[f\"{me_linker}_v_me\"] = 0"
  },
  {
    "objectID": "1.0_generating_linkers.html#add-non-osmotic-apoplastic-linkers-based-on-what-has-been-found-to-be-present-in-the-apoplast-of-guard-cells",
    "href": "1.0_generating_linkers.html#add-non-osmotic-apoplastic-linkers-based-on-what-has-been-found-to-be-present-in-the-apoplast-of-guard-cells",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add non-osmotic apoplastic linkers based on what has been found to be present in the apoplast of guard cells",
    "text": "Add non-osmotic apoplastic linkers based on what has been found to be present in the apoplast of guard cells\n\na_linkers = [\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n    'aMAL',\n]\n\nfor a_linker in a_linkers:\n    linkers_dict[f\"{a_linker}_a\"] = 0"
  },
  {
    "objectID": "1.0_generating_linkers.html#add-osmotic-linkers-to-cytoplasm-and-vacuole-of-gc-based-on-what-has-been-hypothesised-to-accumulate",
    "href": "1.0_generating_linkers.html#add-osmotic-linkers-to-cytoplasm-and-vacuole-of-gc-based-on-what-has-been-hypothesised-to-accumulate",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add osmotic linkers to cytoplasm and vacuole of GC based on what has been hypothesised to accumulate",
    "text": "Add osmotic linkers to cytoplasm and vacuole of GC based on what has been hypothesised to accumulate\n\ngc_c_linkers = [\n    'CIT',\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n]\n\nfor gc_c_linker in gc_c_linkers:\n    linkers_dict[f\"{gc_c_linker}_c_gc\"] = 1\n\n\ngc_v_linkers = [\n    'CIT',\n    'Cl',\n    'FRU',\n    'GLC',\n    'K',\n    'MAL',\n    'NITRATE',\n    'SUCROSE',\n    'aCIT',\n    'aMAL',\n]\n\nfor gc_v_linker in gc_v_linkers:\n    linkers_dict[f\"{gc_v_linker}_v_gc\"] = 1"
  },
  {
    "objectID": "1.0_generating_linkers.html#add-starch-as-a-non-osmotic-linker-reaction-in-both-the-gc-and-me-plastid",
    "href": "1.0_generating_linkers.html#add-starch-as-a-non-osmotic-linker-reaction-in-both-the-gc-and-me-plastid",
    "title": "Generating table for linkers/osmolytes",
    "section": "Add starch as a non-osmotic linker reaction in both the gc and me plastid",
    "text": "Add starch as a non-osmotic linker reaction in both the gc and me plastid\n\nlinkers_dict[f\"STARCH_p_gc\"] = 0\nlinkers_dict[\"STARCH_p_me\"] = 0"
  },
  {
    "objectID": "1.0_generating_linkers.html#save-as-.csv-file",
    "href": "1.0_generating_linkers.html#save-as-.csv-file",
    "title": "Generating table for linkers/osmolytes",
    "section": "Save as .csv file",
    "text": "Save as .csv file\n\nosmolytes_df = pd.DataFrame.from_dict(linkers_dict, orient=\"Index\", columns=[\"Osmotic Coefficient\"])\nosmolytes_df.index.name = \"Linker\"\nosmolytes_df.to_csv(\"../inputs/osmolytes.csv\")"
  },
  {
    "objectID": "1.0_generating_linkers.html#generate-a-prettier-df-for-investigating-here-if-wanted",
    "href": "1.0_generating_linkers.html#generate-a-prettier-df-for-investigating-here-if-wanted",
    "title": "Generating table for linkers/osmolytes",
    "section": "Generate a prettier DF for investigating here if wanted",
    "text": "Generate a prettier DF for investigating here if wanted\n\ndef get_compartment_cell(linker):\n\n    split_name = linker.split(\"_\")\n    cell = split_name[-1]\n    if cell != \"a\":\n        compartment = split_name[-2]\n        metabolite = split_name[:-2]\n    else:\n        compartment = \"NA\"\n        metabolite = split_name[:-1]\n\n    if type(metabolite) == list:\n        metabolite = \"_\".join(metabolite)\n\n    return metabolite, compartment, cell\n\n\nosmolytes_df_prettyindex = pd.MultiIndex.from_tuples([get_compartment_cell(i) for i in osmolytes_df.index], names=[\n                                                     \"Metabolite\", \"Compartment\", \"Cell\"])\nosmolytes_df.index = osmolytes_df_prettyindex\nosmolytes_df = osmolytes_df.sort_index()\nosmolytes_df\n\n\n\n\n\n  \n    \n      \n      \n      \n      Osmotic Coefficient\n    \n    \n      Metabolite\n      Compartment\n      Cell\n      \n    \n  \n  \n    \n      4_AMINO_BUTYRATE\n      v\n      gc\n      1\n    \n    \n      me\n      0\n    \n    \n      ARG\n      v\n      gc\n      1\n    \n    \n      me\n      0\n    \n    \n      ASN\n      v\n      gc\n      1\n    \n    \n      ...\n      ...\n      ...\n      ...\n    \n    \n      aMAL\n      NA\n      a\n      0\n    \n    \n      v\n      gc\n      1\n    \n    \n      me\n      0\n    \n    \n      bHIS\n      v\n      gc\n      1\n    \n    \n      me\n      0\n    \n  \n\n77 rows × 1 columns\n\n\n\n\ndef return_list_of_items(groupobject):\n    return \", \".join(list(groupobject.values.astype(\"str\")))\n\n\nlinkers_met_dict = {\n    \"SUCROSE\": \"Sucrose\",\n    \"GLC\": \"Glucose\",\n    \"FRU\": \"Fructose\",\n    \"MAL\": \"Malate\",\n    \"CIT\": \"Citrate\",\n    \"Cl\": \"Cl\",\n    \"K\": \"K\",\n    \"NITRATE\": \"Nitrate\",\n    \"aMAL\": \"aMalate\",\n    \"STARCH\": \"Starch\",\n    \"aCIT\": \"aCitrate\",\n    \"bHIS\": \"bHis\",\n}\n\nosmolytes_tidy = osmolytes_df.reset_index().set_index([\"Osmotic Coefficient\", \"Cell\", \"Compartment\"]).sort_index()\n\nleftovers = set(osmolytes_tidy.Metabolite) - set(linkers_met_dict.keys())\n\nfor l in leftovers:\n    linkers_met_dict[l] = l.capitalize()\n\nosmolytes_tidy.Metabolite = osmolytes_tidy.Metabolite.map(lambda x: linkers_met_dict[x])\nosmolytes_tidy = osmolytes_tidy.groupby([\"Osmotic Coefficient\", \"Cell\", \"Compartment\"]).agg(return_list_of_items)\nosmolytes_tidy.to_csv(\"../plant_cell_paper/supplemental_table_1.csv\")\nosmolytes_tidy\n\n\n\n\n\n  \n    \n      \n      \n      \n      Metabolite\n    \n    \n      Osmotic Coefficient\n      Cell\n      Compartment\n      \n    \n  \n  \n    \n      0\n      a\n      NA\n      Cl, Fructose, Glucose, K, Malate, Nitrate, Suc...\n    \n    \n      gc\n      p\n      Starch\n    \n    \n      me\n      p\n      Starch\n    \n    \n      v\n      4_amino_butyrate, Arg, Asn, Citrate, Cys, Gln,...\n    \n    \n      1\n      gc\n      c\n      Citrate, Cl, Fructose, Glucose, K, Malate, Nit...\n    \n    \n      v\n      4_amino_butyrate, Arg, Asn, Citrate, Cys, Cl, ..."
  },
  {
    "objectID": "2.1_solvingmodel.html",
    "href": "2.1_solvingmodel.html",
    "title": "Solving guard cell models for different parameters",
    "section": "",
    "text": "# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is where to adjust whether fva is run if running in notebook\nargs = {\n    \"run_fva\": \"True\",\n    \"no_processes\": 3,\n    \"output_dir\": \"../outputs/model_solutions/\",\n    \"model_file\": \"../models/4_stage_GC.xml\",\n    \"map_file\": \"../inputs/map.json\",\n    \"parameters_file\": \"../inputs/arabidopsis_parameters.csv\",\n\n}\n\nsys.argv = [\"script_name\"] + list(args.values())"
  },
  {
    "objectID": "2.1_solvingmodel.html#instantiate-and-apply-base-constraints-to-model",
    "href": "2.1_solvingmodel.html#instantiate-and-apply-base-constraints-to-model",
    "title": "Solving guard cell models for different parameters",
    "section": "Instantiate and apply base constraints to model",
    "text": "Instantiate and apply base constraints to model\n\nImport FBA model\nDecrease tolerance\n\n\nDefine reactions to use for FVA\n\n\nInstantiate Supermodel\nImport parameters from csv, created in parameters notebook\nThis is a little different to Jezek and Blatt (2017), where they have closed as 0.3-0.4pL and open as 0.5-0.65. Open apertures are on the small side but still within their range (2-6). Wang used a volume of 0.4pL.\n\n\nConstrain SuperModel\n\nConstrain osmolarity of the model using the equation from the OnGuard model (Hills et al 2012)\n\nimport numpy as np\n\n\nnp.array(arabidopsis_supermodel.get_osmolarities())\n\narray([0.03935933, 0.05492236, 0.03935933, 0.03935933])\n\n\n\nhelp(arabidopsis_supermodel.get_osmolarities)\n\nHelp on method get_osmolarities in module mmon_gcm.supermodel:\n\nget_osmolarities(apertures='default', equation='onguard', printouts=False) method of mmon_gcm.supermodel.SuperModel instance\n    Calculates the osmolarities at each phase of the model using the equation\n    specified, default is onguard. Adds these as an attribute to the SuperModel\n\n\n\n\nmmoles_per_m2 = np.array(arabidopsis_supermodel.get_osmolarities())\nmmoles_per_gc = mmoles_per_m2 / arabidopsis_supermodel.N_gcs\nmoles_per_gc = mmoles_per_gc * 10 ** -3\nfmoles_per_gc = moles_per_gc / 10 ** -15\nprint(f\"Closed fmoles: {fmoles_per_gc[0]}\")\nprint(f\"Open fmoles: {fmoles_per_gc[1]}\")\nprint(f\"Increase in fmoles: {fmoles_per_gc[1] - fmoles_per_gc[0]}\")\n\nClosed fmoles: 67.86090968309483\nOpen fmoles: 94.69373119804636\nIncrease in fmoles: 26.832821514951533\n\n\n\n\nConstrain photons using a PPFD of 150µmolm\\(^{-2}\\)s\\(^{-1}\\), same as used in Horrer et al (2016)"
  },
  {
    "objectID": "2.1_solvingmodel.html#blue-light",
    "href": "2.1_solvingmodel.html#blue-light",
    "title": "Solving guard cell models for different parameters",
    "section": "Blue Light",
    "text": "Blue Light\n\nATPase unconstrained\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO"
  },
  {
    "objectID": "2.1_solvingmodel.html#white-light",
    "href": "2.1_solvingmodel.html#white-light",
    "title": "Solving guard cell models for different parameters",
    "section": "White Light",
    "text": "White Light\n\nUnconstrained ATPase\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO"
  },
  {
    "objectID": "2.1_solvingmodel.html#guard-cell-has-no-photosynthetic-capacity",
    "href": "2.1_solvingmodel.html#guard-cell-has-no-photosynthetic-capacity",
    "title": "Solving guard cell models for different parameters",
    "section": "Guard cell has no photosynthetic capacity",
    "text": "Guard cell has no photosynthetic capacity\n\nUnconstrained ATPase\n\nWT\n\n\nStarch KO\n\n\n\nConstrained ATPase\n\nWT\n\n\nStarch KO"
  },
  {
    "objectID": "2.2_analysingsolutions.html",
    "href": "2.2_analysingsolutions.html",
    "title": "Analysing solutions",
    "section": "",
    "text": "import itertools\nimport os\nimport re\nimport string\nimport xml.etree.ElementTree as ET\n\nimport cobra\nimport matplotlib as mpl\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom IPython.display import SVG\nfrom matplotlib.ticker import MultipleLocator\nfrom mmon_gcm.analysing import get_escher_map\nfrom mmon_gcm.supermodel import SuperModel\n\n\nsns.set_theme()\nsns.set_style(\"ticks\")\nsns.set_palette(\n    sns.color_palette(\n        [\n            \"#332288\",\n            \"#88CCEE\",\n            \"#44AA99\",\n            \"#117733\",\n            \"#999933\",\n            \"#DDCC77\",\n            \"#CC6677\",\n            \"#882255\",\n            \"#AA4499\",\n        ]\n    )\n)\ncolours = sns.color_palette()\n\nparams = {\n    \"xtick.labelsize\": \"large\",\n    \"ytick.labelsize\": \"large\",\n    \"axes.labelsize\": \"large\",\n    \"axes.titlesize\": \"x-large\",\n    \"axes.labelweight\": \"bold\",\n    \"axes.titleweight\": \"bold\",\n    \"font.weight\": \"bold\",\n    \"axes.spines.right\": False,\n    \"axes.spines.top\": False,\n    \"legend.frameon\": False,\n}\nplt.rcParams.update(params)\n\n\ndef get_multiphase_fluxes(df, reaction):\n    reaction_phased = [f\"{reaction}_{i+1}\" for i in range(4)]\n    selected_df = df.loc[reaction_phased, \"fluxes\"]\n    return selected_df\n\n\ndef convert_phases_to_times(df, phase_times=[6, 6.5, 18, 24]):\n\n    df.index = pd.MultiIndex.from_tuples(\n        [(row[0], phase_times[row[1] - 1]) for row in df.index], names=df.index.names\n    )\n    df = df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n    df = df.append(pd.concat([df.loc[24]], keys=[0]))\n    df = df.sort_index()\n    df = df.reorder_levels([\"Reaction\", \"Phase\"]).sort_index()\n\n    return df\n\n\ndef select_volume_based_on_id(reaction_id, SuperModel):\n\n    total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n\n    if \"total\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(per_guard_cell=False)\n    elif \"v_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = (\n            SuperModel.get_volumes(per_guard_cell=False) * SuperModel.Vac_frac\n        )\n    elif \"c_gc\" in reaction_id:\n        phase_volumes = total_gc_volume = SuperModel.get_volumes(\n            per_guard_cell=False\n        ) * (1 - SuperModel.Vac_frac)\n    elif \"p_gc\" in reaction_id:\n        phase_volumes = [1] * 4\n    else:\n        raise ValueError(f\"Don't know how to deal with {reaction_id}\")\n\n    return phase_volumes\n\n\ndef convert_to_conc(row, SuperModel, phases_in_df=[0, 6, 6.5, 18, 24]):\n\n    phase = row.name[1]\n\n    phase_conversion_dict = {\n        phases_in_df[0]: 4,\n        phases_in_df[1]: 1,\n        phases_in_df[2]: 2,\n        phases_in_df[3]: 3,\n        phases_in_df[4]: 4,\n    }\n\n    phase_volumes = select_volume_based_on_id(row.name[0], SuperModel)\n\n    volume_for_phase = phase_volumes[phase_conversion_dict[phase] - 1]\n\n    return row / volume_for_phase\n\n\ndef get_metabolite_df(\n    solutions_df, concentrations=True, total_mets=None, SuperModel=None\n):\n\n    if total_mets == None:\n        total_mets = [\"SUCROSE\", \"GLC\", \"MAL\", \"FRU\", \"K\", \"Cl\", \"CIT\"]\n    total_mets_reactions = [met + \"_total_pseudolinker\" for met in total_mets] + [\n        \"STARCH_p_gc_Linker\"\n    ]\n    total_mets_reactions_phased = [\n        f\"{reaction}_{i+1}\" for i in range(4) for reaction in total_mets_reactions\n    ]\n    met_df = (solutions_df.loc[total_mets_reactions]).copy()\n\n    # change index to phase times instead of tags\n    met_df = convert_phases_to_times(met_df)\n\n    if concentrations == True:\n        met_df = met_df.apply(convert_to_conc, args=([SuperModel]), axis=1)\n\n    met_df = met_df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n\n    met_df.index = pd.MultiIndex.from_tuples(\n        [(index[0], index[1].split(\"_\")[0]) for index in met_df.index],\n        names=met_df.index.names,\n    )\n\n    return met_df\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[\n            ~(met_df_mm.index == (6, \"STARCH\"))\n        ].loc[6, (light, atpase, genotype, \"fluxes\")]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[\n            ~(met_df_mm.index == (6.5, \"STARCH\"))\n        ].loc[6.5, (light, atpase, genotype, \"fluxes\")]\n\n    return open_closed_dict\n\n\ndef get_closed_open_values(met_df_mm, light, atpase):\n\n    open_closed_dict = {}\n\n    for genotype in [\"wt\", \"starchko\"]:\n        open_closed_dict[genotype] = {}\n        open_closed_dict[genotype][\"closed\"] = met_df_mm.loc[\n            6, (light, atpase, genotype, \"fluxes\")\n        ]\n        open_closed_dict[genotype][\"open\"] = met_df_mm.loc[\n            6.5, (light, atpase, genotype, \"fluxes\")\n        ]\n\n    return open_closed_dict\n\n\ndef get_totals_plot(specific_met_df):\n\n    colours = [\"#999999ff\", \"#ff7043ff\"]\n    mpl.rcParams[\"hatch.linewidth\"] = 1.5\n    fig, axs = plt.subplots(1, 2, figsize=(10, 4), gridspec_kw={\"width_ratios\": [7, 1]})\n\n    closed_metabolite_df = specific_met_df.loc[6.0].drop(\"STARCH\")\n    open_metabolite_df = specific_met_df.loc[6.5].drop(\"STARCH\")\n\n    # plot wt\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 - 0.05,\n        closed_metabolite_df[\"wt\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(open_metabolite_df))) * 2 + 0.05,\n        open_metabolite_df[\"wt\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=colours[0],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=colours[1],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=\"white\",\n        hatch=\"//\",\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 - 0.05,\n        closed_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n    )\n    axs[0].bar(\n        np.array(range(len(closed_metabolite_df))) * 2 + 1 + 0.05,\n        open_metabolite_df[\"starchko\"],\n        color=\"none\",\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n    )\n\n    x_ticks_pad = 12\n    axs[0].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n    axs[1].tick_params(axis=\"x\", which=\"both\", bottom=False, pad=x_ticks_pad)\n\n    starch_closed = specific_met_df.loc[(6.0, \"STARCH\")]\n    starch_open = specific_met_df.loc[(6.5, \"STARCH\")]\n\n    axs[1].bar(\n        -0.05,\n        starch_closed[\"wt\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n    )\n    axs[1].bar(\n        0.05,\n        starch_open[\"wt\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n    )\n\n    axs[1].bar(\n        1 - 0.05,\n        starch_closed[\"starchko\"],\n        width=-0.3,\n        align=\"edge\",\n        edgecolor=colours[0],\n        color=colours[0],\n        hatch=\"//\",\n    )\n    axs[1].bar(\n        1 + 0.05,\n        starch_open[\"starchko\"],\n        width=0.3,\n        align=\"edge\",\n        edgecolor=colours[1],\n        color=colours[1],\n        hatch=\"//\",\n    )\n\n    main_x_tick_labels = [\n        name[0] + name[1:3].lower() for name in open_metabolite_df.index\n    ]\n\n    main_x_tick_labels_superscripted = []\n    for label in main_x_tick_labels:\n        if label == \"K\":\n            new_label = r\"K$^+$\"\n        elif label == \"Cl\":\n            new_label = r\"Cl$^-$\"\n        else:\n            new_label = label\n        main_x_tick_labels_superscripted.append(new_label)\n\n    main_x_tick_labels = main_x_tick_labels_superscripted\n\n    main_x_ticks = np.array(range(len(closed_metabolite_df))) * 2 + 0.5\n\n    ax0_y_max = 60\n\n    axs[0].set_xticks(main_x_ticks)\n    axs[0].set_xticklabels(main_x_tick_labels)\n    axs[0].set_ylim(-0.1, ax0_y_max)\n    axs[0].set_xlim(-0.5, 13.5)\n    axs[0].set_ylabel(r\"Osmolyte concentration (mM)\")\n    axs[0].yaxis.set_major_locator(MultipleLocator(10))\n    # axs[0].yaxis.set_minor_locator(AutoMinorLocator(2))\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in range(len(closed_metabolite_df))]:\n        axs[0].hlines(\n            -3.7, x_loc + 0.1, x_loc + 1.9, clip_on=False, color=\"black\", alpha=0.9\n        )\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[0].text(\n                x_loc + offset, -2, label, ha=\"center\", va=\"center\", size=\"small\"\n            )\n\n    starch_x_tick_labels = [\"Starch\"]\n    starch_x_ticks = [0.5]\n\n    ax1_y_max = 14\n\n    axs[1].set_xticks(starch_x_ticks)\n    axs[1].set_xticklabels(starch_x_tick_labels)\n    axs[1].set_ylim(-0.1 * ax1_y_max / ax0_y_max, ax1_y_max)\n    axs[1].yaxis.set_label_position(\"right\")\n    axs[1].yaxis.tick_right()\n    axs[1].yaxis.set_major_locator(MultipleLocator(2))\n    # axs[1].yaxis.set_minor_locator(AutoMinorLocator(2))\n    axs[1].spines[\"right\"].set_visible(True)\n    axs[1].spines[\"left\"].set_visible(False)\n    axs[1].set_ylabel(r\"Amount (fmol$\\cdot$GC$^{-1}$)\")\n\n    for x_loc in [(x - 1) * 2 + 1.5 for x in [0]]:\n        axs[1].hlines(\n            -3.7 * ax1_y_max / ax0_y_max,\n            x_loc + 0.1,\n            x_loc + 2,\n            clip_on=False,\n            color=\"black\",\n            alpha=0.9,\n        )\n        for offset, label in zip([0.5, 1.5], [\"WT\", \"KO\"]):\n            axs[1].text(\n                x_loc + offset,\n                -2 * ax1_y_max / ax0_y_max,\n                label,\n                ha=\"center\",\n                va=\"center\",\n                size=\"small\",\n            )\n\n    colors = {\"EoN\": \"#999999ff\", \"30 mins\": \"#ff7043ff\"}\n    labels = list(colors.keys())\n    handles = [plt.Rectangle((0, 0), 1, 1, color=colors[label]) for label in labels]\n    # plt.legend(handles, labels)\n\n    plt.subplots_adjust(wspace=0.05)\n\n    return fig\n\n\ndef getgcdiagram(\n    modeldf,\n    modelname,\n    condition_label,\n    genotype_label,\n    scale_height,\n    minimal=True,\n    flipped=False,\n    display_svg=True,\n    debug=False,\n    brokenaxis=False,\n    aspser=False,\n    save_png=True,\n):\n    if minimal == True:\n        if aspser == True:\n            tree = ET.parse(\"../inputs/fluxmap_template_aspserminimal.svg\")\n            root = tree.getroot\n        else:\n            tree = ET.parse(\"../inputs/fluxmap_template_minimal.svg\")\n            root = tree.getroot\n    else:\n        tree = ET.parse(\"../inputs/fluxmap_template.svg\")\n        root = updatetextnames(tree, condition_label, genotype_label, debug=debug)\n\n    # get the background and the flipped background, and set the opacity of the wrong one to 0\n    background = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background\",\n        debug=debug,\n    )\n    background_flipped = getelement(\n        tree,\n        condition_label=condition_label,\n        genotype_label=genotype_label,\n        compartment_label=\"Background_flipped\",\n        debug=debug,\n    )\n\n    if flipped == True:\n        updateelementopacity(background, 0)\n        updateelementopacity(background_flipped, 1)\n    else:\n        updateelementopacity(background, 1)\n        updateelementopacity(background_flipped, 0)\n\n    if minimal is not True:\n        # get the scale bar, either keep the hatched or don't, and set the height to the scale conc specified\n        for phase_label in [\"EoN\", \"30\", \"EoN_hatched\", \"30_hatched\"]:\n            scale_bar_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=\"other\",\n                metabolite_label=\"scale\",\n                phase_label=phase_label,\n                debug=debug,\n            )\n            if \"hatched\" in phase_label:\n                updateelementopacity(scale_bar_element, int(flipped))\n            else:\n                updateelementopacity(scale_bar_element, int(not flipped))\n            updateelementheight(scale_bar_element, scale_height)\n\n    for row in modeldf.iterrows():\n\n        compartment_label = row[0][1]\n        metabolite_label = row[0][0]\n\n        if debug == True:\n            print(row[0], row[1])\n\n        try:\n            eon_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN\",\n                debug=debug,\n            )\n            thirty_element = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30\",\n                debug=debug,\n            )\n\n            eon_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"EoN_hatched\",\n                debug=debug,\n            )\n            thirty_element_hatched = getelement(\n                tree,\n                condition_label=condition_label,\n                genotype_label=genotype_label,\n                compartment_label=compartment_label,\n                metabolite_label=metabolite_label,\n                phase_label=\"30_hatched\",\n                debug=debug,\n            )\n\n            if flipped == True:\n                updateelementopacity(eon_element, 0)\n                updateelementopacity(eon_element_hatched, 1)\n                updateelementopacity(thirty_element, 0)\n                updateelementopacity(thirty_element_hatched, 1)\n            else:\n                updateelementopacity(eon_element, 1)\n                updateelementopacity(eon_element_hatched, 0)\n                updateelementopacity(thirty_element, 1)\n                updateelementopacity(thirty_element_hatched, 0)\n\n            if row[1][\"EoN\"] <= 0.0001:\n                updateelementheight(eon_element, 0.5)\n                updateelementheight(eon_element_hatched, 0.5)\n            else:\n                updateelementheight(eon_element, row[1][\"EoN\"])\n                updateelementheight(eon_element_hatched, row[1][\"EoN\"])\n\n            if row[1][\"30 mins\"] <= 0.0001:\n                updateelementheight(thirty_element, 0.5)\n                updateelementheight(thirty_element_hatched, 0.5)\n            else:\n                updateelementheight(thirty_element, row[1][\"30 mins\"])\n                updateelementheight(thirty_element_hatched, row[1][\"30 mins\"])\n\n        except AttributeError:\n            print(f\"{row[0]} not in template\")\n\n    svgpath = f\"../outputs/flux_maps/{modelname}.svg\"\n    tree.write(svgpath, encoding=\"UTF-8\", xml_declaration=True)\n    if display_svg == True:\n        display(SVG(svgpath))\n\n    return svgpath\n\n\ndef getelement(\n    tree,\n    condition_label,\n    genotype_label=None,\n    compartment_label=None,\n    metabolite_label=None,\n    phase_label=None,\n    debug=False,\n):\n    if debug == True:\n        print(\n            \"Trying: \",\n            condition_label,\n            genotype_label,\n            compartment_label,\n            metabolite_label,\n            phase_label,\n        )\n    root = tree.getroot()\n    if debug == True:\n        print(\"Got root\", end=\" \")\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if (\n            condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n            == \"condition\"\n        ):\n            if debug == True:\n                print(condition_label, end=\" \")\n            if genotype_label == None:\n                return conditon\n            else:\n                for genotype in condition:\n                    if (\n                        genotype.get(\n                            \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                        )\n                        == \"genotype\"\n                    ):\n                        if debug == True:\n                            print(genotype_label, end=\" \")\n                        if compartment_label == None:\n                            return genotype\n                        else:\n                            for compartment in genotype:\n                                if (\n                                    compartment.get(\n                                        \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                                    )\n                                    == compartment_label\n                                ):\n                                    if debug == True:\n                                        print(compartment_label, end=\" \")\n                                    if metabolite_label == None:\n                                        return compartment\n                                    else:\n                                        for metabolite in compartment:\n                                            if (\n                                                metabolite.get(\n                                                    \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                                                )\n                                                == metabolite_label\n                                            ):\n                                                if debug == True:\n                                                    print(metabolite_label, end=\" \")\n                                                if phase_label == None:\n                                                    return metabolite\n                                                else:\n                                                    for phase in metabolite:\n                                                        if (\n                                                            phase.get(\n                                                                \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                                                            )\n                                                            == phase_label\n                                                        ):\n                                                            return phase\n\n\ndef updateelementopacity(element, opacity):\n    style_attribs = element.attrib[\"style\"].split(\";\")\n    for i, style in enumerate(style_attribs):\n        if re.match(r\"^opacity\", style):\n            del style_attribs[i]\n    style_attribs.append(\"opacity:\" + str(opacity))\n    element.attrib[\"style\"] = \";\".join(style_attribs)\n    return element\n\n\ndef updateelementheight(element, height):\n    try:\n        element.attrib[\"height\"]\n        element.attrib[\"height\"] = str(height)\n    except:\n        element.attrib[\"d\"] = (\n            element.attrib[\"d\"].split(\"v\")[0]\n            + \"v -\"\n            + str(height)\n            + \" h\"\n            + element.attrib[\"d\"].split(\"h\")[1]\n        )\n    return element\n\n\ndef updatetextnames(tree, condition_label, genotype_label, debug=False):\n    root = tree.getroot()\n    for condition in root.findall(\"{http://www.w3.org/2000/svg}g\"):\n        if (\n            condition.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n            == \"condition\"\n        ):\n            for genotype in condition:\n                if (\n                    genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                    == \"condition_name\"\n                ):\n                    for tspan in genotype:\n                        tspan.text = condition_label\n                        if debug == True:\n                            print(\"Condition label changed to \" + tspan.text)\n                elif (\n                    genotype.get(\"{http://www.inkscape.org/namespaces/inkscape}label\")\n                    == \"genotype\"\n                ):\n                    for compartment in genotype:\n                        if (\n                            compartment.get(\n                                \"{http://www.inkscape.org/namespaces/inkscape}label\"\n                            )\n                            == \"genotype_name\"\n                        ):\n                            for tspan in compartment:\n                                tspan.text = genotype_label\n                                if debug == True:\n                                    print(\"Genotype label changed to \" + tspan.text)\n                                return root\n\n\nparameters_df = pd.read_csv(\"../inputs/arabidopsis_parameters.csv\", index_col=0)\nfour_stage_GC_model = cobra.io.sbml.read_sbml_model(\n    \"../models/4_stage_GC.xml\"\n)  # read model\narabidopsis_supermodel = SuperModel(\n    parameters_df.loc[:, \"Value\"], fba_model=four_stage_GC_model\n);\n\nNo objective coefficients in model. Unclear what should be optimized\n/home/nls119/src/mmon-gcm2/mmon_gcm/supermodel.py:25: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for parameter, value in parameters.iteritems():"
  },
  {
    "objectID": "2.2_analysingsolutions.html#import-solutions-and-set-up-dataframes",
    "href": "2.2_analysingsolutions.html#import-solutions-and-set-up-dataframes",
    "title": "Analysing solutions",
    "section": "Import solutions and set up dataframes",
    "text": "Import solutions and set up dataframes\n\nsolutions_dict = {\n    file[:-4]: pd.read_csv(f\"../outputs/model_solutions/{file}\", index_col=0)\n    for file in os.listdir(\"../outputs/model_solutions\")\n    if file.endswith(\".csv\")\n}\n\n\nCheck we’re in a good range for the solver\n\nmaxes = {}\nmins = {}\nfor name, solution in solutions_dict.items():\n    maxes[name] = abs(solution.loc[:, \"fluxes\"]).max()\n    mins[name] = abs(\n        solution.loc[:, \"fluxes\"][abs(solution.loc[:, \"fluxes\"]) > 10**-8]\n    ).min()\n\n\nmins\n\n{'blue_constrained_starchko': 1.5247677265731132e-05,\n 'blue_unconstrained_wt': 2.517235510636032e-07,\n 'white_constrained_wt': 3.27322847631833e-05,\n 'nops_unconstrained_wt': 0.0001811893409185,\n 'nops_constrained_wt': 2.1471018822492425e-05,\n 'nops_constrained_starchko': 3.72070755724131e-05,\n 'blue_constrained_wt': 2.334144094270074e-05,\n 'white_constrained_starchko': 4.4613154721834365e-05,\n 'white_unconstrained_starchko': 3.898122362004467e-05,\n 'white_unconstrained_wt': 3.898124962407721e-05,\n 'blue_unconstrained_starchko': 1.5552293266882112e-08,\n 'nops_unconstrained_starchko': 0.0001811893409177}\n\n\n\nabs(\n    solutions_dict[\"blue_unconstrained_wt\"].loc[:, \"fluxes\"][\n        abs(solutions_dict[\"blue_unconstrained_wt\"].loc[:, \"fluxes\"]) > 10**-8\n    ]\n).sort_values()\n\nNITRATE_c_gc_Linker_2                             2.517236e-07\nNITRATE_c_gc_Linker_3                             2.517236e-07\nNITRATE_c_gc_Linker_4                             2.517236e-07\nNITRATE_c_gc_Linker_1                             2.517236e-07\nPEPCARBOX_RXN_c_gc_3                              6.941965e-05\n                                                      ...     \nPLASTOQUINOL_PLASTOCYANIN_REDUCTASE_RXN_p_me_3    1.214771e+02\nRXN490_3650_p_me_3                                2.429542e+02\nEX_X_Photon_t_me_3                                4.859084e+02\nPhoton_tx_me_3                                    4.859084e+02\nPhoton_ep_me_3                                    4.859084e+02\nName: fluxes, Length: 981, dtype: float64\n\n\n\nabs(\n    solutions_dict[\"blue_unconstrained_starchko\"].loc[:, \"fluxes\"][\n        abs(solutions_dict[\"blue_unconstrained_starchko\"].loc[:, \"fluxes\"]) > 10**-8\n    ]\n).sort_values()\n\nNITRATE_c_gc_Linker_1                             1.555229e-08\nNITRATE_c_gc_Linker_2                             1.555229e-08\nNITRATE_c_gc_Linker_3                             1.555229e-08\nNITRATE_c_gc_Linker_4                             1.555229e-08\n2PGADEHYDRAT_RXN_p_gc_3                           6.942203e-05\n                                                      ...     \nPLASTOQUINOL_PLASTOCYANIN_REDUCTASE_RXN_p_me_3    1.214771e+02\nRXN490_3650_p_me_3                                2.429542e+02\nEX_X_Photon_t_me_3                                4.859084e+02\nPhoton_tx_me_3                                    4.859084e+02\nPhoton_ep_me_3                                    4.859084e+02\nName: fluxes, Length: 979, dtype: float64\n\n\nWith solver tolerance of 10-8 we treat any fluxes below that value as being effectively 0, and this doesn’t include any fluxes we’re interested in. They’re 10-5 and above, so there is a difference of three orders of magnitude.\n\nconditions_permutations = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n    [\"fluxes\", \"minimum\", \"maximum\"],\n]\n\nsolutions_df_columns = pd.MultiIndex.from_product(\n    conditions_permutations, names=[\"Light\", \"ATPase\", \"Starch\", \"Solution\"]\n)\nsolutions_df = pd.DataFrame(columns=solutions_df_columns)\n\nconditions_list_of_lists = [\n    [\"blue\", \"white\", \"nops\"],\n    [\"unconstrained\", \"constrained\"],\n    [\"wt\", \"starchko\"],\n]\nconditions_iterations = list(itertools.product(*conditions_list_of_lists))\n\ncols_to_drop = []\nfor conditions in conditions_iterations:\n    light_condition, atpase_condition, starch_condition = conditions\n    file_name = f\"../outputs/model_solutions/{light_condition}_{atpase_condition}_{starch_condition}.csv\"\n    try:\n        condition_df = pd.read_csv(file_name, index_col=0)\n        for col in [\"fluxes\", \"minimum\", \"maximum\"]:\n            solutions_df.loc[\n                :, (light_condition, atpase_condition, starch_condition, col)\n            ] = condition_df.loc[:, col]\n    except:\n        cols_to_drop.append(conditions)\n        print(f\"File {file_name} doesn't exist, skipping\")\n\n\nsolutions_df_unphased = solutions_df.copy()\nindex_phased = pd.MultiIndex.from_tuples(\n    [\n        (reaction[:-2], int(reaction[-1]))\n        if reaction[-1] in [\"1\", \"2\", \"3\", \"4\"]\n        else (reaction, None)\n        for reaction in solutions_df.index\n    ],\n    names=[\"Reaction\", \"Phase\"],\n)\nsolutions_df.index = index_phased\nsolutions_df = solutions_df.drop(cols_to_drop, axis=1)\n\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc[\n/tmp/ipykernel_374830/2276567288.py:27: DeprecationWarning: In a future version, `df.iloc[:, i] = newvals` will attempt to set the values inplace instead of always setting a new array. To retain the old behavior, use either `df[df.columns[i]] = newvals` or, if columns are non-unique, `df.isetitem(i, newvals)`\n  solutions_df.loc["
  },
  {
    "objectID": "2.2_analysingsolutions.html#plotting-linker-fluxes",
    "href": "2.2_analysingsolutions.html#plotting-linker-fluxes",
    "title": "Analysing solutions",
    "section": "Plotting Linker fluxes",
    "text": "Plotting Linker fluxes\nAll gc osmolytes\n\ndef get_linkers_df(\n    solutions_df,\n    concentrations=True,\n    osmolytes_path=\"../inputs/osmolytes.csv\",\n    SuperModel=None,\n):\n\n    osmolytes = pd.read_csv(osmolytes_path, index_col=0)\n    gc_osmolytes = [os for os in osmolytes.index if os[-2:] == \"gc\"]\n    gc_osmolytes_linker_reactions = [os + \"_Linker\" for os in gc_osmolytes]\n\n    linkers_df = solutions_df.loc[gc_osmolytes_linker_reactions].copy()\n\n    linkers_df = convert_phases_to_times(linkers_df)\n\n    if concentrations == True:\n        linkers_df = linkers_df.apply(convert_to_conc, args=([SuperModel]), axis=1)\n\n    linkers_df = linkers_df.reorder_levels([\"Phase\", \"Reaction\"]).sort_index()\n\n    index_key = {\"p\": \"Chloroplast\", \"v\": \"Vacuole\", \"c\": \"Cytoplasm\"}\n\n    linkers_df.index = pd.MultiIndex.from_tuples(\n        [\n            (\n                index[0],\n                \"_\".join(index[1].split(\"_\")[:-3]),\n                index_key[index[1].split(\"_\")[-3]],\n            )\n            for index in linkers_df.index\n        ],\n        names=linkers_df.index.names + [\"Compartment\"],\n    )\n\n    return linkers_df\n\n\nlinkers_df = get_linkers_df(solutions_df, SuperModel=arabidopsis_supermodel)\n\n/tmp/ipykernel_374830/978925231.py:7: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\nmet_df_mm = get_metabolite_df(solutions_df, SuperModel=arabidopsis_supermodel)\n\n/tmp/ipykernel_374830/978925231.py:7: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\nordered_index = []\nfor phase in [0.0, 6.0, 6.5, 18.0, 24.0]:\n    for met in [\"K\", \"Cl\", \"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"STARCH\"]:\n        ordered_index.append((phase, met))\npd.MultiIndex.from_tuples(ordered_index)\nmet_df_mm = met_df_mm.reindex(ordered_index)\nmet_df_mm\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      ...\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      ...\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      ...\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      \n      Solution\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      ...\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n    \n    \n      Phase\n      Reaction\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0.0\n      K\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      ...\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      1.623558e+01\n      NaN\n      NaN\n      1.396758e+01\n      NaN\n      NaN\n    \n    \n      Cl\n      2.223223e+01\n      NaN\n      NaN\n      2.223331e+01\n      NaN\n      NaN\n      1.779201e+01\n      NaN\n      NaN\n      2.456769e-14\n      ...\n      NaN\n      -3.212964e-12\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -2.404497e-15\n      NaN\n      NaN\n    \n    \n      SUCROSE\n      8.531006e-12\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -1.588203e-11\n      NaN\n      NaN\n      3.203986e+01\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      1.710048e+01\n      NaN\n      NaN\n      3.124427e+01\n      NaN\n      NaN\n    \n    \n      GLC\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -8.322345e-12\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -2.236757e-13\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      FRU\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -1.034804e-06\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -2.863518e-14\n      NaN\n      NaN\n      -3.859590e-13\n      NaN\n      NaN\n    \n    \n      MAL\n      2.414779e+01\n      NaN\n      NaN\n      2.414862e+01\n      NaN\n      NaN\n      8.119376e+00\n      NaN\n      NaN\n      5.303941e+00\n      ...\n      NaN\n      1.750039e-13\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      7.287615e+00\n      NaN\n      NaN\n    \n    \n      CIT\n      1.007895e-12\n      NaN\n      NaN\n      -1.094230e-13\n      NaN\n      NaN\n      -1.576202e-12\n      NaN\n      NaN\n      3.284107e-16\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      2.552446e+00\n      NaN\n      NaN\n      2.186282e+00\n      NaN\n      NaN\n    \n    \n      STARCH\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      7.154663e-03\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      2.976651e-03\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      6.0\n      K\n      2.223338e+01\n      0.000000e+00\n      129.146199\n      2.223338e+01\n      5.364309e-16\n      129.146199\n      2.223338e+01\n      0.000000e+00\n      129.146199\n      2.223338e+01\n      ...\n      129.146199\n      2.223338e+01\n      0.0\n      129.146199\n      1.623558e+01\n      0.000000e+00\n      129.146199\n      1.396758e+01\n      0.000000e+00\n      124.337668\n    \n    \n      Cl\n      2.223223e+01\n      0.000000e+00\n      89.290671\n      2.223331e+01\n      0.000000e+00\n      89.290671\n      1.779201e+01\n      0.000000e+00\n      89.290671\n      2.456769e-14\n      ...\n      89.290671\n      0.000000e+00\n      0.0\n      89.290671\n      0.000000e+00\n      0.000000e+00\n      89.290671\n      -2.404497e-15\n      6.793058e-26\n      80.389461\n    \n    \n      SUCROSE\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      3.203986e+01\n      ...\n      178.581341\n      -1.634626e-14\n      0.0\n      178.581341\n      1.710048e+01\n      0.000000e+00\n      178.581341\n      3.124427e+01\n      0.000000e+00\n      178.581341\n    \n    \n      GLC\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      1.532076e-15\n      0.000000e+00\n      178.581341\n      -8.322345e-12\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      ...\n      178.581341\n      0.000000e+00\n      0.0\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      160.463896\n    \n    \n      FRU\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      -1.034804e-06\n      ...\n      178.581341\n      0.000000e+00\n      0.0\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      178.581341\n      0.000000e+00\n      0.000000e+00\n      160.463896\n    \n    \n      MAL\n      2.414779e+01\n      0.000000e+00\n      64.494321\n      2.414862e+01\n      6.028235e-27\n      64.494321\n      8.119376e+00\n      0.000000e+00\n      64.494321\n      5.303941e+00\n      ...\n      64.494321\n      0.000000e+00\n      0.0\n      64.494321\n      0.000000e+00\n      0.000000e+00\n      64.494321\n      7.287615e+00\n      0.000000e+00\n      64.494321\n    \n    \n      CIT\n      0.000000e+00\n      -1.502669e-11\n      49.435142\n      -1.164076e-13\n      0.000000e+00\n      49.435142\n      -8.653558e-13\n      0.000000e+00\n      49.435142\n      5.997260e-16\n      ...\n      49.435142\n      -5.484840e-29\n      0.0\n      49.435142\n      2.552446e+00\n      0.000000e+00\n      49.435142\n      2.186282e+00\n      0.000000e+00\n      49.435142\n    \n    \n      STARCH\n      0.000000e+00\n      0.000000e+00\n      1000.000000\n      0.000000e+00\n      0.000000e+00\n      0.000000\n      7.154663e-03\n      0.000000e+00\n      0.304138\n      0.000000e+00\n      ...\n      1000.000000\n      0.000000e+00\n      0.0\n      0.000000\n      2.976651e-03\n      0.000000e+00\n      0.279649\n      0.000000e+00\n      0.000000e+00\n      0.000000\n    \n    \n      6.5\n      K\n      5.134623e+01\n      0.000000e+00\n      143.220573\n      5.134627e+01\n      5.737648e-11\n      143.220573\n      3.640842e+01\n      -3.701394e-27\n      129.269842\n      3.640842e+01\n      ...\n      143.220573\n      4.997736e+01\n      0.0\n      143.220573\n      3.119891e+01\n      8.523167e-15\n      129.269842\n      2.922898e+01\n      0.000000e+00\n      125.093289\n    \n    \n      Cl\n      5.134524e+01\n      0.000000e+00\n      108.221407\n      5.134621e+01\n      0.000000e+00\n      108.221407\n      3.255078e+01\n      0.000000e+00\n      94.652468\n      1.709714e+01\n      ...\n      108.221407\n      3.066608e+01\n      0.0\n      108.221407\n      1.709714e+01\n      0.000000e+00\n      94.652468\n      1.709714e+01\n      0.000000e+00\n      86.921132\n    \n    \n      SUCROSE\n      4.083694e-01\n      0.000000e+00\n      216.442814\n      4.083952e-01\n      0.000000e+00\n      216.442814\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      -5.356596e-14\n      ...\n      216.442814\n      0.000000e+00\n      0.0\n      216.442814\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      0.000000e+00\n      0.000000e+00\n      138.964049\n    \n    \n      GLC\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      1.330718e-15\n      0.000000e+00\n      216.442814\n      2.819572e+01\n      0.000000e+00\n      216.442814\n      2.782890e+01\n      ...\n      216.442814\n      -2.027432e-12\n      0.0\n      216.442814\n      2.602939e+01\n      0.000000e+00\n      216.442814\n      2.713788e+01\n      0.000000e+00\n      216.442814\n    \n    \n      FRU\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      0.000000e+00\n      0.000000e+00\n      216.442814\n      2.782890e+01\n      ...\n      216.442814\n      -2.027432e-12\n      0.0\n      216.442814\n      1.485299e+01\n      0.000000e+00\n      216.442814\n      2.713788e+01\n      0.000000e+00\n      216.442814\n    \n    \n      MAL\n      1.782797e+01\n      0.000000e+00\n      65.116825\n      1.782858e+01\n      0.000000e+00\n      65.116825\n      5.994419e+00\n      0.000000e+00\n      65.116825\n      3.915824e+00\n      ...\n      65.116825\n      -1.319257e-14\n      0.0\n      65.116825\n      3.325473e+00\n      0.000000e+00\n      65.116825\n      8.228756e+00\n      0.000000e+00\n      62.368323\n    \n    \n      CIT\n      9.648151e-13\n      0.000000e+00\n      44.869080\n      0.000000e+00\n      0.000000e+00\n      44.869080\n      -2.581520e-28\n      9.651638e-13\n      44.869080\n      0.000000e+00\n      ...\n      44.869080\n      1.358935e-14\n      0.0\n      44.869080\n      0.000000e+00\n      0.000000e+00\n      44.869080\n      0.000000e+00\n      0.000000e+00\n      39.253775\n    \n    \n      STARCH\n      0.000000e+00\n      0.000000e+00\n      0.000000\n      0.000000e+00\n      0.000000e+00\n      0.000000\n      0.000000e+00\n      0.000000e+00\n      0.099944\n      0.000000e+00\n      ...\n      0.000000\n      0.000000e+00\n      0.0\n      0.000000\n      0.000000e+00\n      0.000000e+00\n      0.099944\n      0.000000e+00\n      0.000000e+00\n      0.000000\n    \n    \n      18.0\n      K\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      ...\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      1.623558e+01\n      NaN\n      NaN\n      1.396758e+01\n      NaN\n      NaN\n    \n    \n      Cl\n      2.223223e+01\n      NaN\n      NaN\n      2.223331e+01\n      NaN\n      NaN\n      1.779201e+01\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -2.669871e-12\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -4.272136e-14\n      NaN\n      NaN\n    \n    \n      SUCROSE\n      8.530463e-12\n      NaN\n      NaN\n      3.240018e-15\n      NaN\n      NaN\n      -1.564578e-11\n      NaN\n      NaN\n      3.203986e+01\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      1.710048e+01\n      NaN\n      NaN\n      3.124427e+01\n      NaN\n      NaN\n    \n    \n      GLC\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      FRU\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -1.034804e-06\n      ...\n      NaN\n      -3.887412e-12\n      NaN\n      NaN\n      -3.232265e-14\n      NaN\n      NaN\n      -3.654689e-13\n      NaN\n      NaN\n    \n    \n      MAL\n      2.414779e+01\n      NaN\n      NaN\n      2.414862e+01\n      NaN\n      NaN\n      8.119376e+00\n      NaN\n      NaN\n      5.303941e+00\n      ...\n      NaN\n      8.329726e-14\n      NaN\n      NaN\n      -2.118566e-14\n      NaN\n      NaN\n      7.287615e+00\n      NaN\n      NaN\n    \n    \n      CIT\n      1.007895e-12\n      NaN\n      NaN\n      -3.559742e-14\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -8.839934e-14\n      NaN\n      NaN\n      2.552446e+00\n      NaN\n      NaN\n      2.186282e+00\n      NaN\n      NaN\n    \n    \n      STARCH\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      7.154663e-03\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      2.976651e-03\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      24.0\n      K\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      2.223338e+01\n      ...\n      NaN\n      2.223338e+01\n      NaN\n      NaN\n      1.623558e+01\n      NaN\n      NaN\n      1.396758e+01\n      NaN\n      NaN\n    \n    \n      Cl\n      2.223223e+01\n      NaN\n      NaN\n      2.223331e+01\n      NaN\n      NaN\n      1.779201e+01\n      NaN\n      NaN\n      2.456769e-14\n      ...\n      NaN\n      -3.212964e-12\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -2.404497e-15\n      NaN\n      NaN\n    \n    \n      SUCROSE\n      8.531006e-12\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -1.588203e-11\n      NaN\n      NaN\n      3.203986e+01\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      1.710048e+01\n      NaN\n      NaN\n      3.124427e+01\n      NaN\n      NaN\n    \n    \n      GLC\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -8.322345e-12\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -2.236757e-13\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      FRU\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -1.034804e-06\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      -2.863518e-14\n      NaN\n      NaN\n      -3.859590e-13\n      NaN\n      NaN\n    \n    \n      MAL\n      2.414779e+01\n      NaN\n      NaN\n      2.414862e+01\n      NaN\n      NaN\n      8.119376e+00\n      NaN\n      NaN\n      5.303941e+00\n      ...\n      NaN\n      1.750039e-13\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      7.287615e+00\n      NaN\n      NaN\n    \n    \n      CIT\n      1.007895e-12\n      NaN\n      NaN\n      -1.094230e-13\n      NaN\n      NaN\n      -1.576202e-12\n      NaN\n      NaN\n      3.284107e-16\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      2.552446e+00\n      NaN\n      NaN\n      2.186282e+00\n      NaN\n      NaN\n    \n    \n      STARCH\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      7.154663e-03\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      2.976651e-03\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n  \n\n40 rows × 36 columns\n\n\n\n\nmet_df = get_metabolite_df(solutions_df, concentrations=False)\n\n/tmp/ipykernel_374830/978925231.py:7: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n  df = df.append(pd.concat([df.loc[24]], keys=[0]))\n\n\n\ndef plot_linkers(df, light):\n    fig, axs = plt.subplots(2, 2, figsize=(10, 10), sharex=True, sharey=True)\n    for x, atpase_condition in enumerate([\"unconstrained\", \"constrained\"]):\n        for y, starch_condition in enumerate([\"wt\", \"starchko\"]):\n            df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[\n                :, (light, atpase_condition, starch_condition)\n            ].unstack().plot(\n                title=f\"{atpase_condition} {starch_condition}\", ax=axs[x][y]\n            )\n            starch_axis = axs[x][y].twinx()\n            (\n                df.xs(\"fluxes\", level=\"Solution\", axis=1)\n                .loc[:, (light, atpase_condition, starch_condition)]\n                .xs(\"STARCH\", level=\"Reaction\")\n            ).plot(ax=starch_axis, ylim=(0, 0.01), color=\"black\")\n            axs[x][y].get_legend().remove()\n    axs[1][0].legend(loc=\"center left\", bbox_to_anchor=(2.3, 1.1))\n\n\nfor light in [\"blue\", \"white\"]:\n    plot_linkers(met_df_mm, light)"
  },
  {
    "objectID": "2.2_analysingsolutions.html#plotting-before-and-after-opening",
    "href": "2.2_analysingsolutions.html#plotting-before-and-after-opening",
    "title": "Analysing solutions",
    "section": "Plotting before and after opening",
    "text": "Plotting before and after opening\n\ndef convert_starch_cols_to_per_gc(row_series, SuperModel, units):\n    if row_series.name[1] == \"STARCH\":\n        n_gcs = SuperModel.N_gcs\n        row_series_moles = row_series * 10 ** -3\n        moles_per_gc = row_series_moles / n_gcs\n        row_series_converted_to_units = moles_per_gc * (1 / units)\n\n        return row_series_converted_to_units\n\n    else:\n        return row_series\n\n\nfemtomoles = 10 ** -15\nmet_df_mm_starch_fmol_per_gc = met_df_mm.apply(\n    convert_starch_cols_to_per_gc, args=[arabidopsis_supermodel, femtomoles], axis=1\n)\n\n\nmet_df_mm_starch_fmol_per_gc.xs(\"STARCH\", level=\"Reaction\").xs(\n    \"fluxes\", level=\"Solution\", axis=1\n)\n\n\n\n\n\n  \n    \n      Light\n      blue\n      white\n      nops\n    \n    \n      ATPase\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0.0\n      0.0\n      0.0\n      12.335626\n      0.0\n      0.0\n      0.0\n      11.632011\n      0.0\n      -1.186387e-16\n      0.0\n      5.132157\n      0.0\n    \n    \n      6.0\n      0.0\n      0.0\n      12.335626\n      0.0\n      0.0\n      0.0\n      11.632011\n      0.0\n      -1.186387e-16\n      0.0\n      5.132157\n      0.0\n    \n    \n      6.5\n      0.0\n      0.0\n      0.000000\n      0.0\n      0.0\n      0.0\n      0.000000\n      0.0\n      0.000000e+00\n      0.0\n      0.000000\n      0.0\n    \n    \n      18.0\n      0.0\n      0.0\n      12.335626\n      0.0\n      0.0\n      0.0\n      11.632011\n      0.0\n      0.000000e+00\n      0.0\n      5.132157\n      0.0\n    \n    \n      24.0\n      0.0\n      0.0\n      12.335626\n      0.0\n      0.0\n      0.0\n      11.632011\n      0.0\n      -1.186387e-16\n      0.0\n      5.132157\n      0.0\n    \n  \n\n\n\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n            \"fluxes\", level=\"Solution\", axis=1\n        )\n        fig = get_totals_plot(specific_df)\n        plot_name = f\"{light}_{atpase}\"\n        fig.savefig(\n            f\"../outputs/total_opening_plots/{plot_name}.svg\",\n            format=\"svg\",\n            bbox_inches=\"tight\",\n        )\n        fig.savefig(\n            f\"../outputs/total_opening_plots/{plot_name}.png\",\n            format=\"png\",\n            bbox_inches=\"tight\",\n            dpi=300,\n        )\n\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs(\n/tmp/ipykernel_374830/1926438676.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  specific_df = met_df_mm_starch_fmol_per_gc.loc[:, (light, atpase)].xs("
  },
  {
    "objectID": "2.2_analysingsolutions.html#flux-maps",
    "href": "2.2_analysingsolutions.html#flux-maps",
    "title": "Analysing solutions",
    "section": "Flux maps",
    "text": "Flux maps\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        for starch in [\"wt\", \"starchko\"]:\n            model_solution = solutions_df_unphased.loc[\n                :, (light, atpase, starch, \"fluxes\")\n            ]\n            flux_map = get_escher_map(\n                model_solution,\n                map=\"../inputs/map.json\",\n                json_model=\"../models/4_stage_GC.json\",\n            )\n            flux_map_name = f\"{light}_{atpase}_{starch}\"\n            flux_map.save_html(f\"../outputs/escher_maps/{flux_map_name}.html\")\n\n\nlinkers_met_dict = {\n    \"SUCROSE\": \"Suc\",\n    \"GLC\": \"Glc\",\n    \"FRU\": \"Fru\",\n    \"MAL\": \"Mal\",\n    \"CIT\": \"Cit\",\n    \"L_ASPARTATE\": \"Asp\",\n    \"SER\": \"Ser\",\n}\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"white\", \"constrained\", \"starchko\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n  \n    \n      \n      Phase\n      6.0\n      6.5\n    \n    \n      Reaction\n      Compartment\n      \n      \n    \n  \n  \n    \n      SUCROSE\n      Cytoplasm\n      0.000000e+00\n      0.000000e+00\n    \n    \n      Vacuole\n      3.464566e+01\n      0.000000e+00\n    \n    \n      GLC\n      Cytoplasm\n      0.000000e+00\n      1.010736e+01\n    \n    \n      Vacuole\n      0.000000e+00\n      3.009223e+01\n    \n    \n      FRU\n      Cytoplasm\n      -2.311596e-15\n      0.000000e+00\n    \n    \n      Vacuole\n      0.000000e+00\n      3.009223e+01\n    \n    \n      MAL\n      Cytoplasm\n      2.181359e+01\n      0.000000e+00\n    \n    \n      Vacuole\n      0.000000e+00\n      6.281917e+00\n    \n    \n      CIT\n      Cytoplasm\n      0.000000e+00\n      0.000000e+00\n    \n    \n      Vacuole\n      0.000000e+00\n      -1.467736e-10\n    \n    \n      L_ASPARTATE\n      Vacuole\n      3.099630e+00\n      0.000000e+00\n    \n    \n      SER\n      Vacuole\n      0.000000e+00\n      2.692250e+00\n    \n  \n\n\n\n\n\nlinkers_df.loc[\n    ([6, 6.5], [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]),\n    (\"white\", \"constrained\", \"wt\", \"fluxes\"),\n].unstack(0)\n\n\n\n\n\n  \n    \n      \n      Phase\n      6.0\n      6.5\n    \n    \n      Reaction\n      Compartment\n      \n      \n    \n  \n  \n    \n      SUCROSE\n      Cytoplasm\n      7.886935e-13\n      8.180265e+00\n    \n    \n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n    \n      GLC\n      Cytoplasm\n      0.000000e+00\n      1.067769e+02\n    \n    \n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n    \n      FRU\n      Cytoplasm\n      0.000000e+00\n      0.000000e+00\n    \n    \n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n    \n      MAL\n      Cytoplasm\n      0.000000e+00\n      3.382845e+01\n    \n    \n      Vacuole\n      1.063445e+01\n      0.000000e+00\n    \n    \n      CIT\n      Cytoplasm\n      3.221217e-11\n      -2.892443e-11\n    \n    \n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n    \n      L_ASPARTATE\n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n    \n      SER\n      Vacuole\n      0.000000e+00\n      0.000000e+00\n    \n  \n\n\n\n\n\nfor light in [\"blue\", \"white\", \"nops\"]:\n    for atpase in [\"unconstrained\", \"constrained\"]:\n        for starch in [\"wt\", \"starchko\"]:\n            print(f\"{light}_{atpase}_{starch}\")\n\n            mets_to_include = [\"SUCROSE\", \"GLC\", \"FRU\", \"MAL\", \"CIT\", \"L_ASPARTATE\", \"SER\"]\n            test_df = linkers_df.loc[\n                (\n                    [6, 6.5],\n                    mets_to_include,\n                ),\n                (light, atpase, starch, \"fluxes\"),\n            ].unstack(0)\n            test_df.columns = [\"EoN\", \"30 mins\"]\n            test_df.index = pd.MultiIndex.from_tuples(\n                [(linkers_met_dict[index[0]], index[1]) for index in test_df.index]\n            )\n\n            scaling = 0.4\n\n            test_df = test_df * scaling\n\n            if (test_df.loc[[\"Asp\", \"Ser\"]] > 0.0000000001).sum().sum() > 0:\n                aspser = True\n                print(test_df)\n            else:\n                aspser = False\n\n            scale_conc = 50  # mM\n\n            scaled_scale_conc = scale_conc * scaling\n\n            map_name = f\"{light}_{atpase}_{starch}\"\n            if starch == \"wt\":\n                gc_path = getgcdiagram(\n                    test_df,\n                    map_name,\n                    atpase,\n                    starch,\n                    scaled_scale_conc,\n                    flipped=False,\n                    aspser=aspser,\n                    display_svg=True,\n                    debug=False,\n                    brokenaxis=False,\n                )\n            else:\n                gc_path = getgcdiagram(\n                    test_df,\n                    map_name,\n                    atpase,\n                    starch,\n                    scaled_scale_conc,\n                    flipped=True,\n                    aspser=aspser,\n                    display_svg=True,\n                    debug=False,\n                    brokenaxis=False,\n                )\n\n            # doesn't seem to work with hatched\n            # svg_code = open(gc_path, 'rt').read()\n            # svg2png(bytestring=svg_code, write_to=f\"../outputs/flux_maps/{map_name}.png\", dpi=300)\n\nblue_unconstrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nblue_unconstrained_starchko\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nblue_constrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nblue_constrained_starchko\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nwhite_unconstrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nwhite_unconstrained_starchko\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nwhite_constrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nwhite_constrained_starchko\n                        EoN       30 mins\nSuc Cytoplasm  0.000000e+00  0.000000e+00\n    Vacuole    1.385826e+01  0.000000e+00\nGlc Cytoplasm  0.000000e+00  4.042944e+00\n    Vacuole    0.000000e+00  1.203689e+01\nFru Cytoplasm -9.246382e-16  0.000000e+00\n    Vacuole    0.000000e+00  1.203689e+01\nMal Cytoplasm  8.725438e+00  0.000000e+00\n    Vacuole    0.000000e+00  2.512767e+00\nCit Cytoplasm  0.000000e+00  0.000000e+00\n    Vacuole    0.000000e+00 -5.870942e-11\nAsp Vacuole    1.239852e+00  0.000000e+00\nSer Vacuole    0.000000e+00  1.076900e+00\n('Cit', 'Vacuole') not in template\n\n\n\n\n\nnops_unconstrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nnops_unconstrained_starchko\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nnops_constrained_wt\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\nnops_constrained_starchko\n('Asp', 'Vacuole') not in template\n('Ser', 'Vacuole') not in template\n\n\n\n\n\n\nblue_phloem_tx_overall_df = solutions_df.loc[\"Phloem_tx_overall\", \"blue\"].xs(\n    \"fluxes\", level=\"Solution\", axis=1\n)\nwhite_phloem_tx_overall_df = solutions_df.loc[\"Phloem_tx_overall\", \"white\"].xs(\n    \"fluxes\", level=\"Solution\", axis=1\n)\n\n\nblue_phloem_tx_overall_df_wt_unconstrained_corrected = (\n    blue_phloem_tx_overall_df - blue_phloem_tx_overall_df.iloc[0, 0]\n)\nblue_phloem_tx_overall_df_wt_unconstrained_corrected = (\n    blue_phloem_tx_overall_df_wt_unconstrained_corrected.mask(\n        blue_phloem_tx_overall_df_wt_unconstrained_corrected > -0.0000000001, 0\n    )\n)\nblue_phloem_tx_overall_df_wt_unconstrained_corrected_fmol = (\n    blue_phloem_tx_overall_df_wt_unconstrained_corrected\n    / parameters_df.loc[\"N_gcs\", \"Value\"]\n    * 10 ** 12\n)\n\n\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected = (\n    white_phloem_tx_overall_df - white_phloem_tx_overall_df.iloc[0, 0]\n)\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected = (\n    white_phloem_tx_overall_df_wt_unconstrained_corrected.mask(\n        white_phloem_tx_overall_df_wt_unconstrained_corrected > -0.0000000001, 0\n    )\n)\nwhite_phloem_tx_overall_df_wt_unconstrained_corrected_fmol = (\n    white_phloem_tx_overall_df_wt_unconstrained_corrected\n    / parameters_df.loc[\"N_gcs\", \"Value\"]\n    * 10 ** 12\n)\n\n\ncombined_fmol = pd.concat(\n    [\n        blue_phloem_tx_overall_df_wt_unconstrained_corrected_fmol,\n        white_phloem_tx_overall_df_wt_unconstrained_corrected_fmol,\n    ],\n    keys=[\"Blue\", \"White\"],\n)\ncombined_fmol.index = combined_fmol.index.droplevel(1)\ncombined_fmol\n\n\n\n\n\n  \n    \n      ATPase\n      unconstrained\n      constrained\n    \n    \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n    \n  \n  \n    \n      Blue\n      0.0\n      0.0\n      -0.009728\n      -0.030701\n    \n    \n      White\n      0.0\n      0.0\n      -0.011841\n      -0.037546\n    \n  \n\n\n\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\ncombined_fmol.plot.bar(ax=ax)\nax.legend(loc=\"center left\", bbox_to_anchor=(1, 0.5))\nax.set_ylabel(\n    \"Reduction in overall phloem output compared to \\n unconstrained WT in specified light(fmol gc$^{-1}$ h$^{-1}$)\"\n)\n\nfig.set_tight_layout(True)\n\nfig.savefig(\"../outputs/efficiency_comparisons/efficiency_comparisons_compared.svg\")\nfig.savefig(\"../outputs/efficiency_comparisons/efficiency_comparisons_compared.png\")\n\n\n\n\n\nfrom functools import reduce\n\n\ndef multiply_series_by_coefficient(series_object, model, metabolite_id):\n    reaction_id = series_object.name[0]\n    coefficient = model.reactions.get_by_id(f\"{reaction_id}_1\").get_coefficient(\n        f\"{metabolite_id}_1\"\n    )\n    return coefficient * series_object\n\n\ndef get_metabolite_budget(solution_df, metabolite, model):\n    metabolite_reactions_df = solution_df.loc[\n        (\n            [\n                reaction.id[:-2]\n                for reaction in four_stage_GC_model.metabolites.get_by_id(\n                    f\"{metabolite}_1\"\n                ).reactions\n            ],\n            slice(None),\n        ),\n        :,\n    ]\n    metabolite_consumed_produced_df = metabolite_reactions_df.apply(\n        multiply_series_by_coefficient, args=[model, metabolite], axis=1\n    )\n    return metabolite_consumed_produced_df\n\n\ndef get_relevant_reaction_fluxes(\n    solution_df,\n    scenarios_to_drop=[(\"nops\", \"unconstrained\"), (\"white\", \"unconstrained\")],\n):\n\n    solution_df = solution_df.xs(\"fluxes\", level=\"Solution\", axis=1)\n    solution_df = solution_df.loc[\n        (abs(solution_df) > 0.00001).any(axis=1), :\n    ]  # pick only reactions which have a flux in at least one scenario\n    solution_df[abs(solution_df) < 0.00001] = 0  # ignore tiny fluxes from solver error\n    solution_df = solution_df.drop(\n        scenarios_to_drop, axis=1\n    )  # only keep the scenarios that we are interested in\n\n    return solution_df\n\n\ndef get_budget_for_multiple_metabolites(solution_df, metabolites, fba_model):\n\n    metabolite_dfs = [\n        get_metabolite_budget(solution_df, metabolite, fba_model)\n        for metabolite in metabolites\n    ]\n    metabolite_total_df = reduce(lambda a, b: a.add(b, fill_value=0), metabolite_dfs)\n    metabolite_total_df = get_relevant_reaction_fluxes(metabolite_total_df)\n\n    return metabolite_total_df\n\n\natp_metabolites = [\n    metabolite.id\n    for metabolite in four_stage_GC_model.metabolites\n    if \"ATP\" in metabolite.id\n]\ngc_atp_metabolites = [\n    metabolite[:-2] for metabolite in atp_metabolites if \"gc_2\" in metabolite\n]\ngc_atp_metabolites = [\n    e\n    for e in gc_atp_metabolites\n    if e not in (\"DATP_p_gc\", \"PHOSPHORIBOSYL_ATP_p_gc\", \"aDATP_p_gc\")\n]\natp_budget_df = get_budget_for_multiple_metabolites(\n    solutions_df, gc_atp_metabolites, four_stage_GC_model\n)\n\n/tmp/ipykernel_374830/4037575462.py:11: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(\n\n\n\nnadh_nadph_metabolites = [\n    metabolite.id\n    for metabolite in four_stage_GC_model.metabolites\n    if \"NADH\" in metabolite.id or \"NADPH\" in metabolite.id\n]\ngc_nadh_nadph_metabolites = [\n    metabolite[:-2] for metabolite in nadh_nadph_metabolites if \"gc_2\" in metabolite\n]\nnadh_nadph_budget_df = get_budget_for_multiple_metabolites(\n    solutions_df, gc_nadh_nadph_metabolites, four_stage_GC_model\n)\n\n/tmp/ipykernel_374830/4037575462.py:11: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(\n\n\n\nnadh_nadph_budget_df\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.022910\n      0.022910\n      0.000000\n      0.000000\n    \n    \n      3\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.000000\n      0.000000\n    \n    \n      1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.021037\n      -0.019431\n      0.000000\n      0.000000\n    \n    \n      3\n      -0.021569\n      -0.021569\n      -0.021534\n      -0.021405\n      -0.021531\n      -0.021448\n      0.000000\n      0.000000\n    \n    \n      2OXOGLUTARATEDEH_RXN_m_gc\n      2\n      0.000768\n      0.000768\n      0.000537\n      0.000351\n      0.000000\n      0.000000\n      0.001125\n      0.000964\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000021\n      0.000037\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      2\n      -0.000829\n      -0.000829\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000563\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000079\n    \n    \n      GAPOXNPHOSPHN_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.001026\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000046\n      0.000000\n    \n    \n      HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000045\n      0.000000\n      0.000000\n    \n    \n      ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\n      2\n      0.000768\n      0.000768\n      0.000537\n      0.000351\n      0.000000\n      0.000000\n      0.001125\n      0.000964\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000021\n      0.000037\n    \n    \n      MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.001873\n      -0.003479\n      0.000000\n      0.000000\n    \n    \n      3\n      -0.001341\n      -0.001341\n      -0.001377\n      -0.001505\n      -0.001380\n      -0.001463\n      0.000000\n      0.000000\n    \n    \n      MALATE_DEH_RXN_c_gc\n      2\n      0.000829\n      0.000829\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000563\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000079\n    \n    \n      MALATE_DEH_RXN_m_gc\n      2\n      0.000768\n      0.000768\n      0.000537\n      0.000701\n      0.002627\n      0.002453\n      0.000000\n      0.000000\n    \n    \n      3\n      0.001272\n      0.001272\n      0.001353\n      0.001490\n      0.001347\n      0.001463\n      0.000141\n      0.000158\n    \n    \n      MALATE_DEH_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000046\n      0.000000\n    \n    \n      MALATE_DEH_RXN_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000045\n      0.000000\n      0.000000\n    \n    \n      MALIC_NAD_RXN_m_gc\n      2\n      0.000768\n      0.000768\n      0.000537\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      NADH_DEHYDROG_A_RXN_mi_gc\n      2\n      -0.003838\n      -0.003838\n      -0.002684\n      -0.001753\n      -0.002627\n      -0.002453\n      -0.002250\n      -0.001927\n    \n    \n      3\n      -0.001272\n      -0.001272\n      -0.001353\n      -0.001490\n      -0.001347\n      -0.001463\n      -0.000254\n      -0.000312\n    \n    \n      PGLYCDEHYDROG_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.001026\n      0.000000\n      0.000000\n    \n    \n      PYRUVDEH_RXN_m_gc\n      2\n      0.000768\n      0.000768\n      0.000537\n      0.000351\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000070\n      0.000079\n    \n  \n\n\n\n\n\natp_ordered_by_most_likely_importance = (\n    abs(atp_budget_df)\n    .groupby(by=\"Reaction\")\n    .sum()\n    .sum(axis=1)\n    .sort_values(ascending=False)\n)\natp_budget_df_reordered = atp_budget_df.reindex(\n    atp_ordered_by_most_likely_importance.index, level=\"Reaction\"\n)\n\n\nnadh_nadph_ordered_by_most_likely_importance = (\n    abs(nadh_nadph_budget_df)\n    .groupby(by=\"Reaction\")\n    .sum()\n    .sum(axis=1)\n    .sort_values(ascending=False)\n)\nnadh_nadph_budget_df_reordered = nadh_nadph_budget_df.reindex(\n    nadh_nadph_ordered_by_most_likely_importance.index, level=\"Reaction\"\n)\n\n\ndef convert_fluxes_to_per_guard_cell(series, super_model, units):\n\n    return series * 10 ** -3 / super_model.N_gcs * (1 / units)\n\n\nunits = 10 ** -15  # fmol\n\n\natp_budget_df_reordered_nmoles_gc = atp_budget_df_reordered.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\nnadh_nadph_budget_df_reordered_nmoles_gc = nadh_nadph_budget_df_reordered.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\n\nCarbon movement df generation\n\napoplastic_linker_reactions = [\n    reaction.id[:-2]\n    for reaction in four_stage_GC_model.reactions\n    if \"a_Linker\" in reaction.id\n]\nget_relevant_reaction_fluxes(\n    solutions_df.loc[(apoplastic_linker_reactions, slice(None)), :]\n)\n\n/tmp/ipykernel_374830/4037575462.py:11: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      SUCROSE_a_Linker\n      3\n      0.010272\n      0.010272\n      0.006685\n      0.006689\n      0.007382\n      0.007517\n      0.0\n      0.0\n    \n  \n\n\n\n\n\ntransfer_reactions = [\n    reaction.id[:-2]\n    for reaction in four_stage_GC_model.reactions\n    if \"ae_gc\" in reaction.id\n]\ntransfer_reactions = [\n    e for e in transfer_reactions if e not in (\"WATER_ae_gc\", \"K_ae_gc\", \"Cl_ae_gc\", \"NITRATE_ae_gc\")\n]\ntransfer_reactions = solutions_df.loc[(transfer_reactions, slice(None)), :]\ntransfer_reactions = get_relevant_reaction_fluxes(transfer_reactions)\ntransfer_reactions.loc[(\"GLC_ae_gc\", 2), :] = 0\ntransfer_reactions\n\n/tmp/ipykernel_374830/4037575462.py:11: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      SUCROSE_ae_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      3\n      -0.000893\n      -0.000893\n      -0.000581\n      -0.000582\n      -0.000642\n      -0.000654\n      0.000305\n      0.000319\n    \n    \n      GLC_ae_gc\n      3\n      0.000000\n      0.000000\n      -0.000622\n      -0.000614\n      -0.000587\n      -0.000554\n      -0.000574\n      -0.000599\n    \n    \n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n  \n\n\n\n\n\ntransfer_reactions_me = [\n    reaction.id[:-2]\n    for reaction in four_stage_GC_model.reactions\n    if \"ae_me\" in reaction.id\n]\ntransfer_reactions_me = [\n    e\n    for e in transfer_reactions_me\n    if e\n    not in (\n        \"WATER_ae_me\",\n        \"K_ae_me\",\n        \"Cl_ae_me\",\n        \"NITRATE_ae_me\",\n        \"SULFATE_ae_me\",\n        \"AMMONIUM_ae_me\",\n    )\n]\ntransfer_reactions_me = get_relevant_reaction_fluxes(\n    solutions_df.loc[(transfer_reactions_me, slice(None)), :]\n)\ntransfer_reactions_me\n\n/tmp/ipykernel_374830/4037575462.py:11: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solution_df = solution_df.drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      SUCROSE_ae_me\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000305\n      -0.000319\n    \n    \n      4\n      0.001712\n      0.001712\n      0.001114\n      0.001115\n      0.001230\n      0.001253\n      0.000000\n      0.000000\n    \n    \n      GLC_ae_me\n      3\n      0.000000\n      0.000000\n      0.000622\n      0.000614\n      0.000587\n      0.000554\n      0.000574\n      0.000599\n    \n  \n\n\n\n\n\ndef adjust_for_hexose_equivalents(series_object):\n\n    hexose_equivalents = {\n        \"GLC\": 1,\n        \"SUCROSE\": 2,\n        \"FRU\": 1,\n    }\n\n    metabolite = series_object.name[0].split(\"_\")[0]\n    hexose_equivalent = hexose_equivalents[metabolite]\n\n    return series_object * hexose_equivalent\n\n\nfrom mmon_gcm.analysing import adjust_for_phases\n\n\ntransfer_reactions_me\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      SUCROSE_ae_me\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000305\n      -0.000319\n    \n    \n      4\n      0.001712\n      0.001712\n      0.001114\n      0.001115\n      0.001230\n      0.001253\n      0.000000\n      0.000000\n    \n    \n      GLC_ae_me\n      3\n      0.000000\n      0.000000\n      0.000622\n      0.000614\n      0.000587\n      0.000554\n      0.000574\n      0.000599\n    \n  \n\n\n\n\n\nme_carbon_production_consumption = (\n    transfer_reactions_me.apply(adjust_for_phases, args=[four_stage_GC_model], axis=1)\n    .apply(adjust_for_hexose_equivalents, axis=1)\n    .sum()\n    * -1\n)\nme_carbon_production_consumption\n\nLight  ATPase         Starch  \nblue   unconstrained  wt         -0.020545\n                      starchko   -0.020545\n       constrained    wt         -0.020525\n                      starchko   -0.020440\nwhite  constrained    wt         -0.021510\n                      starchko   -0.021406\nnops   constrained    wt          0.000405\n                      starchko    0.000455\ndtype: float64\n\n\n\ngc_carbon_production_consumption = (\n    transfer_reactions.loc[[\"GLC_ae_gc\", \"SUCROSE_ae_gc\"], :].apply(\n        adjust_for_phases, args=[four_stage_GC_model], axis=1\n    ).apply(adjust_for_hexose_equivalents, axis=1)\n    * -1\n)\ngc_carbon_production_consumption\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      GLC_ae_gc\n      3\n      -0.000000\n      -0.000000\n      0.007155\n      0.007062\n      0.006747\n      0.006373\n      0.006605\n      0.006886\n    \n    \n      2\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n    \n    \n      SUCROSE_ae_gc\n      2\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n      -0.000000\n    \n    \n      3\n      0.020545\n      0.020545\n      0.013370\n      0.013379\n      0.014764\n      0.015033\n      -0.007010\n      -0.007341\n    \n  \n\n\n\n\n\ngc_carbon_production_consumption_nmoles_gc = gc_carbon_production_consumption.apply(\n    convert_fluxes_to_per_guard_cell, args=[arabidopsis_supermodel, units], axis=1\n)\n\n\natp_colours = {\n    \"6PFRUCTPHOS_RXN_c_gc\": [6, 6],  # phosphofructokinase glycolysis\n    \"FRUCTOKINASE_RXN_c_gc\": [6, 6],  # fructokinase glycolysis\n    \"GLUC1PADENYLTRANS_RXN_p_gc\": [8, 8],  # glc1p -> adp glc (starch synthesis)\n    \"GLY3KIN_RXN_p_gc\": [6, 6],  # g3p -> glycerate (carbon degradation)\n    \"Mitochondrial_ATP_Synthase_m_gc\": [7, 7],  # mitochondrial atp synthase\n    \"PEPCARBOXYKIN_RXN_c_gc\": [6, 6],  # OAA -> pyruvate (mal deg)\n    \"PEPDEPHOS_RXN_c_gc\": [6, 6],  # PEP -> pyruvate\n    \"PEPDEPHOS_RXN_p_gc\": [6, 6],  # PEP -> pyruvate\n    \"PHOSGLYPHOS_RXN_c_gc\": [2, 6],  # DPG -> G3p (glycolysis)\n    \"PHOSGLYPHOS_RXN_p_gc\": [4, 4],  # DPG -> G3p (glycolysis)\n    \"PHOSPHORIBULOKINASE_RXN_p_gc\": [4, 4],  # calvin cycle\n    \"PROTONATP_rev_vc_gc\": [0, 0],  # tonoplastic proton pump\n    \"PROTON_ATPase_c_gc\": [1, 1],  # plasma membrane proton pump\n    \"Plastidial_ATP_Synthase_p_gc\": [3, 3],  # plastidial atp_synthase\n    \"SUCCCOASYN_RXN_m_gc\": [6, 6],  # TCA cycle\n    \"UDPKIN_RXN_c_gc\": [2, 2],  # atp->utp, sucrose synthesis\n    \"GLUCOKIN_RXN_c_gc\": [9, 9],\n    \"ATP_ADP_mc_gc\": [9, 9],  # ATP shuttle\n}\n\nnadh_nadph_colours = {\n    \"1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\": [3, 3],  # ps\n    \"1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\": [4, 4],  # ps\n    \"2OXOGLUTARATEDEH_RXN_m_gc\": [6, 6],  # tca\n    \"GAPOXNPHOSPHN_RXN_c_gc\": [2, 6],  # glycolysis or gluconeogenesis\n    \"GAPOXNPHOSPHN_RXN_p_gc\": [4, 4],  # calvin cycle but nadh\n    \"HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\": [5, 5],  # OH_PYR_x -> Glycerate_x to do with serine/aspartate metabolism\n    \"ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\": [6, 6],  # tca\n    \"MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\": [9, 9],  # shuttle\n    \"MALATE_DEH_RXN_c_gc\": [9, 6],  # malate degradation when forward but also shuttle in reverse\n    \"MALATE_DEH_RXN_m_gc\": [9, 9],  # can be tca but mainly shuttle\n    \"MALATE_DEH_RXN_p_gc\": [9, 9],  # shuttle\n    \"MALATE_DEH_RXN_x_gc\": [9, 9],  # shuttle\n    \"MALIC_NAD_RXN_m_gc\": [6, 6],  # malate degradation (al->pyr)\n    \"NADH_DEHYDROG_A_RXN_mi_gc\": [7, 7],  # complex 1 (TC)\n    \"PGLYCDEHYDROG_RXN_p_gc\": [5, 5],  # ser_synthesis from g3p\n    \"PYRUVDEH_RXN_m_gc\": [6, 6],  # pyruvate degradation\n    \"ISOCITDEH_RXN_c_gc\": [6, 6],  # tca nadp\n    \"6PGLUCONDEHYDROG_RXN_p_gc\": [9, 9],  # PPP\n}\n\nreaction_colours = {**atp_colours, **nadh_nadph_colours}\nfor reaction, colour_number in reaction_colours.items():\n    for i, reverse_forward in enumerate(colour_number):\n        if reverse_forward == 9:\n            reaction_colours[reaction][i] = \"#DDDDDD\"\n        else:\n            reaction_colours[reaction][i] = colours[reverse_forward]\n\n\ncolours_legend = {\n    \"Tonoplast membrane ATPase\": 0,\n    \"Plasma membrane ATPase\": 1,\n    \"Sucrose/Glucose synthesis\": 2,\n    \"Plastid/PS\": 3,\n    \"Carbon fixation\": 4,\n    \"Serine Synthesis\": 5,\n    \"Carbon degradation\\n(Glycolysis, TCA etc.)\": 6,\n    \"ETC/Mitochondrial\\nATP Synthase\": 7,\n    \"Starch synthesis\": 8,\n    \"Other e.g. shuttles\": 9,\n}\nfor category, colour_number in colours_legend.items():\n    if colour_number == 9:\n        colours_legend[category] = \"#DDDDDD\"\n    else:\n        colours_legend[category] = colours[colour_number]\n\n\ncarbon_colours = {\"SUCROSE_ae_gc\": colours[2], \"GLC_ae_gc\": colours[6], \"FRU_ae_gc\": colours[4]}\n\n\nlegend_colours = {\n    \"Glucose\": colours[6],\n    \"Sucrose\": colours[2],\n}\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      39.500551\n      39.500551\n      0.000000\n      0.000000\n    \n    \n      3\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      0.000000\n      0.000000\n    \n    \n      1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -36.271334\n      -33.502269\n      0.000000\n      0.000000\n    \n    \n      3\n      -37.187692\n      -37.187689\n      -37.127180\n      -36.905720\n      -37.122098\n      -36.978487\n      0.000000\n      0.000000\n    \n    \n      NADH_DEHYDROG_A_RXN_mi_gc\n      2\n      -6.617777\n      -6.617798\n      -4.628047\n      -3.023238\n      -4.529872\n      -4.229137\n      -3.879718\n      -3.323148\n    \n    \n      3\n      -2.193170\n      -2.193169\n      -2.333127\n      -2.568542\n      -2.321904\n      -2.522065\n      -0.438120\n      -0.537478\n    \n    \n      MALATE_DEH_RXN_m_gc\n      2\n      1.323555\n      1.323560\n      0.925610\n      1.209295\n      4.529872\n      4.229137\n      0.000000\n      0.000000\n    \n    \n      3\n      2.193170\n      2.193169\n      2.333127\n      2.568542\n      2.321904\n      2.522065\n      0.242721\n      0.272785\n    \n    \n      MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -3.229217\n      -5.998282\n      0.000000\n      0.000000\n    \n    \n      3\n      -2.312859\n      -2.312862\n      -2.373371\n      -2.594831\n      -2.378454\n      -2.522065\n      0.000000\n      0.000000\n    \n    \n      ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\n      2\n      1.323555\n      1.323560\n      0.925609\n      0.604648\n      0.000000\n      0.000000\n      1.939859\n      1.661574\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.037019\n      0.064150\n    \n    \n      2OXOGLUTARATEDEH_RXN_m_gc\n      2\n      1.323555\n      1.323560\n      0.925609\n      0.604648\n      0.000000\n      0.000000\n      1.939859\n      1.661574\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.037019\n      0.064150\n    \n    \n      PYRUVDEH_RXN_m_gc\n      2\n      1.323555\n      1.323560\n      0.925609\n      0.604648\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.121361\n      0.136392\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      2\n      -1.429293\n      -1.429383\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.969930\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.136392\n    \n    \n      MALATE_DEH_RXN_c_gc\n      2\n      1.429293\n      1.429383\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.969930\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.136392\n    \n    \n      MALIC_NAD_RXN_m_gc\n      2\n      1.323555\n      1.323560\n      0.925609\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      GAPOXNPHOSPHN_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -1.769145\n      0.000000\n      0.000000\n    \n    \n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.079190\n      0.000000\n    \n    \n      PGLYCDEHYDROG_RXN_p_gc\n      2\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      1.769145\n      0.000000\n      0.000000\n    \n    \n      MALATE_DEH_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.079190\n      0.000000\n    \n    \n      MALATE_DEH_RXN_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.076919\n      0.000000\n      0.000000\n    \n    \n      HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.076919\n      0.000000\n      0.000000\n    \n  \n\n\n\n\n\ncolor_order = [[nadh_nadph_colours[reaction][1], reaction]\n               for reaction in nadh_nadph_budget_df_reordered_nmoles_gc.index.levels[0]]\nnadh_nadph_budget_df_reordered_nmoles_gc = nadh_nadph_budget_df_reordered_nmoles_gc.loc[pd.DataFrame(\n    color_order).sort_values(by=[0, 1]).loc[:, 1].values]\n\n\ncolor_order = [[atp_colours[reaction][1], reaction]\n               for reaction in atp_budget_df_reordered_nmoles_gc.index.levels[0]]\natp_budget_df_reordered_nmoles_gc = atp_budget_df_reordered_nmoles_gc.loc[pd.DataFrame(color_order).sort_values(by=[\n    0, 1]).loc[:, 1].values]\n\n\natp_budget_df_reordered_nmoles_gc.drop(\"nops\", axis=1).loc[(\"Plastidial_ATP_Synthase_p_gc\", 3)].mean()\n\n/tmp/ipykernel_374830/544428024.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  atp_budget_df_reordered_nmoles_gc.drop(\"nops\", axis=1).loc[(\"Plastidial_ATP_Synthase_p_gc\", 3)].mean()\n\n\n50.78642316655137\n\n\n\n(abs(nadh_nadph_budget_df_reordered_nmoles_gc)/2).sum()\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          49.740791\n                      starchko    49.740902\n       constrained    wt          46.461726\n                      starchko    45.092332\nwhite  constrained    wt          85.852878\n                      starchko    87.598369\nnops   constrained    wt           5.366958\n                      starchko     3.997019\ndtype: float64\n\n\n\nnadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), :]\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n      3\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      39.500551\n      0.000000\n      0.000000\n    \n    \n      NADH_DEHYDROG_A_RXN_mi_gc\n      3\n      -2.193170\n      -2.193169\n      -2.333127\n      -2.568542\n      -2.321904\n      -2.522065\n      -0.438120\n      -0.537478\n    \n    \n      1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n      3\n      -37.187692\n      -37.187689\n      -37.127180\n      -36.905720\n      -37.122098\n      -36.978487\n      0.000000\n      0.000000\n    \n    \n      GAPOXNPHOSPHN_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.079190\n      0.000000\n    \n    \n      2OXOGLUTARATEDEH_RXN_m_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.037019\n      0.064150\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.136392\n    \n    \n      ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.037019\n      0.064150\n    \n    \n      MALATE_DEH_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.136392\n    \n    \n      PYRUVDEH_RXN_m_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.121361\n      0.136392\n    \n    \n      HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.076919\n      0.000000\n      0.000000\n    \n    \n      MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n      3\n      -2.312859\n      -2.312862\n      -2.373371\n      -2.594831\n      -2.378454\n      -2.522065\n      0.000000\n      0.000000\n    \n    \n      MALATE_DEH_RXN_m_gc\n      3\n      2.193170\n      2.193169\n      2.333127\n      2.568542\n      2.321904\n      2.522065\n      0.242721\n      0.272785\n    \n    \n      MALATE_DEH_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.079190\n      0.000000\n    \n    \n      MALATE_DEH_RXN_x_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.076919\n      0.000000\n      0.000000\n    \n  \n\n\n\n\n\nnops_nadph_3 = nadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), \"nops\"].index\n\n\ncolours_legend_iv = {v: k for k, v in colours_legend.items()}\n\n\nnops_nadph_3_df = nadh_nadph_budget_df_reordered_nmoles_gc.loc[(slice(None), 3), \"nops\"]\n\n\nnops_nadph_3\n\nMultiIndex([('1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc', 3),\n            (             'NADH_DEHYDROG_A_RXN_mi_gc', 3),\n            ('1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc', 3),\n            (                'GAPOXNPHOSPHN_RXN_p_gc', 3),\n            (             '2OXOGLUTARATEDEH_RXN_m_gc', 3),\n            (                'GAPOXNPHOSPHN_RXN_c_gc', 3),\n            ( 'ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc', 3),\n            (                   'MALATE_DEH_RXN_c_gc', 3),\n            (                     'PYRUVDEH_RXN_m_gc', 3),\n            ('HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc', 3),\n            (   'MALATE_DEHYDROGENASE_NADPs_RXN_p_gc', 3),\n            (                   'MALATE_DEH_RXN_m_gc', 3),\n            (                   'MALATE_DEH_RXN_p_gc', 3),\n            (                   'MALATE_DEH_RXN_x_gc', 3)],\n           names=['Reaction', 'Phase'])\n\n\n\nnops_nadph_3_reactions = [i[0] for i in nops_nadph_3]\n\n\ndescriptions = []\nfor reaction in nops_nadph_3_reactions:\n    descriptions.append(colours_legend_iv[nadh_nadph_colours[reaction][0]].replace(\"\\n\", \"\"))\n\n\nnops_nadph_3_df.loc[:, \"Description\"] = descriptions\n\n\nnops_nadph_3_df\n\n\n\n\n\n  \n    \n      \n      ATPase\n      constrained\n      Description\n    \n    \n      \n      Starch\n      wt\n      starchko\n      \n    \n    \n      Reaction\n      Phase\n      \n      \n      \n    \n  \n  \n    \n      1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      Plastid/PS\n    \n    \n      NADH_DEHYDROG_A_RXN_mi_gc\n      3\n      -0.438120\n      -0.537478\n      ETC/MitochondrialATP Synthase\n    \n    \n      1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      Carbon fixation\n    \n    \n      GAPOXNPHOSPHN_RXN_p_gc\n      3\n      0.079190\n      0.000000\n      Carbon fixation\n    \n    \n      2OXOGLUTARATEDEH_RXN_m_gc\n      3\n      0.037019\n      0.064150\n      Carbon degradation(Glycolysis, TCA etc.)\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      3\n      0.000000\n      0.136392\n      Sucrose/Glucose synthesis\n    \n    \n      ISOCITRATE_DEHYDROGENASE_NAD_RXN_m_gc\n      3\n      0.037019\n      0.064150\n      Carbon degradation(Glycolysis, TCA etc.)\n    \n    \n      MALATE_DEH_RXN_c_gc\n      3\n      0.000000\n      -0.136392\n      Other e.g. shuttles\n    \n    \n      PYRUVDEH_RXN_m_gc\n      3\n      0.121361\n      0.136392\n      Carbon degradation(Glycolysis, TCA etc.)\n    \n    \n      HYDROXYPYRUVATE_REDUCTASE_RXN_NAD_x_gc\n      3\n      0.000000\n      0.000000\n      Serine Synthesis\n    \n    \n      MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      Other e.g. shuttles\n    \n    \n      MALATE_DEH_RXN_m_gc\n      3\n      0.242721\n      0.272785\n      Other e.g. shuttles\n    \n    \n      MALATE_DEH_RXN_p_gc\n      3\n      -0.079190\n      0.000000\n      Other e.g. shuttles\n    \n    \n      MALATE_DEH_RXN_x_gc\n      3\n      0.000000\n      0.000000\n      Other e.g. shuttles\n    \n  \n\n\n\n\n\nmetabolites = [\"ATP\", \"NAD(P)H\"]\nphases = [\"Opening\", \"Day\"]\nhatches = {\"wt\": None, \"starchko\": \"//\"}\natpase_labelling = {\"unconstrained\": \"–\", \"constrained\": \"+\"}\n\nfig, axs = plt.subplots(3, 2, figsize=(9, 12), sharex=True, sharey=\"row\")\nplt.subplots_adjust(hspace=0.1)\n\ncolour_rectangles_thickness = 4 / (75 * 2)\n\nfor y, metabolite in enumerate(\n    [atp_budget_df_reordered_nmoles_gc, nadh_nadph_budget_df_reordered_nmoles_gc]\n):\n    for x, phase in enumerate([2, 3]):\n        budget_df = metabolite.xs(phase, level=\"Phase\")\n        ax = axs[y][x]\n\n        # if y == 0:\n        for x1, x2, colour in zip(\n            [-0.5, 3.5, 5.5], [3.5, 5.5, 7.5], [\"#004488\", \"white\", \"#DDDDDD\"]\n        ):\n            ax.fill_betweenx(\n                [75 - colour_rectangles_thickness * 75 * 2, 75],\n                x1,\n                x2,\n                alpha=1,\n                color=colour,\n                linewidth=0.5,\n                edgecolor=\"black\",\n            )\n\n        for i, scenario in enumerate(budget_df.columns):\n            positive_bottom = 0\n            negative_top = 0\n            scenario_df = budget_df.loc[:, scenario]\n            for reaction in scenario_df.index:\n                value = scenario_df.loc[reaction]\n                if value > 0.00001:\n                    ax.bar(\n                        i,\n                        value,\n                        bottom=positive_bottom,\n                        color=reaction_colours[reaction][1],\n                        linewidth=0.1,\n                        hatch=hatches[scenario[2]],\n                    )\n                    positive_bottom += value\n                elif value < 0.00001:\n                    ax.bar(\n                        i,\n                        value,\n                        bottom=negative_top,\n                        color=reaction_colours[reaction][0],\n                        linewidth=0.1,\n                        hatch=hatches[scenario[2]],\n                    )\n                    negative_top += value\n\n        # ax.text(i, positive_bottom + 0.005, round(positive_bottom, 6), rotation=90)\n        ax.set_xticks([])  # range(len(budget_df.columns)))\n        ax.set_xticklabels(\n            []\n        )  # [atpase_labelling[scenario[1]] for scenario in budget_df.columns])\n\n        # if y==1:\n        for x1, x2 in zip([-0.4, 1.6], [1.4, 7.4]):  # lines above atpase text\n            ax.hlines(-75, x1, x2, color=\"black\", linewidth=3, clip_on=False)\n\n        \"\"\"    \n        atpase_text_y = -80\n        if y==1:\n            ax.text(0.5, atpase_text_y, \"Un-\", ha=\"center\", va=\"top\", size=\"x-large\")\n            ax.text(4.5, atpase_text_y, \"Constrained\", ha=\"center\", va=\"top\", size=\"x-large\")\n            if x == 0:\n                ax.text(-0.7, atpase_text_y, \"ATPase\", ha=\"right\", va=\"top\", size=\"x-large\")\n        \"\"\"\n\n        if y == 0:\n            ax.set_title(phases[x], pad=10)\n        if x == 0:\n            ax.set_ylabel(metabolites[y])\n\n        ax.set_xlim(-0.70, 7.7)\n        ax.set_ylim(-70, 75)\n        ax.spines[\"bottom\"].set_visible(False)\n        ax.spines[\"left\"].set_bounds(-70, 70)\n        # ax.xaxis.set_major_locator(MultipleLocator(1))\n        ax.yaxis.set_major_locator(MultipleLocator(35))\n        # ax.yaxis.set_minor_locator(AutoMinorLocator(2))\n\n        ax.hlines(0, -0.5, 7.5, color=\"black\", linewidth=0.5)\n\nfig.text(\n    -0.02,\n    0.66,\n    r\"Rate of production/consumption of energy\"\n    \"\\n\"\n    \"and reducing power (fmol$\\cdot$GC$^{-1}\\cdot$h$^{-1}$)\",\n    rotation=90,\n    va=\"center\",\n    ha=\"center\",\n    size=\"large\",\n)\n# ax.set_title(f\"ATP Phase {phase}\", pad=70)\n\npatchList = []\nfor key in colours_legend:\n    data_key = mpatches.Patch(color=colours_legend[key], label=key)\n    patchList.append(data_key)\n\nfig.legend(handles=patchList, loc=\"center left\", bbox_to_anchor=(0.925, 0.63))\n\n\nfor x, ax in enumerate(axs[2]):\n\n    phase = [2, 3][x]\n\n    y_lim_for_hexose = 49\n\n    for x1, x2, colour in zip(\n        [-0.5, 3.5, 5.5], [3.5, 5.5, 7.5], [\"#004488\", \"white\", \"#DDDDDD\"]\n    ):\n        ax.fill_betweenx(\n            [y_lim_for_hexose - y_lim_for_hexose * colour_rectangles_thickness, y_lim_for_hexose],\n            x1,\n            x2,\n            alpha=1,\n            color=colour,\n            linewidth=0.5,\n            edgecolor=\"black\",\n        )\n\n    for i, scenario in enumerate(gc_carbon_production_consumption_nmoles_gc.columns):\n        positive_bottom = 0\n        negative_top = 0\n        scenario_df = gc_carbon_production_consumption_nmoles_gc.xs(\n            phase, level=\"Phase\"\n        ).loc[:, scenario]\n        for reaction in scenario_df.index:\n            value = scenario_df.loc[reaction]\n            if value > 0.00001:\n                ax.bar(\n                    i,\n                    value,\n                    bottom=positive_bottom,\n                    color=carbon_colours[reaction],\n                    linewidth=0.1,\n                    hatch=hatches[scenario[2]],\n                    align=\"edge\",\n                    width=-0.4,\n                )\n                positive_bottom += value\n            elif value < 0.00001:\n                ax.bar(\n                    i,\n                    abs(value),\n                    bottom=negative_top,\n                    color=carbon_colours[reaction],\n                    linewidth=0.1,\n                    hatch=hatches[scenario[2]],\n                    align=\"edge\",\n                    width=0.4,\n                )\n                negative_top += abs(value)\n        if positive_bottom == 0:\n            ax.bar(\n                i,\n                0.3,\n                bottom=0,\n                color=carbon_colours[reaction],\n                linewidth=0.1,\n                hatch=hatches[scenario[2]],\n                align=\"edge\",\n                width=-0.4,\n            )\n        if negative_top == 0:\n            ax.bar(\n                i,\n                0.3,\n                bottom=0,\n                color=carbon_colours[reaction],\n                linewidth=0.1,\n                hatch=hatches[scenario[2]],\n                align=\"edge\",\n                width=0.4,\n            )\n\n        # ax.text(\n        #    i - 0.2, positive_bottom + 1.5, \"+\", ha=\"center\", va=\"center\", size=\"large\"\n        # )\n        if positive_bottom > 0:\n            ax.text(\n                i - 0.2, positive_bottom + 1.5, f\"+{round(positive_bottom, 2)}\", ha=\"center\", va=\"bottom\", size=\"x-small\", rotation=90\n            )\n        #ax.text(i + 0.2, negative_top + 1.5, \"-\", ha=\"center\", va=\"center\", size=\"large\")\n        if negative_top > 0:\n            ax.text(\n                i + 0.2, negative_top + 1.5, f\"–{abs(round(negative_top, 2))}\", ha=\"center\", va=\"bottom\", size=\"x-small\", rotation=90\n            )\n        if positive_bottom > 0 and negative_top > 0:\n            net_value = round(positive_bottom-negative_top, 2)\n            if net_value < 0:\n                ax.text(\n                    i-0.1, 25, f\"–{abs(net_value)}\", ha=\"center\", va=\"center\", size=\"x-small\"\n                )\n            else:\n                ax.text(\n                    i-0.1, 25, f\"{net_value}\", ha=\"center\", va=\"center\", size=\"x-small\"\n                )\n        if phase == 3:\n            ax.text(\n                6.5, 27, \"Net:\", ha=\"center\", va=\"bottom\", size=\"small\", weight=\"normal\"\n            )\n\n        starch_condition = {\"wt\": \"WT\", \"starchko\": \"KO\"}[scenario_df.name[2]]\n        ax.text(i, -1.5, starch_condition, ha=\"center\", va=\"center\", size=\"small\")\n\n    # ax.hlines(0, -0.5, 7.5, color=\"black\", linewidth=0.5)\n\n    patchList = []\n    for key in legend_colours:\n        data_key = mpatches.Patch(color=legend_colours[key], label=key)\n        patchList.append(data_key)\n\n    if x == 1:\n        ax.legend(handles=patchList, loc=\"center left\", bbox_to_anchor=(1.1, 0.5))\n\n    for x1, x2 in zip([-0.4, 1.6], [1.4, 7.4]):  # lines above atpase text\n        ax.hlines(-3, x1, x2, color=\"black\", linewidth=3, clip_on=False)\n\n    atpase_text_y = -3.5\n    ax.text(0.5, atpase_text_y, \"Un-\", ha=\"center\", va=\"top\", size=\"x-large\")\n    ax.text(4.5, atpase_text_y, \"Constrained\", ha=\"center\", va=\"top\", size=\"x-large\")\n    if x == 0:\n        ax.text(-0.7, atpase_text_y, \"ATPase\", ha=\"right\", va=\"top\", size=\"x-large\")\n\n    ax.set_xlim(-0.7, 7.7)\n    ax.set_ylim(-0.1, y_lim_for_hexose)\n    ax.spines[\"bottom\"].set_visible(False)\n    ax.spines[\"left\"].set_bounds(0, 40)\n    ax.set_xticks([])  # range(len(budget_df.columns)))\n    ax.set_xticklabels(\n        []\n    )  # [atpase_labelling[scenario[1]] for scenario in budget_df.columns])\n\n    ax.hlines(0, -0.5, 7.5, color=\"black\", linewidth=0.5)\n\n    if x == 0:\n        ax.set_ylabel(\n            \"Hexose equivalents \\n exported (+) or imported (–) \\n by GC during phase \\n\"\n            r\"(fmol$\\cdot$GC$^{-1}$)\",\n            labelpad=15,\n        )\n\ni = 0\nfor y in range(3):\n    for x in range(2):\n        ax = axs[y][x]\n        letter = string.ascii_uppercase[i]\n        if x == 0:\n            ax.text(-0.2, 0.92, letter, size=\"x-large\", transform=ax.transAxes)\n        elif x == 1:\n            ax.text(-0.1, 0.92, letter, size=\"x-large\", transform=ax.transAxes)\n        i += 1\n\n\n# fig.text(-0.02,0.25, \"Hexose equivalents imported (+) \\n or exported (-) by GC \" r\"(nmoles$\\cdot$GC$^{-1}$)\", rotation=90, va=\"center\", ha=\"center\", size=\"large\")\n\nfig.savefig(\n    f\"../plant_cell_paper/figure_6.svg\", bbox_inches=\"tight\"\n)\nfig.savefig(\n    f\"../plant_cell_paper/figure_6.png\", dpi=300, bbox_inches=\"tight\"\n)\n\n\n\n\n\ncarbon_rank = gc_carbon_production_consumption_nmoles_gc.sum().rank(ascending=False)\n\n\natp_2_rank = abs(atp_budget_df_reordered_nmoles_gc).xs(2, level=\"Phase\").sum().rank(ascending=False)\natp_3_rank = abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\").sum().rank(ascending=False)\natp_rank = (abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\")*0.5 +\n            abs(atp_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\")*11.5).sum().rank(ascending=False)\n\n\nnad_2_rank = abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(2, level=\"Phase\").sum().rank(ascending=False)\nnad_3_rank = abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\").sum().rank(ascending=False)\nnad_rank = (abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\")*0.5 +\n            abs(nadh_nadph_budget_df_reordered_nmoles_gc).xs(3, level=\"Phase\")*11.5).sum().rank(ascending=False)\n\n\npd.concat([carbon_rank, atp_2_rank, atp_3_rank, atp_rank, nad_2_rank, nad_3_rank, nad_rank], axis=1,\n          keys=[\"Carbon\", \"ATP 2\", \"ATP 3\", \"ATP Day\", \"NAD 2\", \"NAD 3\", \"NAD Day\"]).sort_values(\"Carbon\")\n\n\n\n\n\n  \n    \n      \n      \n      \n      Carbon\n      ATP 2\n      ATP 3\n      ATP Day\n      NAD 2\n      NAD 3\n      NAD Day\n    \n    \n      Light\n      ATPase\n      Starch\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      white\n      constrained\n      wt\n      1.0\n      1.0\n      4.0\n      4.0\n      2.0\n      4.0\n      4.0\n    \n    \n      starchko\n      2.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      1.0\n    \n    \n      blue\n      unconstrained\n      starchko\n      3.0\n      3.0\n      6.0\n      6.0\n      3.0\n      6.0\n      6.0\n    \n    \n      wt\n      4.0\n      4.0\n      5.0\n      5.0\n      4.0\n      5.0\n      5.0\n    \n    \n      constrained\n      wt\n      5.0\n      6.0\n      3.0\n      3.0\n      6.0\n      3.0\n      3.0\n    \n    \n      starchko\n      6.0\n      8.0\n      1.0\n      1.0\n      8.0\n      2.0\n      2.0\n    \n    \n      nops\n      constrained\n      wt\n      7.0\n      5.0\n      8.0\n      8.0\n      5.0\n      8.0\n      8.0\n    \n    \n      starchko\n      8.0\n      7.0\n      7.0\n      7.0\n      7.0\n      7.0\n      7.0\n    \n  \n\n\n\n\n\nStarch KO leads to lower carbon consumption and higher ATP and NAD turnover\nConstraining ATPase leads to lower efficiency and higher ATP and NAD turnover\nPS is more complicated because it’s both phases, so won’t include\n\nRemoving it vs blue eads to"
  },
  {
    "objectID": "2.2_analysingsolutions.html#bits-and-bobs-for-paper",
    "href": "2.2_analysingsolutions.html#bits-and-bobs-for-paper",
    "title": "Analysing solutions",
    "section": "Bits and bobs for paper",
    "text": "Bits and bobs for paper\n\nblue_constrained_wt_osmolytes = met_df_mm.loc[:, (\"blue\", \"constrained\", \"wt\", \"fluxes\")].unstack()\nos_fraction = (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]) / (\n    blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).sum() * 100\nos_fraction\n\nReaction\nCIT        1.573448e-12\nCl         2.683538e+01\nFRU        0.000000e+00\nGLC        5.126735e+01\nK          2.577402e+01\nMAL       -3.863739e+00\nSTARCH    -1.300909e-02\nSUCROSE    0.000000e+00\ndtype: float64\n\n\n\nblue_constrained_wt_osmolytes\n\n\n\n\n\n  \n    \n      Reaction\n      CIT\n      Cl\n      FRU\n      GLC\n      K\n      MAL\n      STARCH\n      SUCROSE\n    \n    \n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      0.0\n      -1.576202e-12\n      17.792012\n      0.0\n      -8.322345e-12\n      22.233377\n      8.119376\n      0.007155\n      -1.588203e-11\n    \n    \n      6.0\n      -8.653558e-13\n      17.792012\n      0.0\n      -8.322345e-12\n      22.233377\n      8.119376\n      0.007155\n      0.000000e+00\n    \n    \n      6.5\n      -2.581520e-28\n      32.550776\n      0.0\n      2.819572e+01\n      36.408419\n      5.994419\n      0.000000\n      0.000000e+00\n    \n    \n      18.0\n      0.000000e+00\n      17.792012\n      0.0\n      0.000000e+00\n      22.233377\n      8.119376\n      0.007155\n      -1.564578e-11\n    \n    \n      24.0\n      -1.576202e-12\n      17.792012\n      0.0\n      -8.322345e-12\n      22.233377\n      8.119376\n      0.007155\n      -1.588203e-11\n    \n  \n\n\n\n\n\nos_fraction.loc[\"Cl\"]+os_fraction.loc[\"K\"]\n\n52.609396448638556\n\n\n\n(blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).loc[\"Cl\"] + \\\n    (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).loc[\"K\"]\n\n28.93380608398066\n\n\n\nsolutions_df\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      ...\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      ...\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      ...\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      \n      Solution\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      ...\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      EX_X_pi_t_me\n      1\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      2\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      3\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      4\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      EX_X_pi_t_gc\n      1\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      Cl_total_pseudolinker\n      4\n      4.899985e-03\n      NaN\n      NaN\n      4.900221e-03\n      NaN\n      NaN\n      3.921359e-03\n      NaN\n      NaN\n      5.414718e-18\n      ...\n      NaN\n      -7.081374e-16\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      -5.299512e-19\n      NaN\n      NaN\n    \n    \n      CIT_total_pseudolinker\n      1\n      0.000000e+00\n      -3.311882e-15\n      0.010896\n      -2.565624e-17\n      0.0\n      0.010896\n      -1.907244e-16\n      0.000000e+00\n      0.010896\n      1.321796e-19\n      ...\n      0.010896\n      -1.208859e-32\n      0.0\n      0.010896\n      0.000563\n      0.0\n      0.010896\n      4.818565e-04\n      0.0\n      0.010896\n    \n    \n      2\n      2.448218e-16\n      0.000000e+00\n      0.011386\n      0.000000e+00\n      0.0\n      0.011386\n      -6.550608e-32\n      2.449103e-16\n      0.011386\n      0.000000e+00\n      ...\n      0.011386\n      3.448298e-18\n      0.0\n      0.011386\n      0.000000\n      0.0\n      0.011386\n      0.000000e+00\n      0.0\n      0.009961\n    \n    \n      3\n      2.221401e-16\n      NaN\n      NaN\n      -7.845672e-18\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -1.948321e-17\n      NaN\n      NaN\n      0.000563\n      NaN\n      NaN\n      4.818565e-04\n      NaN\n      NaN\n    \n    \n      4\n      2.221401e-16\n      NaN\n      NaN\n      -2.411683e-17\n      NaN\n      NaN\n      -3.473949e-16\n      NaN\n      NaN\n      7.238173e-20\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000563\n      NaN\n      NaN\n      4.818565e-04\n      NaN\n      NaN\n    \n  \n\n7101 rows × 36 columns\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\n    \"K_ec_gc\", 2), :] + solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Cl_PROTON_ec_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.024387\n                      starchko    0.024387\n       constrained    wt          0.013015\n                      starchko    0.013015\nwhite  unconstrained  wt          0.023240\n                      starchko    0.023240\n       constrained    wt          0.013015\n                      starchko    0.013015\nnops   unconstrained  wt          0.023345\n                      starchko    0.023345\n       constrained    wt          0.013015\n                      starchko    0.013015\ndtype: float64\n\n\n\n0.013015/0.024387*100\n\n53.36859802353714\n\n\n\nblue_constrained_starcko_osmolytes = met_df_mm.loc[:, (\"blue\", \"constrained\", \"starchko\", \"fluxes\")].unstack()\nos_fraction = (blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]) / (\n    blue_constrained_wt_osmolytes.loc[6.5] - blue_constrained_wt_osmolytes.loc[6.0]).sum() * 100\nos_fraction\n\nReaction\nCIT        1.573448e-12\nCl         2.683538e+01\nFRU        0.000000e+00\nGLC        5.126735e+01\nK          2.577402e+01\nMAL       -3.863739e+00\nSTARCH    -1.300909e-02\nSUCROSE    0.000000e+00\ndtype: float64\n\n\n\nblue_constrained_wt_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n  \n    \n      Reaction\n      CIT\n      Cl\n      FRU\n      GLC\n      K\n      MAL\n      STARCH\n      SUCROSE\n    \n    \n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      6.0\n      -8.653558e-13\n      17.792012\n      0.0\n      -8.322345e-12\n      22.233377\n      8.119376\n      0.007155\n      0.0\n    \n    \n      6.5\n      -2.581520e-28\n      32.550776\n      0.0\n      2.819572e+01\n      36.408419\n      5.994419\n      0.000000\n      0.0\n    \n  \n\n\n\n\n\nblue_constrained_wt_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n  \n    \n      Reaction\n      CIT\n      Cl\n      FRU\n      GLC\n      K\n      MAL\n      STARCH\n      SUCROSE\n    \n    \n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      6.0\n      -8.653558e-13\n      17.792012\n      0.0\n      -8.322345e-12\n      22.233377\n      8.119376\n      0.007155\n      0.0\n    \n    \n      6.5\n      -2.581520e-28\n      32.550776\n      0.0\n      2.819572e+01\n      36.408419\n      5.994419\n      0.000000\n      0.0\n    \n  \n\n\n\n\n\nblue_constrained_starcko_osmolytes.loc[[6, 6.5]]\n\n\n\n\n\n  \n    \n      Reaction\n      CIT\n      Cl\n      FRU\n      GLC\n      K\n      MAL\n      STARCH\n      SUCROSE\n    \n    \n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      6.0\n      5.997260e-16\n      2.456769e-14\n      -0.000001\n      0.000000\n      22.233378\n      5.303941\n      0.0\n      3.203986e+01\n    \n    \n      6.5\n      0.000000e+00\n      1.709714e+01\n      27.828905\n      27.828905\n      36.408419\n      3.915824\n      0.0\n      -5.356596e-14\n    \n  \n\n\n\n\n\n27.828905*2\n\n55.65781\n\n\n\nmet_df.loc[:, (\"white\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n/tmp/ipykernel_374830/1419630875.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  met_df.loc[:, (\"white\", \"constrained\")].xs(\"fluxes\", level=\"Solution\", axis=1).loc[([6.0, 6.5], \"STARCH\"), :]\n\n\n\n\n\n\n  \n    \n      \n      Starch\n      wt\n      starchko\n    \n    \n      Phase\n      Reaction\n      \n      \n    \n  \n  \n    \n      6.0\n      STARCH\n      0.006747\n      0.0\n    \n    \n      6.5\n      STARCH\n      0.000000\n      0.0\n    \n  \n\n\n\n\n\n(0.006747 * 10 ** -3/arabidopsis_supermodel.N_gcs) * 10 ** 15\n\n11.632758620689657\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_ATPase_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.008129\n                      starchko    0.008129\n       constrained    wt          0.004338\n                      starchko    0.004338\nwhite  unconstrained  wt          0.007747\n                      starchko    0.007747\n       constrained    wt          0.004338\n                      starchko    0.004338\nnops   unconstrained  wt          0.007963\n                      starchko    0.007963\n       constrained    wt          0.004338\n                      starchko    0.004338\nName: (PROTON_ATPase_c_gc, 2), dtype: float64\n\n\n\nsolutions_df\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      ...\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      ...\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      ...\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      \n      Solution\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      ...\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n      fluxes\n      minimum\n      maximum\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      EX_X_pi_t_me\n      1\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      2\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      3\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      4\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      EX_X_pi_t_gc\n      1\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      Cl_total_pseudolinker\n      4\n      4.899985e-03\n      NaN\n      NaN\n      4.900221e-03\n      NaN\n      NaN\n      3.921359e-03\n      NaN\n      NaN\n      5.414718e-18\n      ...\n      NaN\n      -7.081374e-16\n      NaN\n      NaN\n      0.000000\n      NaN\n      NaN\n      -5.299512e-19\n      NaN\n      NaN\n    \n    \n      CIT_total_pseudolinker\n      1\n      0.000000e+00\n      -3.311882e-15\n      0.010896\n      -2.565624e-17\n      0.0\n      0.010896\n      -1.907244e-16\n      0.000000e+00\n      0.010896\n      1.321796e-19\n      ...\n      0.010896\n      -1.208859e-32\n      0.0\n      0.010896\n      0.000563\n      0.0\n      0.010896\n      4.818565e-04\n      0.0\n      0.010896\n    \n    \n      2\n      2.448218e-16\n      0.000000e+00\n      0.011386\n      0.000000e+00\n      0.0\n      0.011386\n      -6.550608e-32\n      2.449103e-16\n      0.011386\n      0.000000e+00\n      ...\n      0.011386\n      3.448298e-18\n      0.0\n      0.011386\n      0.000000\n      0.0\n      0.011386\n      0.000000e+00\n      0.0\n      0.009961\n    \n    \n      3\n      2.221401e-16\n      NaN\n      NaN\n      -7.845672e-18\n      NaN\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000000e+00\n      ...\n      NaN\n      -1.948321e-17\n      NaN\n      NaN\n      0.000563\n      NaN\n      NaN\n      4.818565e-04\n      NaN\n      NaN\n    \n    \n      4\n      2.221401e-16\n      NaN\n      NaN\n      -2.411683e-17\n      NaN\n      NaN\n      -3.473949e-16\n      NaN\n      NaN\n      7.238173e-20\n      ...\n      NaN\n      0.000000e+00\n      NaN\n      NaN\n      0.000563\n      NaN\n      NaN\n      4.818565e-04\n      NaN\n      NaN\n    \n  \n\n7101 rows × 36 columns\n\n\n\n\npm_proton_pump = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTONATP_rev_vc_gc\", 2), :]\nfor value in pm_proton_pump.values:\n    print('{0:.10f}'.format(value))\n\n0.0036702884\n0.0036702049\n0.0052175915\n0.0019039819\n-0.0000000002\n0.0000000007\n0.0000327323\n0.0000000000\n0.0058439202\n0.0058439202\n0.0058439202\n0.0041422750\n\n\n\ntonoplast_proton_pump = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_PPi_rev_vc_gc\", 2), :]\ntonoplast_proton_pump\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000622\n                      starchko    0.000622\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.009596\n                      starchko    0.009596\n       constrained    wt          0.009862\n                      starchko    0.009716\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nName: (PROTON_PPi_rev_vc_gc, 2), dtype: float64\n\n\n\n(pm_proton_pump + tonoplast_proton_pump).plot.bar()\n\n<Axes: xlabel='Light,ATPase,Starch'>\n\n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PHOSGLYPHOS_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          8.289899e-04\n                      starchko    8.290422e-04\n       constrained    wt         -2.906954e-10\n                      starchko    9.122828e-10\nwhite  unconstrained  wt          0.000000e+00\n                      starchko    0.000000e+00\n       constrained    wt          0.000000e+00\n                      starchko    0.000000e+00\nnops   unconstrained  wt         -7.247574e-04\n                      starchko   -7.247574e-04\n       constrained    wt         -5.625591e-04\n                      starchko    0.000000e+00\nName: (PHOSGLYPHOS_RXN_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"2PGADEHYDRAT_RXN_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt         -8.289899e-04\n                      starchko   -8.290422e-04\n       constrained    wt          2.906983e-10\n                      starchko   -9.122828e-10\nwhite  unconstrained  wt         -8.965687e-04\n                      starchko   -8.965681e-04\n       constrained    wt         -7.543795e-04\n                      starchko    0.000000e+00\nnops   unconstrained  wt          7.247574e-04\n                      starchko    7.247574e-04\n       constrained    wt          5.625591e-04\n                      starchko    0.000000e+00\nName: (2PGADEHYDRAT_RXN_c_gc, 2), dtype: float64\n\n\nMALATE_DEH_RXN_c_gc## Fraction is ATPase vs PPi for tonoplast\n\npm_proton_pump / (pm_proton_pump + tonoplast_proton_pump) * 100\n\nLight  ATPase         Starch  \nblue   unconstrained  wt           85.514028\n                      starchko     85.512964\n       constrained    wt          100.000000\n                      starchko    100.000000\nwhite  unconstrained  wt           -0.000002\n                      starchko      0.000007\n       constrained    wt            0.330800\n                      starchko      0.000000\nnops   unconstrained  wt          100.000000\n                      starchko    100.000000\n       constrained    wt          100.000000\n                      starchko    100.000000\ndtype: float64\n\n\n\nplastidatp_reactions = [reaction.id[:-2]\n                        for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_p_gc_2.reactions]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 2), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) < 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/3663876372.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      ATP_ADP_Pi_pc_gc\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      -0.001723\n      -0.001743\n      0.0\n      0.0\n    \n    \n      PHOSPHORIBULOKINASE_RXN_p_gc\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.010141\n      0.010742\n      0.0\n      0.0\n    \n    \n      PHOSGLYPHOS_RXN_p_gc\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.021037\n      0.020457\n      0.0\n      0.0\n    \n    \n      Plastidial_ATP_Synthase_p_gc\n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.009819\n      0.009819\n      0.0\n      0.0\n    \n  \n\n\n\n\n\nplastidatp_reactions = [reaction.id[:-2]\n                        for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_p_gc_2.reactions]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) < 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/3680442761.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      PEPDEPHOS_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000046\n      0.0\n    \n    \n      ATP_ADP_Pi_pc_gc\n      3\n      -0.002932\n      -0.002932\n      -0.003478\n      -0.002659\n      -0.003443\n      -0.002737\n      -0.000167\n      0.0\n    \n    \n      GLUC1PADENYLTRANS_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000622\n      0.000000\n      0.000587\n      0.000000\n      0.000259\n      0.0\n    \n    \n      PHOSPHORIBULOKINASE_RXN_p_gc\n      3\n      0.010819\n      0.010819\n      0.010779\n      0.010710\n      0.010782\n      0.010701\n      0.000000\n      0.0\n    \n    \n      PHOSGLYPHOS_RXN_p_gc\n      3\n      0.021569\n      0.021569\n      0.021534\n      0.021405\n      0.021531\n      0.021448\n      -0.000046\n      0.0\n    \n    \n      Plastidial_ATP_Synthase_p_gc\n      3\n      0.009819\n      0.009819\n      0.009819\n      0.009819\n      0.009819\n      0.009819\n      0.000000\n      0.0\n    \n    \n      GLY3KIN_RXN_p_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000045\n      0.000000\n      0.0\n    \n  \n\n\n\n\n\nplastidatp_reactions = [reaction.id[:-2]\n                        for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_3.reactions]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) < 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/861862047.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      PEPCARBOXYKIN_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000024\n      0.000000\n    \n    \n      PROTON_ATPase_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000305\n      0.000319\n    \n    \n      FRUCTOKINASE_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000614\n      0.000000\n      0.000499\n      0.000328\n      0.000599\n    \n    \n      ATP_ADP_Pi_pc_gc\n      3\n      -0.002932\n      -0.002932\n      -0.003478\n      -0.002659\n      -0.003443\n      -0.002737\n      -0.000167\n      0.000000\n    \n    \n      UDPKIN_RXN_c_gc\n      3\n      0.000884\n      0.000884\n      0.000581\n      0.001196\n      0.000597\n      0.001152\n      0.000023\n      0.000280\n    \n    \n      PEPDEPHOS_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000024\n      0.000079\n    \n    \n      PHOSGLYPHOS_RXN_c_gc\n      3\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n      -0.000079\n    \n    \n      ATP_ADP_mc_gc\n      3\n      0.003816\n      0.003816\n      0.004060\n      0.004469\n      0.004040\n      0.004388\n      0.000822\n      0.001039\n    \n  \n\n\n\n\n\nplastidatp_reactions = [reaction.id[:-2]\n                        for reaction in arabidopsis_supermodel.fba_model.metabolites.NADPH_p_gc_2.reactions]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 3), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) < 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/3683469779.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      1_PERIOD_2_PERIOD_1_PERIOD_13_RXN_p_gc\n      3\n      0.021569\n      0.021569\n      0.021534\n      0.021405\n      0.021531\n      0.021448\n      0.0\n      0.0\n    \n    \n      1_PERIOD_18_PERIOD_1_PERIOD_2_RXN_p_gc\n      3\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.022910\n      0.0\n      0.0\n    \n    \n      MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\n      3\n      0.001341\n      0.001341\n      0.001377\n      0.001505\n      0.001380\n      0.001463\n      0.0\n      0.0\n    \n  \n\n\n\n\n\nplastidatp_reactions = [reaction.id[:-2]\n                        for reaction in arabidopsis_supermodel.fba_model.metabolites.NADH_c_gc_2.reactions]\nplastidatp_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(plastidatp_reactions, 2), :]\nplastidatp_df = plastidatp_df.loc[~(abs(plastidatp_df) < 0.0000000001).all(axis=1)]\nplastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/2230598337.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  plastidatp_df.mask(abs(plastidatp_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      MALATE_DEH_RXN_c_gc\n      2\n      0.000829\n      0.000829\n      -2.906954e-10\n      9.122828e-10\n      0.0\n      0.0\n      -0.000563\n      0.0\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      2\n      -0.000829\n      -0.000829\n      2.906954e-10\n      -9.122828e-10\n      0.0\n      0.0\n      0.000563\n      0.0\n    \n  \n\n\n\n\n\n0.003478-0.002659\n\n0.0008190000000000003\n\n\n\n0.020457+0.010742\n\n0.031198999999999998\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PROTON_ATPase_c_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.008129\n                      starchko    0.008129\n       constrained    wt          0.004338\n                      starchko    0.004338\nwhite  unconstrained  wt          0.007747\n                      starchko    0.007747\n       constrained    wt          0.004338\n                      starchko    0.004338\nnops   unconstrained  wt          0.007963\n                      starchko    0.007963\n       constrained    wt          0.004338\n                      starchko    0.004338\nName: (PROTON_ATPase_c_gc, 2), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"MALATE_DEHYDROGENASE_NADPs_RXN_p_gc\", 2), :]\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nwhite  unconstrained  wt          0.002544\n                      starchko    0.002544\n       constrained    wt          0.001873\n                      starchko    0.003479\nnops   unconstrained  wt          0.000000\n                      starchko    0.000000\n       constrained    wt          0.000000\n                      starchko    0.000000\nName: (MALATE_DEHYDROGENASE_NADPs_RXN_p_gc, 2), dtype: float64\n\n\n\nfig, ax = plt.subplots()\n\ntonoplast_proton_transport_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\ntonoplast_proton_transport_df.index = [\"PPi Pump\", \"ATPase Pump\"]\ntonoplast_proton_transport_df.T.plot(kind='bar', stacked=True, ax=ax)\n\nax.set_ylabel(\"Flux (mmoles$\\cdot$m$^{-2}$$\\cdot$h$^{-1}$)\")\n\n/tmp/ipykernel_374830/2314583387.py:3: PerformanceWarning: indexing past lexsort depth may impact performance.\n  tonoplast_proton_transport_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n\n\nText(0, 0.5, 'Flux (mmoles$\\\\cdot$m$^{-2}$$\\\\cdot$h$^{-1}$)')\n\n\n\n\n\n\ntonoplast_proton_transport_df\n\n\n\n\n\n  \n    \n      Light\n      blue\n      white\n      nops\n    \n    \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n  \n  \n    \n      PPi Pump\n      0.000622\n      0.000622\n      0.000000\n      0.000000\n      0.009862\n      0.009716\n      0.000000\n      0.000000\n    \n    \n      ATPase Pump\n      0.003670\n      0.003670\n      0.005218\n      0.001904\n      0.000033\n      0.000000\n      0.005844\n      0.004142\n    \n  \n\n\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1).sum().plot.bar()\n\n/tmp/ipykernel_374830/3027342076.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[([\"PROTON_PPi_rev_vc_gc\", \"PROTONATP_rev_vc_gc\"], 2), :].drop(\n\n\n<Axes: xlabel='Light,ATPase,Starch'>\n\n\n\n\n\n\nppi_reactions = [reaction.id[:-2]\n                 for reaction in arabidopsis_supermodel.fba_model.metabolites.PPI_c_gc_2.reactions]\nppi_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(ppi_reactions, 2), :]\nppi_df = ppi_df.loc[~(abs(ppi_df) < 0.0000000001).all(axis=1)]\nppi_df.mask(abs(ppi_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/3140086841.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  ppi_df.mask(abs(ppi_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2_PERIOD_7_PERIOD_1_PERIOD_90_RXN_c_gc\n      2\n      -0.000414\n      -0.000415\n      0.0\n      0.0\n      -0.008828\n      -0.008438\n      0.0\n      0.0\n    \n    \n      GLUC1PURIDYLTRANS_RXN_c_gc\n      2\n      0.000207\n      0.000207\n      0.0\n      0.0\n      0.001034\n      0.001277\n      0.0\n      0.0\n    \n    \n      PROTON_PPi_rev_vc_gc\n      2\n      0.000622\n      0.000622\n      0.0\n      0.0\n      0.009862\n      0.009716\n      0.0\n      0.0\n    \n  \n\n\n\n\n\nppi_reactions = [reaction.id[:-2]\n                 for reaction in arabidopsis_supermodel.fba_model.metabolites.PPI_p_gc_2.reactions]\nppi_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(ppi_reactions, 2), :]\nppi_df = ppi_df.loc[~(abs(ppi_df) < 0.0000000001).all(axis=1)]\nppi_df.mask(abs(ppi_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/2145986697.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  ppi_df.mask(abs(ppi_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n  \n\n\n\n\n\nboundary_reactions = [reaction.id[:-2]\n                      for reaction in arabidopsis_supermodel.fba_model.reactions if \"_tx\" in reaction.id]\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_a_tx\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      NITRATE_a_tx\n      1\n      0.018952\n      0.018952\n      0.018952\n      0.018952\n      0.019835\n      0.019835\n      0.019835\n      0.019835\n      0.019831\n      0.019831\n      0.019831\n      0.019831\n    \n    \n      2\n      0.056855\n      0.056855\n      0.056855\n      0.056855\n      0.251324\n      0.251324\n      0.251324\n      0.251324\n      0.251274\n      0.251274\n      0.251274\n      0.251274\n    \n    \n      3\n      0.307408\n      0.307408\n      0.307408\n      0.307408\n      0.313542\n      0.313542\n      0.313542\n      0.313541\n      0.313480\n      0.313480\n      0.313479\n      0.313479\n    \n    \n      4\n      0.012861\n      0.012861\n      0.012861\n      0.012861\n      0.013183\n      0.013183\n      0.013183\n      0.013183\n      0.013181\n      0.013181\n      0.013181\n      0.013181\n    \n  \n\n\n\n\n\nfrom mmon_gcm.analysing import get_phase_lengths\n\n\nphase_lengths = get_phase_lengths(arabidopsis_supermodel.fba_model)\nphase_lengths\n\n[6.0, 0.5, 11.5, 6.0]\n\n\n\nfor i, phase_length in zip([1, 2, 3, 4], phase_lengths):\n    nitrate_uptake.loc[(\"NITRATE_a_tx\", i), :] = nitrate_uptake.loc[(\"NITRATE_a_tx\", i), :] * phase_length\nnitrate_uptake\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      NITRATE_a_tx\n      1\n      0.113710\n      0.113710\n      0.113710\n      0.113710\n      0.119010\n      0.119010\n      0.119010\n      0.119010\n      0.118987\n      0.118987\n      0.118987\n      0.118987\n    \n    \n      2\n      0.028428\n      0.028428\n      0.028428\n      0.028428\n      0.125662\n      0.125662\n      0.125662\n      0.125662\n      0.125637\n      0.125637\n      0.125637\n      0.125637\n    \n    \n      3\n      3.535195\n      3.535195\n      3.535194\n      3.535191\n      3.605729\n      3.605729\n      3.605728\n      3.605724\n      3.605016\n      3.605016\n      3.605006\n      3.605004\n    \n    \n      4\n      0.077167\n      0.077167\n      0.077167\n      0.077167\n      0.079101\n      0.079101\n      0.079101\n      0.079101\n      0.079085\n      0.079085\n      0.079085\n      0.079085\n    \n  \n\n\n\n\n\nnitrate_uptake_day = nitrate_uptake.loc[(slice(None), [2, 3]), :].sum()\nnitrate_uptake_night = nitrate_uptake.loc[(slice(None), [1, 4]), :].sum()\n\n\nnitrate_uptake_day\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          3.563623\n                      starchko    3.563623\n       constrained    wt          3.563621\n                      starchko    3.563619\nwhite  unconstrained  wt          3.731391\n                      starchko    3.731391\n       constrained    wt          3.731390\n                      starchko    3.731386\nnops   unconstrained  wt          3.730653\n                      starchko    3.730653\n       constrained    wt          3.730643\n                      starchko    3.730641\ndtype: float64\n\n\n\nnitrate_uptake_night\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.190877\n                      starchko    0.190877\n       constrained    wt          0.190877\n                      starchko    0.190877\nwhite  unconstrained  wt          0.198111\n                      starchko    0.198111\n       constrained    wt          0.198111\n                      starchko    0.198111\nnops   unconstrained  wt          0.198072\n                      starchko    0.198072\n       constrained    wt          0.198071\n                      starchko    0.198071\ndtype: float64\n\n\n\nnitrate_uptake_day/nitrate_uptake_night\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          18.669741\n                      starchko    18.669741\n       constrained    wt          18.669741\n                      starchko    18.669741\nwhite  unconstrained  wt          18.834845\n                      starchko    18.834845\n       constrained    wt          18.834845\n                      starchko    18.834845\nnops   unconstrained  wt          18.834845\n                      starchko    18.834845\n       constrained    wt          18.834845\n                      starchko    18.834845\ndtype: float64\n\n\n\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_a_Linker\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      NITRATE_a_Linker\n      1\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      3\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      4\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n\n\n\n\nnitrate_uptake = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"NITRATE_ae_me\", slice(None)), :]\nnitrate_uptake\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      NITRATE_ae_me\n      1\n      0.018952\n      0.018952\n      0.018952\n      0.018952\n      0.019835\n      0.019835\n      0.019835\n      0.019835\n      0.019831\n      0.019831\n      0.019831\n      0.019831\n    \n    \n      2\n      0.056855\n      0.056855\n      0.056855\n      0.056855\n      0.251324\n      0.251324\n      0.251324\n      0.251324\n      0.251274\n      0.251274\n      0.251274\n      0.251274\n    \n    \n      3\n      0.307408\n      0.307408\n      0.307408\n      0.307408\n      0.313542\n      0.313542\n      0.313542\n      0.313541\n      0.313480\n      0.313480\n      0.313479\n      0.313479\n    \n    \n      4\n      0.012861\n      0.012861\n      0.012861\n      0.012861\n      0.013183\n      0.013183\n      0.013183\n      0.013183\n      0.013181\n      0.013181\n      0.013181\n      0.013181\n    \n  \n\n\n\n\n\narabidopsis_supermodel.fba_model.metabolites.NITRATE_e_gc_2\n\n\n\n        \n            \n                Metabolite identifierNITRATE_e_gc_2\n            \n                NameNITRATE_gc_2\n            \n                Memory address\n                0x7f49b8b345e0\n            \n                FormulaN1O3\n            \n                Compartmente\n            \n                In 2 reaction(s)\n                    Nitrate_ec_gc_2, NITRATE_ae_gc_2\n                    \n            \n        \n\n\n\nfiltered_reactions = [reaction.id[:-2]\n                      for reaction in arabidopsis_supermodel.fba_model.metabolites.NADH_c_gc_2.reactions]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) < 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/2420179439.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  filtered_df.mask(abs(filtered_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      MALATE_DEH_RXN_c_gc\n      2\n      0.000829\n      0.000829\n      -2.906954e-10\n      9.122828e-10\n      0.0\n      0.0\n      -0.000563\n      0.0\n    \n    \n      GAPOXNPHOSPHN_RXN_c_gc\n      2\n      -0.000829\n      -0.000829\n      2.906954e-10\n      -9.122828e-10\n      0.0\n      0.0\n      0.000563\n      0.0\n    \n  \n\n\n\n\n\nfiltered_reactions = [reaction.id[:-2]\n                      for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_2.reactions]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) < 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) < 0.0000000001, 0).drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")], axis=1)\n\n/tmp/ipykernel_374830/1610886466.py:5: PerformanceWarning: indexing past lexsort depth may impact performance.\n  filtered_df.mask(abs(filtered_df) < 0.0000000001, 0).drop(\n\n\n\n\n\n\n  \n    \n      \n      Light\n      blue\n      white\n      nops\n    \n    \n      \n      ATPase\n      unconstrained\n      constrained\n      constrained\n      constrained\n    \n    \n      \n      Starch\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Reaction\n      Phase\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      PROTON_ATPase_c_gc\n      2\n      0.008129\n      0.008129\n      4.338400e-03\n      4.338400e-03\n      0.004338\n      0.004338\n      0.004338\n      0.004338\n    \n    \n      UDPKIN_RXN_c_gc\n      2\n      0.000207\n      0.000207\n      0.000000e+00\n      0.000000e+00\n      0.001034\n      0.001277\n      0.000000\n      0.000000\n    \n    \n      ATP_ADP_Pi_pc_gc\n      2\n      0.000000\n      0.000000\n      0.000000e+00\n      0.000000e+00\n      -0.001723\n      -0.001743\n      0.000000\n      0.000000\n    \n    \n      PEPDEPHOS_RXN_c_gc\n      2\n      0.000000\n      0.000000\n      2.906983e-10\n      3.506957e-04\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      PHOSGLYPHOS_RXN_c_gc\n      2\n      0.000829\n      0.000829\n      -2.906954e-10\n      9.122828e-10\n      0.000000\n      0.000000\n      -0.000563\n      0.000000\n    \n    \n      PROTONATP_rev_vc_gc\n      2\n      0.003670\n      0.003670\n      5.217592e-03\n      1.903982e-03\n      0.000033\n      0.000000\n      0.005844\n      0.004142\n    \n    \n      6PFRUCTPHOS_RXN_c_gc\n      2\n      0.000000\n      0.000000\n      1.453477e-10\n      -4.561414e-10\n      0.000000\n      0.000000\n      0.000281\n      0.000000\n    \n    \n      FRUCTOKINASE_RXN_c_gc\n      2\n      0.000000\n      0.000000\n      0.000000e+00\n      -4.561414e-10\n      0.000000\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      PEPCARBOXYKIN_RXN_c_gc\n      2\n      0.000829\n      0.000829\n      0.000000e+00\n      3.506966e-04\n      0.000754\n      0.000000\n      0.000000\n      0.000000\n    \n    \n      ATP_ADP_mc_gc\n      2\n      0.013664\n      0.013664\n      9.555991e-03\n      6.242383e-03\n      0.007882\n      0.007359\n      0.009901\n      0.008481\n    \n  \n\n\n\n\n\nfiltered_reactions = [reaction.id[:-2]\n                      for reaction in arabidopsis_supermodel.fba_model.metabolites.ATP_c_gc_2.reactions]\nfiltered_df = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(filtered_reactions, 2), :]\nfiltered_df = filtered_df.loc[~(abs(filtered_df) < 0.0000000001).all(axis=1)]\nfiltered_df.mask(abs(filtered_df) < 0.0000000001, 0).loc[:, (\"white\", \"constrained\", \"wt\")]\n\nReaction                Phase\nPROTON_ATPase_c_gc      2        0.004338\nUDPKIN_RXN_c_gc         2        0.001034\nATP_ADP_Pi_pc_gc        2       -0.001723\nPEPDEPHOS_RXN_c_gc      2        0.000000\nPHOSGLYPHOS_RXN_c_gc    2        0.000000\nPROTONATP_rev_vc_gc     2        0.000033\n6PFRUCTPHOS_RXN_c_gc    2        0.000000\nFRUCTOKINASE_RXN_c_gc   2        0.000000\nPEPCARBOXYKIN_RXN_c_gc  2        0.000754\nATP_ADP_mc_gc           2        0.007882\nName: (white, constrained, wt), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n    [(\"white\", \"unconstrained\"), (\"nops\", \"unconstrained\")])\n\n/tmp/ipykernel_374830/990213441.py:1: PerformanceWarning: indexing past lexsort depth may impact performance.\n  solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"PEPCARBOXYKIN_RXN_c_gc\", 2), :].drop(\n\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          0.000829\n                      starchko    0.000829\n       constrained    wt          0.000000\n                      starchko    0.000351\nwhite  constrained    wt          0.000754\n                      starchko    0.000000\nnops   constrained    wt          0.000000\n                      starchko    0.000000\nName: (PEPCARBOXYKIN_RXN_c_gc, 2), dtype: float64\n\n\n\nphloem_outputs = solutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Phloem_tx_overall\", np.nan), :]\n\n\nphloem_outputs\n\nLight  ATPase         Starch  \nblue   unconstrained  wt          15.179976\n                      starchko    15.179976\n       constrained    wt          15.179970\n                      starchko    15.179958\nwhite  unconstrained  wt          15.887536\n                      starchko    15.887536\n       constrained    wt          15.887530\n                      starchko    15.887515\nnops   unconstrained  wt          15.884392\n                      starchko    15.884392\n       constrained    wt          15.884351\n                      starchko    15.884343\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs_dict = {}\nfor name, value in phloem_outputs.items():\n    phloem_outputs_dict[name] = (phloem_outputs/value * 100).round(3)\n\n\nphloem_outputs_comparison_table = pd.DataFrame.from_dict(phloem_outputs_dict)\nphloem_outputs_comparison_table.to_csv(\"../outputs/efficiency_comparisons/phloem_outputs_compare.csv\")\nphloem_outputs_comparison_table\n\n\n\n\n\n  \n    \n      \n      \n      \n      blue\n      white\n      nops\n    \n    \n      \n      \n      \n      unconstrained\n      constrained\n      unconstrained\n      constrained\n      unconstrained\n      constrained\n    \n    \n      \n      \n      \n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n      wt\n      starchko\n    \n    \n      Light\n      ATPase\n      Starch\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      blue\n      unconstrained\n      wt\n      100.000\n      100.000\n      100.000\n      100.000\n      95.546\n      95.546\n      95.546\n      95.547\n      95.565\n      95.565\n      95.566\n      95.566\n    \n    \n      starchko\n      100.000\n      100.000\n      100.000\n      100.000\n      95.546\n      95.546\n      95.546\n      95.547\n      95.565\n      95.565\n      95.566\n      95.566\n    \n    \n      constrained\n      wt\n      100.000\n      100.000\n      100.000\n      100.000\n      95.546\n      95.546\n      95.546\n      95.547\n      95.565\n      95.565\n      95.566\n      95.566\n    \n    \n      starchko\n      100.000\n      100.000\n      100.000\n      100.000\n      95.546\n      95.546\n      95.546\n      95.546\n      95.565\n      95.565\n      95.565\n      95.566\n    \n    \n      white\n      unconstrained\n      wt\n      104.661\n      104.661\n      104.661\n      104.661\n      100.000\n      100.000\n      100.000\n      100.000\n      100.020\n      100.020\n      100.020\n      100.020\n    \n    \n      starchko\n      104.661\n      104.661\n      104.661\n      104.661\n      100.000\n      100.000\n      100.000\n      100.000\n      100.020\n      100.020\n      100.020\n      100.020\n    \n    \n      constrained\n      wt\n      104.661\n      104.661\n      104.661\n      104.661\n      100.000\n      100.000\n      100.000\n      100.000\n      100.020\n      100.020\n      100.020\n      100.020\n    \n    \n      starchko\n      104.661\n      104.661\n      104.661\n      104.661\n      100.000\n      100.000\n      100.000\n      100.000\n      100.020\n      100.020\n      100.020\n      100.020\n    \n    \n      nops\n      unconstrained\n      wt\n      104.640\n      104.640\n      104.640\n      104.641\n      99.980\n      99.980\n      99.980\n      99.980\n      100.000\n      100.000\n      100.000\n      100.000\n    \n    \n      starchko\n      104.640\n      104.640\n      104.640\n      104.641\n      99.980\n      99.980\n      99.980\n      99.980\n      100.000\n      100.000\n      100.000\n      100.000\n    \n    \n      constrained\n      wt\n      104.640\n      104.640\n      104.640\n      104.640\n      99.980\n      99.980\n      99.980\n      99.980\n      100.000\n      100.000\n      100.000\n      100.000\n    \n    \n      starchko\n      104.640\n      104.640\n      104.640\n      104.640\n      99.980\n      99.980\n      99.980\n      99.980\n      100.000\n      100.000\n      100.000\n      100.000\n    \n  \n\n\n\n\n\n100-99.980\n\n0.01999999999999602\n\n\n\nphloem_outputs_blue = phloem_outputs.loc[\"blue\"]\nphloem_outputs_blue / phloem_outputs_blue.iloc[0] * 100\n\nATPase         Starch  \nunconstrained  wt          100.000000\n               starchko    100.000000\nconstrained    wt           99.999963\n               starchko     99.999883\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs_white = phloem_outputs.drop(\"blue\")\nphloem_outputs_white = phloem_outputs_white / phloem_outputs_white.iloc[0] * 100\nphloem_outputs_white\n\n/tmp/ipykernel_374830/3118140255.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  phloem_outputs_white = phloem_outputs.drop(\"blue\")\n\n\nLight  ATPase         Starch  \nwhite  unconstrained  wt          100.000000\n                      starchko    100.000000\n       constrained    wt           99.999957\n                      starchko     99.999863\nnops   unconstrained  wt           99.980210\n                      starchko     99.980210\n       constrained    wt           99.979949\n                      starchko     99.979901\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nphloem_outputs.drop(\"blue\")\n\n/tmp/ipykernel_374830/4124221444.py:1: PerformanceWarning: dropping on a non-lexsorted multi-index without a level parameter may impact performance.\n  phloem_outputs.drop(\"blue\")\n\n\nLight  ATPase         Starch  \nwhite  unconstrained  wt          15.887536\n                      starchko    15.887536\n       constrained    wt          15.887530\n                      starchko    15.887515\nnops   unconstrained  wt          15.884392\n                      starchko    15.884392\n       constrained    wt          15.884351\n                      starchko    15.884343\nName: (Phloem_tx_overall, nan), dtype: float64\n\n\n\nsolutions_df.xs(\"fluxes\", level=\"Solution\", axis=1).loc[(\"Phloem_tx_overall\", np.nan), :].plot.bar()\n\n<Axes: xlabel='Light,ATPase,Starch'>"
  },
  {
    "objectID": "functions/solving.html",
    "href": "functions/solving.html",
    "title": "solving",
    "section": "",
    "text": "source\n\npfba_Weighted\n\n pfba_Weighted (model, weightings=None, fraction_of_optimum=1.0,\n                objective=None, reactions=None)\n\nPerform basic pFBA (parsimonious Enzyme Usage Flux Balance Analysis) to minimize total flux. pFBA [1] adds the minimization of all fluxes the the objective of the model. This approach is motivated by the idea that high fluxes have a higher enzyme turn-over and that since producing enzymes is costly, the cell will try to minimize overall flux while still maximizing the original objective function, e.g. the growth rate.\n\nParameters:\nmodel : cobra.Model The model fraction_of_optimum : float, optional Fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than maximal_value * fraction_of_optimum. objective : dict or model.problem.Objective A desired objective to use during optimization in addition to the pFBA objective. Dictionaries (reaction as key, coefficient as value) can be used for linear objectives. reactions : iterable List of reactions or reaction identifiers. Implies return_frame to be true. Only return fluxes for the given reactions. Faster than fetching all fluxes if only a few are needed.\n\n\nReturns:\ncobra.Solution\nThe solution object to the optimized model with pFBA constraints added.\nReferences: .. [1] Lewis, N. E., Hixson, K. K., Conrad, T. M., Lerman, J. A., Charusanti, P., Polpitiya, A. D., Palsson, B. O. (2010). Omic data from evolved E. coli are consistent with computed optimal growth from genome-scale models. Molecular Systems Biology, 6, 390. doi:10.1038/msb.2010.47\n\nsource\n\n\n\nadd_pfba_Weighted\n\n add_pfba_Weighted (model, weightings=None, objective=None,\n                    fraction_of_optimum=1.0)\n\nThis function is a modified version of cobrapy add_pfba function\nAdd pFBA objective Add objective to minimize the summed flux of all reactions to the current objective.\nSee Also: pfba\nParameters: model : cobra.Model The model to add the objective to objective : An objective to set in combination with the pFBA objective. fraction_of_optimum : float Fraction of optimum which must be maintained. The original objective reaction is constrained to be greater than maximal_value * fraction_of_optimum.\n\nsource\n\n\nget_weightings\n\n get_weightings (model)\n\nThis function is used by pfba_weighted to generate default weightings for the guard cell model It takes the model as an argument and returns the weightings based on the phase lengths of the model.\n\nsource\n\n\npFBA_FVA_run\n\n pFBA_FVA_run (cobra_model, obj, rxnlist=[], processes=3,\n               fix_sof_for_fva=False)\n\n\nsource\n\n\nget_sum_of_fluxes\n\n get_sum_of_fluxes (model)\n\n\nsource\n\n\nrev2irrev\n\n rev2irrev (cobra_model)\n\nFunction to convert any model with reversible reactions to a copy of the same m- -odel with only irreversible reactions. ID of reverse reactions are generated by suffixing “_reverse” to the ID of the orignal reaction. args: 1) a cobra model output: a cobra model with only irreversible reactions\n\nsource\n\n\ncheck_fba_fva_run\n\n check_fba_fva_run (fba_model, pfba_solution)\n\nThis is a test that checks if the fluxes that are returned by the fba model are different to those by the pFBA\n\nsource\n\n\nget_pfba_fva_solution\n\n get_pfba_fva_solution (fba_model, rxn_list=[],\n                        objective='Phloem_tx_overall', processes=3,\n                        fix_sof_for_fva=False)\n\nTake FBA model and solve weighted FVA on a list of reactions. Returns a dataframe with flux of all reactions and minimum and maximum if they were in the fva list"
  },
  {
    "objectID": "functions/supermodel.html",
    "href": "functions/supermodel.html",
    "title": "supermodel",
    "section": "",
    "text": "From Hills et al. (2012): > $ VT = $ (16)\nwhere:\n\\(VT\\) is the total volume of the guard cell\n\\(C_{apo}\\) is the sum of osmolarity in the apoplast.\n$ q = n - m s / r $\nwhere n, m, s and r are empirical parameters\n\\(R\\) is the ideal gas constant\n\\(T\\) is temperature\n$ p = m/r $\nQT is total osmolarity of the guard cell\nThey also provide a relationship between volume and aperture:\n$ A_s = (VT - s)/r $ (17)\nAs we want a way to calculate total osmolarity from aperture we can rearrange (and just say VT is V and QT is Q) to get:\n$ V = A_s r + s $\nand:\n$ Q = (( + C_{apo} + )^2 - (C_{apo} + )^2) $\n\nsource\n\nSuperModel\n\n SuperModel (parameters, fba_model=None)\n\nThe supermodel class is a class that includes the FBA model object as well as all the parameters used to constrain it. It provides methods to constrain the FBA model\n\nsource\n\n\nSuperModel.get_volumes\n\n SuperModel.get_volumes (apertures='default', printouts=False,\n                         per_guard_cell=True)\n\nReturns a list containing the volume of the guard cells, in dm\\(^3\\), at each phase, calculated using the OnGuard equation\nHere the default is for per_guard_cell to be True, meaning that the list that is returned is a volume per individual cell, however setting this to false will return the colume of guard cell within the 1m\\(^2\\) of leaf being simulated.\n\nsource\n\n\nSuperModel.get_osmolarities\n\n SuperModel.get_osmolarities (apertures='default', equation='onguard',\n                              printouts=False)\n\nCalculates the osmolarities at each phase of the model using the equation specified, default is onguard. Adds these as an attribute to the SuperModel\n\nsource\n\n\nSuperModel.constrain_osmolarity\n\n SuperModel.constrain_osmolarity (apertures='default', printouts=False,\n                                  osequation='onguard')\n\nThis method constrains the fba_model of the supermodel using osmolarities calculated using SuperModel.get_osmolarities\n\nsource\n\n\nSuperModel.get_prop_gc\n\n SuperModel.get_prop_gc (printouts=False)\n\nThis method returns the proportion of the volume of the leaf that is guard cells\n\nsource\n\n\nSuperModel.get_photons\n\n SuperModel.get_photons (PPFD, printouts=False)\n\nThis method constrains photon influx into the model in accordance with the equation outlined in the documentation\n\nsource\n\n\nSuperModel.constrain_photons\n\n SuperModel.constrain_photons (PPFD, printouts=False)\n\nThis method constrains the fba_model of the supermodel using osmolarities calculated using SuperModel.get_osmolarities\n\nsource\n\n\nSuperModel.add_maintenance\n\n SuperModel.add_maintenance (me=True, gc=False)\n\nThis function constrains the maintenance reactions in the model relative to the input of photons into the model."
  },
  {
    "objectID": "functions/buildingediting.html",
    "href": "functions/buildingediting.html",
    "title": "buildingediting",
    "section": "",
    "text": "source\n\nadd_metabolite\n\n add_metabolite (model, name, compartment='default', multi=True)\n\nThis function adds a metabolite to the given model, and returns this metabolite. If multi is set to true it will be added to every phase of the model.\n\nsource\n\n\nadd_reaction\n\n add_reaction (model, name, multi=True)\n\nThis function adds a reaction to the given model, and returns this reaction. If multi is set to true it will be added to every phase of the model.\n\nsource\n\n\nsplit_model\n\n split_model (model, labels)\n\nThis function takes two arguments: the model to be split and the labels for the models to split it into. len(labels) number of models will be created, with the suffix “_label” to define them.\n\nsource\n\n\ncheck_number_of_models\n\n check_number_of_models (model)\n\nThis function returns the number of phases of the model based on the maximal number of the last tag\n\nsource\n\n\nset_bounds_multi\n\n set_bounds_multi (model, reaction_id, lower_flux, upper_flux)\n\nConstrain a reaction’s flux in all phases\n\nsource\n\n\nadd_linkers\n\n add_linkers (model, linkers_file, compartments, cells, phase_times)\n\nThis function adds linker reactions for osmolytes to a phased model of guard cell, and adds osmolarity and charge linker pseudoreactions. It takes five arguments: model: the model to which linkers are to be added linkersfile: a .csv file with a list of osmolytes and their osmotic coefficients, leave the osmotic coefficient at 0 to add as a linker but not contribute to osmolarity compartments: a list of the compartments to add linker reactions to within cells cells: a list of cell tags to be used phase_times: a list of the lengths of each phase, for scaling of the linker reactions\n\nsource\n\n\ndef_linkers\n\n def_linkers (file)\n\nThis function creates a dict of osmolytes and their osmotic coefficients from the .csv file, and is used by addlinkers\n\nsource\n\n\nadd_metabolites_to_reaction_multi\n\n add_metabolites_to_reaction_multi (model, reaction, metabolites_dict)\n\nThis function adds a dictionary of metabolites to a reaction in every phase of the model"
  },
  {
    "objectID": "functions/constraintscan.html",
    "href": "functions/constraintscan.html",
    "title": "constraintscan",
    "section": "",
    "text": "source\n\nnormalise_within_bounds\n\n normalise_within_bounds (constraint_series, parameter_df)\n\n\nsource\n\n\ngenerate_constraints_df\n\n generate_constraints_df (constraints_df, params_df)\n\nThis functions takes a list of constraints along with a dataframe that contains the bounds for the parameters that these constraints should apply to It uses the bounds from the dataframe with the values from the constraints_list to generate a dataframe of constraints for running a constraint scan\n\nsource\n\n\nsolve_model_for_constraint_scan\n\n solve_model_for_constraint_scan (constraints, fba_model, light_colour,\n                                  printouts=False)"
  },
  {
    "objectID": "functions/osmolyteconstraints.html",
    "href": "functions/osmolyteconstraints.html",
    "title": "osmolyteconstraints",
    "section": "",
    "text": "def constrainosmolytelevels(model, osmolytelevels):\n    closedphaseos = model.osmolarities[0]/model.getvolumes(perguardcell = False)[0]\n\n    totallevel = 0\n    for osmolytelevel in osmolytelevels.values():\n        totallevel += osmolytelevel[0][1]\n    scaling_closed = closedphaseos/totallevel\n\n    openphaseos = model.osmolarities[1]/model.getvolumes(perguardcell = False)[1]\n\n    totallevel = 0\n    for osmolytelevel in osmolytelevels.values():\n        totallevel += osmolytelevel[1][1]\n    scaling_open = openphaseos/totallevel\n\n    print(scaling_closed, scaling_open)\n    \n    osmolytelevel_scaled = copy.deepcopy(osmolytelevels)\n\n    for osmolytelevel in osmolytelevel_scaled.values():\n        osmolytelevel[0][1] = osmolytelevel[0][1]*scaling_closed\n        osmolytelevel[1][1] = osmolytelevel[1][1]*scaling_open\n        osmolytelevel[0][1] = osmolytelevel[1][1] # IMPORTANT LINE ignores scaling closed\n\n    otherlist = []\n    skipother = [\"aMAL\", \"STARCH\"]\n\n    for reaction in model.model.reactions:\n        if \"gc_Linker_1\" in reaction.id:\n            osmolytename = \"_\".join(reaction.id.split(\"_\")[:-4])\n            if osmolytename in skipother:\n                continue\n            other = True\n            if osmolytename in osmolytelevel_scaled:\n                other = False\n            if other == True:\n                otherlist.append(osmolytename)\n    for osmolyte, concentration in osmolytelevel_scaled.items():\n\n        if osmolyte == \"Other\":\n            for other in otherlist:\n                try:\n                    constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(other + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n                    constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(other + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[0][0],\n                        ub=concentration[0][1]) for phase in [1,3,4]]\n                except:\n                    constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n                    constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(other + \"_v_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[0][0],\n                        ub=concentration[0][1]) for phase in [1,3,4]]\n                for constraint in constraints_open+constraints_closed:\n                    model.model.add_cons_vars(constraint)\n\n        elif osmolyte == \"MAL\":\n            constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(\"a\" + osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n            constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(\"a\" + osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                lb=concentration[0][0],\n                ub=concentration[0][1]) for phase in [1,3,4]]\n            for constraint in constraints_open+constraints_closed:\n                model.model.add_cons_vars(constraint)\n\n        else:\n            constraints_open = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                        lb=concentration[1][0],\n                        ub=concentration[1][1]) for phase in [2]]\n            constraints_closed = [model.model.problem.Constraint((model.model.reactions.get_by_id(osmolyte + \"_v_gc_Linker_\" + str(phase)).flux_expression+model.model.reactions.get_by_id(osmolyte + \"_c_gc_Linker_\" + str(phase)).flux_expression)/model.getvolumes(perguardcell = False)[phase-1],\n                lb=concentration[0][0],\n                ub=concentration[0][1]) for phase in [1,3,4]]\n            for constraint in constraints_open+constraints_closed:\n                model.model.add_cons_vars(constraint)"
  },
  {
    "objectID": "functions/helper.html",
    "href": "functions/helper.html",
    "title": "Helper functions",
    "section": "",
    "text": "source\n\nconvert_true_false\n\n convert_true_false (true_false)"
  },
  {
    "objectID": "functions/alternativemodes.html",
    "href": "functions/alternativemodes.html",
    "title": "alternativemodes",
    "section": "",
    "text": "source\n\nget_real_reaction_ids\n\n get_real_reaction_ids (model)\n\nThis function takes a COBRApy model object and returns a list of reaction ids without phase tags that are considered to be ‘real’, excluding reactions that combine others, constraint pseudoreactions, boundary reactions.\n\nsource\n\n\nsolve_model_with_weightings\n\n solve_model_with_weightings (weightings, model, temp_results_path)"
  },
  {
    "objectID": "functions/analysing.html",
    "href": "functions/analysing.html",
    "title": "Analysing",
    "section": "",
    "text": "source\n\nget_phase_times\n\n get_phase_times (model)\n\n\nsource\n\n\nget_phase_length\n\n get_phase_length (model, phase)\n\n\nsource\n\n\nget_phase_lengths\n\n get_phase_lengths (model)\n\n\nsource\n\n\nadjust_for_phases\n\n adjust_for_phases (series_object, model)\n\n\nsource\n\n\nget_only_gc_opening\n\n get_only_gc_opening (df)\n\n\nsource\n\n\nget_pearson\n\n get_pearson (df)\n\n\nsource\n\n\nget_solution_dfs\n\n get_solution_dfs (light, atpase_constrained, starch_knockout,\n                   outputs_path, cutoff_flux=1e-08)\n\n\nsource\n\n\ncheck_for_missing\n\n check_for_missing (reaction_list, map_path)\n\n\nsource\n\n\nget_escher_map\n\n get_escher_map (model_solution, map='inputs/map.json',\n                 json_model='models/4_stage_GC.json', **kwargs)\n\n\nsource\n\n\nget_difference_biggest_to_smallest\n\n get_difference_biggest_to_smallest (row)\n\n\nsource\n\n\nreplace_with_1_0\n\n replace_with_1_0 (value, threshold)\n\n\nsource\n\n\nget_adjacency\n\n get_adjacency (df, threshold)\n\n\nsource\n\n\nget_percentage_difference_df\n\n get_percentage_difference_df (pfba_df, averages_df)\n\n\nsource\n\n\nget_difference_map\n\n get_difference_map (percentage_difference_df, map_path, json_model)\n\n\nsource\n\n\nget_pfba_pathways_map\n\n get_pfba_pathways_map (subgraph_list, map_path, json_model)"
  },
  {
    "objectID": "3.2_run_constraint_scan.html",
    "href": "3.2_run_constraint_scan.html",
    "title": "Running Constraint Scan",
    "section": "",
    "text": "This notebook can either be run as a notebook, or using nbdev a python script is produced that can be run in the command line for easier running on e.g. a cluster. It is a notebook in the nbs directory and exported as a .py file in the mmon-gcm library.\n\n# This cell isn't exported to the .py file, so define here if running in notebook rather than as .py on e.g.a cluster\n# This is also where to change whether the light is blue or white if you want to run in the notebook\n\nsys.argv = [\"script_name\",\n            \"../outputs/constraint_scan/constraint_scan_results_test.csv\",\n            \"../models/4_stage_GC.json\",\n            \"../outputs/constraint_scan/constraints_df.csv\",\n            \"white\",\n            \"2\"]\n\nIf you are running from notebook you’ll want to comment out the next cell! It’s here so that running nbdev tests doesn’t take too long, as they test running the entire notebook. It won’t be exported so running as a script will be fine\n\ntest == True\nconstraints = constraints.iloc[:10]  # so tests don't take too long\n\n\nconstraints.head()\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      R\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n    \n  \n  \n    \n      0\n      0.917691\n      0.000197\n      1.0\n      8.232099e-13\n      0.837376\n      0.121362\n      0.363686\n      0.124395\n      0.797331\n      293.291212\n      0.08205\n      4.756498e+08\n      1.829932\n      0.855492\n      7.521823e-14\n      2.682773e-13\n      0.025900\n      2.654215\n      7.513602\n      7.951997\n    \n    \n      1\n      0.881261\n      0.000228\n      1.0\n      2.907333e-12\n      0.851060\n      0.068245\n      0.348204\n      0.170261\n      0.792009\n      291.698522\n      0.08205\n      7.267261e+08\n      2.194335\n      0.853219\n      5.213651e-14\n      2.848145e-13\n      0.027046\n      3.830202\n      8.080839\n      15.837257\n    \n    \n      2\n      0.872031\n      0.000178\n      1.0\n      8.784094e-13\n      0.816784\n      0.156438\n      0.249827\n      0.130194\n      0.780852\n      285.335460\n      0.08205\n      1.037300e+09\n      2.439880\n      0.901650\n      5.550787e-14\n      2.612669e-13\n      0.026224\n      2.944908\n      6.051611\n      8.357127\n    \n    \n      3\n      0.945186\n      0.000172\n      1.0\n      1.031566e-12\n      0.841661\n      0.150717\n      0.298125\n      0.213744\n      0.794230\n      292.230971\n      0.08205\n      7.231671e+08\n      1.651735\n      0.911739\n      5.112495e-14\n      2.598802e-13\n      0.027432\n      3.084081\n      11.954409\n      8.384843\n    \n    \n      4\n      0.873152\n      0.000203\n      1.0\n      1.748335e-12\n      0.829433\n      0.144234\n      0.342282\n      0.149424\n      0.823567\n      286.040989\n      0.08205\n      2.877316e+08\n      2.056712\n      0.840618\n      7.458150e-14\n      1.908111e-13\n      0.035754\n      1.926858\n      10.939009\n      7.600877"
  },
  {
    "objectID": "4.1_generate_alternative_flux_modes_matrix.html",
    "href": "4.1_generate_alternative_flux_modes_matrix.html",
    "title": "Alternative Flux Modes",
    "section": "",
    "text": "import random\n\nimport cobra\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom mmon_gcm.alternativemodes import get_real_reaction_ids\nfrom mmon_gcm.solving import get_weightings\nLooking for alternative solutions using the method for accounting for enzyme costs outlined in Cheung et al. (2015). From the methods section:\nThe steps required for implementing the method are therefore: 1. Generate an matrix of n x m random weightings from a uniform distribution between 0 and 1, where n is the number of solutions required and m is the number of reactions in each phase of the model. 2. For each row of the matrix, combine these weightings with the phase-scaled weightings necessary as the phases are different lengths. 3. For each row of weightings, solve the model using pFBA 4. Take the average of all of the rows to give the averaged flux solution\nThis notebook includes steps 1 and 2, producing a .csv file with the matrix. Notebook 5.2 runs step 3 and 4, producing one .csv with all solutions and another with the averaged solution. The averaged solutions for this paper are then analysed in Notebook 5.3."
  },
  {
    "objectID": "4.1_generate_alternative_flux_modes_matrix.html#create-matrix-using-just-real-reactions",
    "href": "4.1_generate_alternative_flux_modes_matrix.html#create-matrix-using-just-real-reactions",
    "title": "Alternative Flux Modes",
    "section": "Create matrix using just ‘real’ reactions",
    "text": "Create matrix using just ‘real’ reactions\nRather than having different random weightings for the same reaction in each phase, we want the same random weighting. We also don’t want to count flux for reactions that aren’t ‘real’ like pseudoreactions, aggregator reactions, and boundary reactions. So first we generate a matrix of random numbers for just those reactions, not including the phasing:\n\nreal_reaction_ids = get_real_reaction_ids(model)\n\n\nm = len(real_reaction_ids)\nn = 1000\n\n\nnp.random.seed(314)\nrandom_matrix = np.random.random_sample((n, m))\nrandom_matrix_df = pd.DataFrame(random_matrix)\nrandom_matrix_df.columns = real_reaction_ids\nrandom_matrix_df\n\n\n\n\n\n  \n    \n      \n      PRO_PROTON_vc_me\n      PRO_PROTON_vc_gc\n      H2O_xc_me\n      H2O_xc_gc\n      sCIT_biomass_me\n      sCIT_biomass_gc\n      ACETYLGLUTKIN_RXN_p_me\n      ACETYLGLUTKIN_RXN_p_gc\n      2KG_OAA_mc_me\n      2KG_OAA_mc_gc\n      ...\n      aMAL_v_gc_Linker\n      STARCH_p_gc_Linker\n      STARCH_p_me_Linker\n      SUCROSE_total_pseudolinker\n      GLC_total_pseudolinker\n      MAL_total_pseudolinker\n      FRU_total_pseudolinker\n      K_total_pseudolinker\n      Cl_total_pseudolinker\n      CIT_total_pseudolinker\n    \n  \n  \n    \n      0\n      0.916874\n      0.588542\n      0.265048\n      0.783205\n      0.918001\n      0.827355\n      0.727951\n      0.260480\n      0.911763\n      0.260757\n      ...\n      0.256249\n      0.849630\n      0.036859\n      0.352452\n      0.165891\n      0.527951\n      0.514265\n      0.573895\n      0.943229\n      0.787065\n    \n    \n      1\n      0.837431\n      0.869500\n      0.251766\n      0.851621\n      0.807844\n      0.207134\n      0.166586\n      0.491988\n      0.613055\n      0.610856\n      ...\n      0.190224\n      0.484610\n      0.660262\n      0.944763\n      0.689011\n      0.029902\n      0.458717\n      0.648120\n      0.896864\n      0.160396\n    \n    \n      2\n      0.671711\n      0.174232\n      0.278023\n      0.959027\n      0.929187\n      0.894054\n      0.655200\n      0.942286\n      0.975562\n      0.765088\n      ...\n      0.160538\n      0.400109\n      0.135024\n      0.272108\n      0.661908\n      0.203095\n      0.493434\n      0.395530\n      0.027857\n      0.724801\n    \n    \n      3\n      0.912066\n      0.867228\n      0.696670\n      0.350903\n      0.308767\n      0.833534\n      0.860486\n      0.601825\n      0.634225\n      0.363727\n      ...\n      0.714588\n      0.549787\n      0.644255\n      0.187938\n      0.006522\n      0.175178\n      0.367586\n      0.702406\n      0.469907\n      0.028718\n    \n    \n      4\n      0.407295\n      0.005681\n      0.669659\n      0.742074\n      0.134489\n      0.336690\n      0.847053\n      0.454356\n      0.253618\n      0.395133\n      ...\n      0.279085\n      0.015945\n      0.397974\n      0.670957\n      0.761961\n      0.857324\n      0.689408\n      0.500088\n      0.837236\n      0.786871\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      0.549238\n      0.983931\n      0.616316\n      0.979573\n      0.991521\n      0.623560\n      0.240054\n      0.150167\n      0.076900\n      0.904664\n      ...\n      0.624767\n      0.508215\n      0.721488\n      0.125900\n      0.341007\n      0.194615\n      0.169541\n      0.113740\n      0.643763\n      0.949376\n    \n    \n      996\n      0.298990\n      0.557697\n      0.919112\n      0.632737\n      0.205327\n      0.793606\n      0.883850\n      0.878186\n      0.757498\n      0.657648\n      ...\n      0.730948\n      0.511767\n      0.178073\n      0.767833\n      0.274780\n      0.684812\n      0.523172\n      0.947464\n      0.204050\n      0.006956\n    \n    \n      997\n      0.310442\n      0.141863\n      0.507655\n      0.597543\n      0.309384\n      0.705092\n      0.469655\n      0.942340\n      0.362111\n      0.298743\n      ...\n      0.494237\n      0.832757\n      0.152577\n      0.365978\n      0.656360\n      0.722871\n      0.537215\n      0.830815\n      0.864335\n      0.227395\n    \n    \n      998\n      0.087585\n      0.461775\n      0.996273\n      0.740516\n      0.224738\n      0.552139\n      0.189635\n      0.652741\n      0.267166\n      0.568535\n      ...\n      0.035277\n      0.494617\n      0.816259\n      0.991288\n      0.463856\n      0.375362\n      0.745862\n      0.900269\n      0.183644\n      0.821859\n    \n    \n      999\n      0.926170\n      0.037719\n      0.348960\n      0.563737\n      0.921457\n      0.525878\n      0.459770\n      0.745981\n      0.834370\n      0.844547\n      ...\n      0.382454\n      0.830025\n      0.655860\n      0.256822\n      0.577537\n      0.177064\n      0.610304\n      0.197392\n      0.857057\n      0.263141\n    \n  \n\n1000 rows × 1731 columns"
  },
  {
    "objectID": "4.1_generate_alternative_flux_modes_matrix.html#expand-matrix-to-include-all-reactions-in-model",
    "href": "4.1_generate_alternative_flux_modes_matrix.html#expand-matrix-to-include-all-reactions-in-model",
    "title": "Alternative Flux Modes",
    "section": "Expand matrix to include all reactions in model",
    "text": "Expand matrix to include all reactions in model\nNow we use this dataframe with random weightings and transfer it to all of the reactions in the model. The random weighting is the same across phases for each reaction and set to zero for reactions that are not ‘real’.\n\nall_reactions_random_weightings_dict = {}\nfor reaction in model.reactions:\n    if reaction.id[:-2] in random_matrix_df.columns:\n        all_reactions_random_weightings_dict[reaction.id] = random_matrix_df.loc[:, reaction.id[:-2]]\n    else:\n        all_reactions_random_weightings_dict[reaction.id] = np.zeros(len(random_matrix_df.index))\nrandom_weights_df = pd.DataFrame.from_dict(all_reactions_random_weightings_dict)\nrandom_weights_df\n\n\n\n\n\n  \n    \n      \n      EX_X_pi_t_me_1\n      EX_X_pi_t_me_2\n      EX_X_pi_t_me_3\n      EX_X_pi_t_me_4\n      EX_X_pi_t_gc_1\n      EX_X_pi_t_gc_2\n      EX_X_pi_t_gc_3\n      EX_X_pi_t_gc_4\n      EX_X_CO2_t_me_1\n      EX_X_CO2_t_me_2\n      ...\n      K_total_pseudolinker_3\n      K_total_pseudolinker_4\n      Cl_total_pseudolinker_1\n      Cl_total_pseudolinker_2\n      Cl_total_pseudolinker_3\n      Cl_total_pseudolinker_4\n      CIT_total_pseudolinker_1\n      CIT_total_pseudolinker_2\n      CIT_total_pseudolinker_3\n      CIT_total_pseudolinker_4\n    \n  \n  \n    \n      0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.573895\n      0.573895\n      0.943229\n      0.943229\n      0.943229\n      0.943229\n      0.787065\n      0.787065\n      0.787065\n      0.787065\n    \n    \n      1\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.648120\n      0.648120\n      0.896864\n      0.896864\n      0.896864\n      0.896864\n      0.160396\n      0.160396\n      0.160396\n      0.160396\n    \n    \n      2\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.395530\n      0.395530\n      0.027857\n      0.027857\n      0.027857\n      0.027857\n      0.724801\n      0.724801\n      0.724801\n      0.724801\n    \n    \n      3\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.702406\n      0.702406\n      0.469907\n      0.469907\n      0.469907\n      0.469907\n      0.028718\n      0.028718\n      0.028718\n      0.028718\n    \n    \n      4\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.500088\n      0.500088\n      0.837236\n      0.837236\n      0.837236\n      0.837236\n      0.786871\n      0.786871\n      0.786871\n      0.786871\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.113740\n      0.113740\n      0.643763\n      0.643763\n      0.643763\n      0.643763\n      0.949376\n      0.949376\n      0.949376\n      0.949376\n    \n    \n      996\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.947464\n      0.947464\n      0.204050\n      0.204050\n      0.204050\n      0.204050\n      0.006956\n      0.006956\n      0.006956\n      0.006956\n    \n    \n      997\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.830815\n      0.830815\n      0.864335\n      0.864335\n      0.864335\n      0.864335\n      0.227395\n      0.227395\n      0.227395\n      0.227395\n    \n    \n      998\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.900269\n      0.900269\n      0.183644\n      0.183644\n      0.183644\n      0.183644\n      0.821859\n      0.821859\n      0.821859\n      0.821859\n    \n    \n      999\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      ...\n      0.197392\n      0.197392\n      0.857057\n      0.857057\n      0.857057\n      0.857057\n      0.263141\n      0.263141\n      0.263141\n      0.263141\n    \n  \n\n1000 rows × 7093 columns"
  },
  {
    "objectID": "4.1_generate_alternative_flux_modes_matrix.html#combine-random-weights-with-phase-weighting",
    "href": "4.1_generate_alternative_flux_modes_matrix.html#combine-random-weights-with-phase-weighting",
    "title": "Alternative Flux Modes",
    "section": "Combine random weights with phase-weighting",
    "text": "Combine random weights with phase-weighting\nAs we’ve done previously, we want to adjust the weights of reactions to take into account the different lengths of phases.\n\nfull_weights_df = pd.Series(get_weightings(model)) * random_weights_df\nfull_weights_df = full_weights_df.round(8)  # round to bring down below git max file size\nfull_weights_df\n\n\n\n\n\n  \n    \n      \n      10_FORMYL_THF_pc_gc_1\n      10_FORMYL_THF_pc_gc_2\n      10_FORMYL_THF_pc_gc_3\n      10_FORMYL_THF_pc_gc_4\n      10_FORMYL_THF_pc_me_1\n      10_FORMYL_THF_pc_me_2\n      10_FORMYL_THF_pc_me_3\n      10_FORMYL_THF_pc_me_4\n      1TRANSKETO_RXN_p_gc_1\n      1TRANSKETO_RXN_p_gc_2\n      ...\n      sSUC_biomass_me_3\n      sSUC_biomass_me_4\n      unlProtHYPO_c_gc_1\n      unlProtHYPO_c_gc_2\n      unlProtHYPO_c_gc_3\n      unlProtHYPO_c_gc_4\n      unlProtHYPO_c_me_1\n      unlProtHYPO_c_me_2\n      unlProtHYPO_c_me_3\n      unlProtHYPO_c_me_4\n    \n  \n  \n    \n      0\n      3.196322\n      0.266360\n      6.126284\n      3.196322\n      2.003810\n      0.166984\n      3.840636\n      2.003810\n      4.628290\n      0.385691\n      ...\n      3.685919\n      1.923088\n      3.013075\n      0.251090\n      5.775060\n      3.013075\n      4.919640\n      0.409970\n      9.429310\n      4.919640\n    \n    \n      1\n      2.976393\n      0.248033\n      5.704753\n      2.976393\n      0.059372\n      0.004948\n      0.113797\n      0.059372\n      3.306903\n      0.275575\n      ...\n      11.088275\n      5.785187\n      4.092069\n      0.341006\n      7.843133\n      4.092069\n      0.268098\n      0.022342\n      0.513855\n      0.268098\n    \n    \n      2\n      3.812475\n      0.317706\n      7.307244\n      3.812475\n      3.160252\n      0.263354\n      6.057151\n      3.160252\n      1.036738\n      0.086395\n      ...\n      5.557520\n      2.899576\n      3.424889\n      0.285407\n      6.564371\n      3.424889\n      1.629429\n      0.135786\n      3.123073\n      1.629429\n    \n    \n      3\n      0.186226\n      0.015519\n      0.356934\n      0.186226\n      1.913905\n      0.159492\n      3.668317\n      1.913905\n      4.470282\n      0.372524\n      ...\n      2.648911\n      1.382040\n      4.475259\n      0.372938\n      8.577580\n      4.475259\n      0.418057\n      0.034838\n      0.801276\n      0.418057\n    \n    \n      4\n      1.899401\n      0.158283\n      3.640519\n      1.899401\n      1.419532\n      0.118294\n      2.720771\n      1.419532\n      3.441213\n      0.286768\n      ...\n      4.127187\n      2.153315\n      3.283695\n      0.273641\n      6.293748\n      3.283695\n      4.740312\n      0.395026\n      9.085597\n      4.740312\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      2.852690\n      0.237724\n      5.467655\n      2.852690\n      0.020950\n      0.001746\n      0.040154\n      0.020950\n      3.208964\n      0.267414\n      ...\n      5.407379\n      2.821241\n      5.569828\n      0.464152\n      10.675504\n      5.569828\n      1.066897\n      0.088908\n      2.044886\n      1.066897\n    \n    \n      996\n      2.628661\n      0.219055\n      5.038267\n      2.628661\n      3.061566\n      0.255130\n      5.868001\n      3.061566\n      0.898539\n      0.074878\n      ...\n      8.525851\n      4.448270\n      5.790531\n      0.482544\n      11.098518\n      5.790531\n      3.936361\n      0.328030\n      7.544692\n      3.936361\n    \n    \n      997\n      1.765245\n      0.147104\n      3.383386\n      1.765245\n      1.824386\n      0.152032\n      3.496741\n      1.824386\n      1.165449\n      0.097121\n      ...\n      10.186639\n      5.314768\n      0.586656\n      0.048888\n      1.124424\n      0.586656\n      4.460932\n      0.371744\n      8.550119\n      4.460932\n    \n    \n      998\n      2.427627\n      0.202302\n      4.652951\n      2.427627\n      1.101725\n      0.091810\n      2.111640\n      1.101725\n      1.543910\n      0.128659\n      ...\n      9.506838\n      4.960089\n      3.335862\n      0.277988\n      6.393735\n      3.335862\n      0.364925\n      0.030410\n      0.699439\n      0.364925\n    \n    \n      999\n      5.600001\n      0.466667\n      10.733334\n      5.600001\n      3.066118\n      0.255510\n      5.876726\n      3.066118\n      0.754813\n      0.062901\n      ...\n      10.094004\n      5.266437\n      4.535840\n      0.377987\n      8.693693\n      4.535840\n      1.374694\n      0.114558\n      2.634830\n      1.374694\n    \n  \n\n1000 rows × 7093 columns"
  },
  {
    "objectID": "4.1_generate_alternative_flux_modes_matrix.html#confirm-uniform-distributions",
    "href": "4.1_generate_alternative_flux_modes_matrix.html#confirm-uniform-distributions",
    "title": "Alternative Flux Modes",
    "section": "Confirm uniform distributions:",
    "text": "Confirm uniform distributions:\n\nrandom_ids = random.sample(real_reaction_ids, 10)\n\nfig, axs = plt.subplots(len(random_ids), 4, figsize=(4 * 4, 3 * len(random_ids)), sharex=\"col\", sharey=True)\n\nfor x in range(4):\n    for y in range(len(random_ids)):\n        axs[y][x].hist(full_weights_df.loc[:, f\"{random_ids[y]}_{x + 1}\"], bins=50)\n        axs[y][x].set_xlabel(f\"Reaction weight in phase {x + 1}\")\n        axs[y][0].set_ylabel(random_ids[y])\n\n\n\n\n\nfull_weights_df.to_csv(\"../outputs/alternative_weighting/alternative_weights.csv\")"
  },
  {
    "objectID": "3.1_generate_constraints_df.html",
    "href": "3.1_generate_constraints_df.html",
    "title": "Constraint scan",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport pyDOE\nfrom mmon_gcm.constraintscan import generate_constraints_df"
  },
  {
    "objectID": "3.1_generate_constraints_df.html#define-parameter-bounds",
    "href": "3.1_generate_constraints_df.html#define-parameter-bounds",
    "title": "Constraint scan",
    "section": "Define parameter bounds",
    "text": "Define parameter bounds\n\nparameter_bounds = {}"
  },
  {
    "objectID": "3.1_generate_constraints_df.html#photons",
    "href": "3.1_generate_constraints_df.html#photons",
    "title": "Constraint scan",
    "section": "Photons",
    "text": "Photons\nWe can go 10% above and below the value for photon reflectance and transmission from Zhu et al (2010)\n\nparameter_bounds[\"P_abs\"] = [0.9*0.9, 0.9*1.1, r\"Dimensionless\",\n                             \"90% of Zhu, Long, and Ort (2010)\", \"110% of Zhu, Long, and Ort (2010)\"]  # proportion of photons absorbed by the leaf\n\nThe lower bound is the default we’ve used from Wuyts et al (2021), for a higher value we’ll use one from Ramonell 2001.\n\nparameter_bounds[\"T_l\"] = [0.017 * 10 ** -2, 0.024 * 10 ** -2, r\"m\", \"Wuyts et al. (2010)\", \"Ramonell et al. (2001)\"]\n\nThe are of the leaf being simulated is fixed at 1m\\(^2\\)\n\nparameter_bounds[\"A_l\"] = [1, 1, r\"m$^2$\", \"Fixed\", \"Fixed\"]\n\nFor the lower bound we can use the average volume of an Arabidopsis guard cell as the midpoint of the values given in table 1 of Jezek and Blatt (2017). For the upper bound we can use the volume given in Hills et al (2012).\n\nj_b_upper = 0.65\nj_b_lower = 0.3\nV_gc_ind = (j_b_lower+j_b_upper)/2  # pL\nV_gc_ind = V_gc_ind * 10**-12  # dm3\nparameter_bounds[\"V_gc_ind\"] = [V_gc_ind, 4.1E-12, r\"dm$^3$\", \"Jezek and Blatt (2017)\", \"Hills et al. (2012)\"]\n\nThe photosynthetic efficient of guard cells compared to the mesophyll was taken from Lawson (2003).\n\nIn leaves of all species the values of photosynthetic efficiency for guard cells were either indistinguishable from or only slightly lower (minimum of 79%) than those of the underlying, spongy mesophyll cells.\n\nWe’ll use these as the bounds.\n\nparameter_bounds[\"FqFm\"] = [0.79, 0.9, r\"Dimensionless\", \"Lawson (2003)\", \"Lawson (2003)\"]\n\nFujiwara et al (2019) provide a range of values for number of chloroplasts in mesophyll and guard cells, we can take the upper gc and lower me and vice versa to get the upper and lower bound for the ratios, respectively.\n\nupper_gc = 5.5\nlower_gc = 3.5\n\nupper_me = 100\nlower_me = 30\n\nrch_lower_bound = lower_gc/upper_me\nrch_upper_bound = upper_gc/lower_me\n\nparameter_bounds[\"R_ch\"] = [rch_lower_bound, rch_upper_bound, r\"Dimensionless\",\n                            \"Fujiwara, Sanjaya, and Itoh (2019)\", \"Fujiwara, Sanjaya, and Itoh (2019)\"]\n\nFor the lower bound Ramonell et al. (2001) provide a percentage of the leaf that is space at atmospheric pressure in Table 1.For the upper bound we take the proportion of the leaf that is air from Earles et al 2018 for Guzmania zahnii from Table 2.\n\nparameter_bounds[\"L_air\"] = [0.185, 0.37, r\"Dimensionless\", \"Ramonell et al. (2001)\", \"Earles et al. (2018)\"]\n\nWillmer and Fricker (1996) provide a lower bound of 0.1 and Ramonell et al. (2001) an upper bound of 0.24 for the proportion of the leaf that is epidermis.\n\nparameter_bounds[\"L_epidermis\"] = [0.1, 0.24, r\"Dimensionless\", \"Willmer and Fricker (1996)\", \"Ramonell et al. (2001)\"]"
  },
  {
    "objectID": "3.1_generate_constraints_df.html#osmolarity",
    "href": "3.1_generate_constraints_df.html#osmolarity",
    "title": "Constraint scan",
    "section": "Osmolarity",
    "text": "Osmolarity\nWang et al. (2017) use a value of 0.751 to be the proportion of the Guard Cell that is vacuole, Andrés et al. (2014) quote a value of 90% from an old MacRobbie paper.\n\nparameter_bounds[\"Vac_frac\"] = [0.751, 0.9, r\"Dimensionless\", \"Wang et al. (2017)\", \"Andrés et al. (2014) \"]\n\nA reasonable range for temperature seems to be 10C to 25C, this covers a wide range:\n\nparameter_bounds[\"T\"] = [273.15+10, 273.15+25, \"K\", \"10C\", \"25C\"]\n\nIdeal gas constant, from NIST, (reference Tiesinga2019). This is constant, so won’t change in the model\n\nR = 8.205*10**(-5)  # m3atmK-1mol-1\nR = R*10**3  # dm3atmK-1mol-1\nparameter_bounds[\"R\"] = [\n    R, R, r\"dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\", \"Tiesinga et al. (2019)\", \"Tiesinga et al. (2019)\"]\n\nThe density of guard cells per m\\(^2\\) of leaf was taken by multiplying the density of stomata from Papanatsiou et al (2016) by two. This only takes into account the abaxial surface of the leaf, so for the upper bound, we’ll double this again. For the lower bound, we’ll use a value for Commelina from Willmer and Fricker (1996).\n\nparameter_bounds[\"N_gcs\"] = [172 * 10 ** 6, 290 * 10 ** 6 * 2.0 * 2,\n                             r\"GCs$\\cdot$m$^{-2}$\", \"Willmer and Fricker (1996)\", \"Papanatsiou, Amtmann, and Blatt (2016)\"]\n\nThe following parameters required for osmolarity are based taking values from an older OnGuard paper (Wang et al. (2012)) and the newer, updated model (Wang et al 2017).\n\nparameter_bounds[\"n\"] = [1.5, 2.5, \"atm\", \"Wang et al. (2012)\", \"Wang et al. (2017)\"]\nparameter_bounds[\"m\"] = [0.8, 1, r\"atm$\\cdot$µm$^{-1}$\", \"Wang et al. (2017)\", \"Wang et al. (2012)\"]\nparameter_bounds[\"r\"] = [0.05 * 10 ** (-12), 0.08 * 10 ** (-12),\n                         r\"dm$^3$ µm$^{-1}$\", \"Wang et al. (2017)\", \"Wang et al. (2012)\"]\nparameter_bounds[\"s\"] = [0.1 * 10 ** (-12), 0.3 * 10 ** (-12), r\"dm$^3$\", \"Wang et al. (2012)\", \"Wang et al. (2017)\"]\n\nFor the apoplastic concentration, we use the value from the OnGuard model as the lower bound, and use a combination of values which have been collated by Roelfsema and Hedrich (2002) from Lohaus et al. (2001) for the upper bound:\n\napoplastic_concs_wang_2017 = {\n    \"K\": 10,\n    \"Ca\": 1,\n    \"Cl\": 12,\n    \"Suc\": 0.01,\n    \"MH2\": 3.2*10**(-6),\n    \"MH\": 7.9*10**(-5),\n    \"M\": 0.00999,\n}\napoplastic_conc_wang_2017 = sum(apoplastic_concs_wang_2017.values())\n\n\napoplastic_concs_roelfsema_2002 = {\n    \"K\": 13,\n    \"Ca\": 0.7,\n    \"Cl\": 11,\n    \"Suc\": 1.6,\n    \"Mal\": 0.7,\n    \"Amino Acids\": 9.6,\n    \"Hexoses\": 0.7,\n}\napoplastic_conc_roelfsema_2002 = sum(apoplastic_concs_roelfsema_2002.values())\n\n\nparameter_bounds[\"C_apo\"] = [apoplastic_conc_wang_2017*10 **\n                             (-3), apoplastic_conc_roelfsema_2002*10**(-3), r\"mol$\\cdot$dm$^{-3}$\", \"Wang et al. (2017)\", \"Roelfsema and Hedrich (2002)\"]"
  },
  {
    "objectID": "3.1_generate_constraints_df.html#apertures",
    "href": "3.1_generate_constraints_df.html#apertures",
    "title": "Constraint scan",
    "section": "Apertures",
    "text": "Apertures\nFor the closed aperture, we’ll use 1 µm value from Jezek and Blatt (2017) as a lower bound and 4 µm from Wang et al. (2017) as an upper bound.\n\nparameter_bounds[\"A_closed\"] = [1, 4, r\"µm\", \"Jezek and Blatt (2017)\", \"Wang et al. (2017)\"]\n\nFor the open aperture, we’ll use the 2.75 µm from Horrer et al. (2016) as the lower bound and 12 µm from Wang et al. (2017) as the upper bound.\n\nparameter_bounds[\"A_open\"] = [2.75, 12, r\"µm\", \"Horrer et al. (2016)\", \"Wang et al. (2017)\"]\n\nFor the proportion of photons that are absorbed by the leaf we can just go for 10% above and below the value that is reported by"
  },
  {
    "objectID": "3.1_generate_constraints_df.html#atpase",
    "href": "3.1_generate_constraints_df.html#atpase",
    "title": "Constraint scan",
    "section": "ATPase",
    "text": "ATPase\nWe’ll go between constraining the ATPase to 0 and the level of ATPase that Flütsch et al. (2020) measured (17 fmoles\\(\\cdot\\)GC\\(^{-1}\\cdot\\)h\\(^{-1}\\)).\n\nparameter_bounds[\"ATPase\"] = [\n    0, 17, r\"fmoles$\\cdot$GC$^{-1}\\cdot$h$^{-1}$\", \"Supplementary\", \"Flütsch et al. (2020)\"]\n\n\nparams_df = pd.DataFrame.from_dict(parameter_bounds, orient=\"index\", columns=[\n                                   \"Lower\", \"Upper\", \"Units\", \"Source Lower\", \"Source Upper\"])\nparams_df.to_csv(\"../outputs/constraint_scan/parameter_bounds.csv\")\nparams_df.to_csv(\"../plant_cell_paper/supplemental_table_2.csv\")\n\n\nparams_df\n\n\n\n\n\n  \n    \n      \n      Lower\n      Upper\n      Units\n      Source Lower\n      Source Upper\n    \n  \n  \n    \n      P_abs\n      8.100000e-01\n      9.900000e-01\n      Dimensionless\n      90% of Zhu, Long, and Ort (2010)\n      110% of Zhu, Long, and Ort (2010)\n    \n    \n      T_l\n      1.700000e-04\n      2.400000e-04\n      m\n      Wuyts et al. (2010)\n      Ramonell et al. (2001)\n    \n    \n      A_l\n      1.000000e+00\n      1.000000e+00\n      m$^2$\n      Fixed\n      Fixed\n    \n    \n      V_gc_ind\n      4.750000e-13\n      4.100000e-12\n      dm$^3$\n      Jezek and Blatt (2017)\n      Hills et al. (2012)\n    \n    \n      FqFm\n      7.900000e-01\n      9.000000e-01\n      Dimensionless\n      Lawson (2003)\n      Lawson (2003)\n    \n    \n      R_ch\n      3.500000e-02\n      1.833333e-01\n      Dimensionless\n      Fujiwara, Sanjaya, and Itoh (2019)\n      Fujiwara, Sanjaya, and Itoh (2019)\n    \n    \n      L_air\n      1.850000e-01\n      3.700000e-01\n      Dimensionless\n      Ramonell et al. (2001)\n      Earles et al. (2018)\n    \n    \n      L_epidermis\n      1.000000e-01\n      2.400000e-01\n      Dimensionless\n      Willmer and Fricker (1996)\n      Ramonell et al. (2001)\n    \n    \n      Vac_frac\n      7.510000e-01\n      9.000000e-01\n      Dimensionless\n      Wang et al. (2017)\n      Andrés et al. (2014)\n    \n    \n      T\n      2.831500e+02\n      2.981500e+02\n      K\n      10C\n      25C\n    \n    \n      R\n      8.205000e-02\n      8.205000e-02\n      dm$^3$$\\cdot$atm$\\cdot$K$^{-1}$$\\cdot$mol$^{-1}$\n      Tiesinga et al. (2019)\n      Tiesinga et al. (2019)\n    \n    \n      N_gcs\n      1.720000e+08\n      1.160000e+09\n      GCs$\\cdot$m$^{-2}$\n      Willmer and Fricker (1996)\n      Papanatsiou, Amtmann, and Blatt (2016)\n    \n    \n      n\n      1.500000e+00\n      2.500000e+00\n      atm\n      Wang et al. (2012)\n      Wang et al. (2017)\n    \n    \n      m\n      8.000000e-01\n      1.000000e+00\n      atm$\\cdot$µm$^{-1}$\n      Wang et al. (2017)\n      Wang et al. (2012)\n    \n    \n      r\n      5.000000e-14\n      8.000000e-14\n      dm$^3$ µm$^{-1}$\n      Wang et al. (2017)\n      Wang et al. (2012)\n    \n    \n      s\n      1.000000e-13\n      3.000000e-13\n      dm$^3$\n      Wang et al. (2012)\n      Wang et al. (2017)\n    \n    \n      C_apo\n      2.302007e-02\n      3.730000e-02\n      mol$\\cdot$dm$^{-3}$\n      Wang et al. (2017)\n      Roelfsema and Hedrich (2002)\n    \n    \n      A_closed\n      1.000000e+00\n      4.000000e+00\n      µm\n      Jezek and Blatt (2017)\n      Wang et al. (2017)\n    \n    \n      A_open\n      2.750000e+00\n      1.200000e+01\n      µm\n      Horrer et al. (2016)\n      Wang et al. (2017)\n    \n    \n      ATPase\n      0.000000e+00\n      1.700000e+01\n      fmoles$\\cdot$GC$^{-1}\\cdot$h$^{-1}$\n      Supplementary\n      Flütsch et al. (2020)\n    \n  \n\n\n\n\n\nGenerate constraints array\n\nnp.random.seed(31415)\nlhs_df = pd.DataFrame(pyDOE.lhs(len(params_df), samples=1000), columns=params_df.index)\n\n\nlhs_df\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      R\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n    \n  \n  \n    \n      0\n      0.598283\n      0.382096\n      0.360196\n      0.096058\n      0.430689\n      0.582219\n      0.965869\n      0.174251\n      0.310949\n      0.676081\n      0.350129\n      0.307338\n      0.329932\n      0.277458\n      0.840608\n      0.841386\n      0.201685\n      0.551405\n      0.514984\n      0.049579\n    \n    \n      1\n      0.395895\n      0.834124\n      0.403975\n      0.670988\n      0.555089\n      0.224124\n      0.882185\n      0.501864\n      0.275227\n      0.569901\n      0.082091\n      0.561464\n      0.694335\n      0.266096\n      0.071217\n      0.924072\n      0.281912\n      0.943401\n      0.576307\n      0.877863\n    \n    \n      2\n      0.344619\n      0.107536\n      0.511027\n      0.111285\n      0.243491\n      0.818683\n      0.350414\n      0.215672\n      0.200350\n      0.145697\n      0.429363\n      0.875809\n      0.939880\n      0.508252\n      0.183596\n      0.806334\n      0.224396\n      0.648303\n      0.356931\n      0.092135\n    \n    \n      3\n      0.751033\n      0.026151\n      0.655720\n      0.153535\n      0.469648\n      0.780116\n      0.611487\n      0.812458\n      0.290134\n      0.605398\n      0.299345\n      0.557861\n      0.151735\n      0.558696\n      0.037498\n      0.799401\n      0.308932\n      0.694694\n      0.995071\n      0.095047\n    \n    \n      4\n      0.350846\n      0.468450\n      0.565799\n      0.351265\n      0.358483\n      0.736410\n      0.850171\n      0.353026\n      0.487027\n      0.192733\n      0.525284\n      0.117137\n      0.556712\n      0.203088\n      0.819383\n      0.454055\n      0.891758\n      0.308953\n      0.885298\n      0.012697\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      995\n      0.467396\n      0.523844\n      0.164472\n      0.926516\n      0.000909\n      0.586268\n      0.905711\n      0.412156\n      0.702914\n      0.323484\n      0.330463\n      0.400680\n      0.868469\n      0.693086\n      0.472039\n      0.804197\n      0.740728\n      0.702568\n      0.664242\n      0.072167\n    \n    \n      996\n      0.239250\n      0.608484\n      0.862220\n      0.038286\n      0.637539\n      0.423608\n      0.911187\n      0.865959\n      0.239153\n      0.688343\n      0.074856\n      0.380041\n      0.592303\n      0.853966\n      0.603645\n      0.718571\n      0.511484\n      0.780458\n      0.973929\n      0.979101\n    \n    \n      997\n      0.898836\n      0.490542\n      0.558371\n      0.524065\n      0.195645\n      0.396144\n      0.308697\n      0.359794\n      0.433892\n      0.938592\n      0.210794\n      0.874929\n      0.802742\n      0.793727\n      0.547461\n      0.972227\n      0.151030\n      0.168309\n      0.122978\n      0.333262\n    \n    \n      998\n      0.130157\n      0.051106\n      0.018765\n      0.517490\n      0.432583\n      0.866775\n      0.125102\n      0.968265\n      0.278008\n      0.333859\n      0.928970\n      0.011777\n      0.761461\n      0.388600\n      0.938613\n      0.293328\n      0.662041\n      0.464024\n      0.512581\n      0.482024\n    \n    \n      999\n      0.479688\n      0.950291\n      0.708046\n      0.903471\n      0.260669\n      0.338951\n      0.008769\n      0.479281\n      0.668033\n      0.665242\n      0.164595\n      0.681543\n      0.446325\n      0.561493\n      0.966107\n      0.919312\n      0.781869\n      0.338209\n      0.394723\n      0.863794\n    \n  \n\n1000 rows × 20 columns\n\n\n\n\nconstraints_df = generate_constraints_df(lhs_df, params_df)\nconstraints_df.head()\n\nRemoving 28 combinations where open aperture is smaller than closed\n\n\n\n\n\n\n  \n    \n      \n      P_abs\n      T_l\n      A_l\n      V_gc_ind\n      FqFm\n      R_ch\n      L_air\n      L_epidermis\n      Vac_frac\n      T\n      R\n      N_gcs\n      n\n      m\n      r\n      s\n      C_apo\n      A_closed\n      A_open\n      ATPase\n    \n  \n  \n    \n      0\n      0.917691\n      0.000197\n      1.0\n      8.232099e-13\n      0.837376\n      0.121362\n      0.363686\n      0.124395\n      0.797331\n      293.291212\n      0.08205\n      4.756498e+08\n      1.829932\n      0.855492\n      7.521823e-14\n      2.682773e-13\n      0.025900\n      2.654215\n      7.513602\n      0.842851\n    \n    \n      1\n      0.881261\n      0.000228\n      1.0\n      2.907333e-12\n      0.851060\n      0.068245\n      0.348204\n      0.170261\n      0.792009\n      291.698522\n      0.08205\n      7.267261e+08\n      2.194335\n      0.853219\n      5.213651e-14\n      2.848145e-13\n      0.027046\n      3.830202\n      8.080839\n      14.923673\n    \n    \n      2\n      0.872031\n      0.000178\n      1.0\n      8.784094e-13\n      0.816784\n      0.156438\n      0.249827\n      0.130194\n      0.780852\n      285.335460\n      0.08205\n      1.037300e+09\n      2.439880\n      0.901650\n      5.550787e-14\n      2.612669e-13\n      0.026224\n      2.944908\n      6.051611\n      1.566297\n    \n    \n      3\n      0.945186\n      0.000172\n      1.0\n      1.031566e-12\n      0.841661\n      0.150717\n      0.298125\n      0.213744\n      0.794230\n      292.230971\n      0.08205\n      7.231671e+08\n      1.651735\n      0.911739\n      5.112495e-14\n      2.598802e-13\n      0.027432\n      3.084081\n      11.954409\n      1.615792\n    \n    \n      4\n      0.873152\n      0.000203\n      1.0\n      1.748335e-12\n      0.829433\n      0.144234\n      0.342282\n      0.149424\n      0.823567\n      286.040989\n      0.08205\n      2.877316e+08\n      2.056712\n      0.840618\n      7.458150e-14\n      1.908111e-13\n      0.035754\n      1.926858\n      10.939009\n      0.215853\n    \n  \n\n\n\n\n\nconstraints_df.to_csv(\"../outputs/constraint_scan/constraints_df.csv\")"
  }
]